var store = [{
        "title": "DevSDK 블로그, 시작합니다.",
        "excerpt":"이번에, Jekyll + Github IO 묶어서, 블로그를 새로 시작합니다. 목적은 그냥 개발 노트 겸 기술 이야기를 할 목적입니다. 이 블로그를 만드는것도 좀 짜증났는데, 우선 망할놈의 jekyll 스킨을 고르는 시간도 꽤 걸렸구요. 고른 스킨도 색상이 영 맘에 안들어서 css를 직접 수정해가며 바꿨습니다. 그리고 Tag System도 넣었고요. 나중에 좀더 개선할 여지가 보이긴 합니다. 아무튼, 최근 하고 있는 Game Engine 개발 \tGitHub 및 공부용으로 개발할 운영체제인 0SOS(제로 S OS)를 개발하면서, 또는 중간중간 개발 관련된 글을 쭉 올리도록 하겠습니다. ","categories": ["development"],
        "tags": ["Jekyll","GitHubIO"],
        "url": "https://devsdk.github.io/ko/development/2017/06/26/FirstPost.html"
      },{
        "title": "Comet Engine에 들어간 Custom Allocator에 대한 이야기",
        "excerpt":"한 2주 전 부터 고민하던 내용이였던 Costom Allocator 을 구현할까? 말까에 대한 내용인데, System Allocator을 쓰면 C 에서는 malloc, C++에서는 new를 사용한다. 문제는 속도가 ms 단위로 빨라야 할 곳에 저것들은 느려 느리다고. 우선, Memory Allocation과정에서 발생하는 User-Kernel Mode 간의 Context Switch 비용도 무시할 수 없을 뿐더러, 우리가 모르는 부가적인 코드를 함깨 실행시키곤 하며 느리게 동작한다. 그래서 정말 빨라야 할때 빠른 메모리 할당자가 필요하다면? 이라는 주제로 한동안 고민했다. 아예 안쓰는 방법도 있긴 있다. 전부 Stack에 선언해버리거나 하는등 말이다. 하지만 그건 싫다. 그렇게 고민하다가. 지나가다가 본 자료중에 흥미로운 구조들을 많이 발견했는데, 어떤 방식을 가져갈지 고민했다. 후보로는 Pool Based Memory Allocator, Stack Based Memory Allocator 그리고 아예 OS가 하는것 마냥 운영체제마냥 Paging Address 심고 세그멘테이션 해버리게 해볼까도 고민했었는데 나중에 free라던가, 연속된 메모리 블록일경우라던가 고려할게 많았다. 그러다가 FreeList Based Allocator 자료를 보게 되었다.  Free List 는 대충 이렇게 생겼다. 간단히 말하면 비어있는 메모리를 그 메모리를 이용해 Linked List로 만들고, 메모리를 할당할때 그 리스트에서 크기를 잘라 준다. Free 하면 그 리스트에 이어버린다(물론 추가적인거로는 인접할경우 이전블록을 크게 키운다거나 하기도 함) 내부적으로는 할당하면서 할당된 메모리 블록에 Header를 심는데, 16바이트 크기의 해더를 심고 사용자에게는 16바이트 이후의 주소를 준다. 즉 실제로 할당되는 크기는 요청 사이즈 + 해더 사이즈 + Align 유지를 위한 사이즈. 이렇게 해두면 Free 할때 해더정보를 읽어서 Free 할 수 있다. Free 할땐 Header를 포함한 그 메모리 블록에 다시 FreeList Node를 심고 이어서 FreeList로 만듬. 간단함. 아무튼간 대충 이렇게 동작해먹는걸 내 엔진에 구현했다.  내부 구현 및 구조를 보고 싶으면 여기서 보기 바람. (FreeListAllocator Class) 사용 방법은 다음과 같은데, char* MemoryBlock = new char[1024 * 1024 * 10];Memory::FreeListAllocator allocator = Memory::FreeListAllocator(MemoryBlock, 4, 1024 * 1024);할당자의 대상이 될 메모리 블록을 선언한다. 그러곤 FreeListAllocator를 초기화 한다. allocator.alloc(size_t);allocator.dealloc(void*);각각 할당과 해제를 하는 함수다. 뭐 동작은 위 이미지에서 보듯 잘 된다. 게다가 Align 유지까지 됨. 만들었으니 빠르다는걸 검증을 해야지 나는 빠를것이다 라고 믿고있었고 테스트를 진행했다.  테스트 조건은 배열크기 1000짜리 int 형 배열을 10000번 반복해 만들떄임. ( sizeof(int)*1000) iteration 10000 time. ) 결과로 보듯 약 10배 차이난다.             System Alloc      Custom Alloc      System Free      Custom Free                  0.0120 s      0.0015 s      0.0091 s      0.0013 s      아무튼 빠르니까 기분 좋네. 나중에 Proxy 물려서 Profiler 넣든 하거나, Leak Management를 넣으면 좋을듯. ","categories": ["development"],
        "tags": ["CometEngine","GameEngine","Memory","Optimization","최적화"],
        "url": "https://devsdk.github.io/ko/development/2017/06/26/Custom-Allocator.html"
      },{
        "title": "OS개발-Frame Buffer에 때려박자.",
        "excerpt":"다른모드는 아직 안만져 봐서 모르겠는데 그리고 GUI 쪽 FrameBuffer은 어떨지 모르지만 일단 아는 한에서 씀 리얼모드에서 텍스트 Video Memory 주소는 0xB800이다. 여기서 한 글자는 2바이트를 먹는데, 1바이트는 아스키 케릭터 값, 2바이트는 속성값이다. 자세한건 여기서 그러니까 부트로더를 짤때든 언제든 0xB800에 순서대로 ‘H’,속성,’E’,(속성)… 이렇게 집어넣으면 글자가 뜬다. 물론 깨끗하게 나올리가 없지. 기존에 ( QEMU ) BIOS가 만들어낸 데이터를 싹 비워줘야 한다. 그걸 위해서 Frame Buffer를 싹 비워줘야한다 ( 0으로 설정해야한다. ) 비워주면서 속성도 넣어주고.. [ORG 0x00]              ; Start Address 0x00[BITS 16]               ; 16 bit codesSECTION .text           ;text section.jmp 0x07C0:START        ;코드 시작주로소 간다.START:\tmov ax, 0x07C0      ; 부트로더의 시작 주소 ( 그 이전 주소엔 잡다한거 들어있음.)\tmov ds, ax          ; 데이터 세그멘트 지정\tmov ax, 0xB800      ; 비디오 메모리 주소 지정\tmov es, ax\tmov si, 0           ; 문자열 indexing에 쓰일 레지스터\t.SCREENCLEARLOOP        ; 화면 비우는 레이블\tmov byte[ es: si],0 ; 0xB800부터 크기만큼 반복함\tmov byte[ es: si + 1], 0x0A\tadd si,2\tcmp si, 80*25*2     ; si 가 80*25*2 (비디오 메모리 크기) 작을때 아래 코드 실행\tjl .SCREENCLEARLOOP ; 반복\tmov si, 0           ;초기화\tmov di, 0.MESSAGELOOP:           ;화면에 메시지를 띄워주는 레이블\tmov cl, byte[MESSAGE1+si]   ;c언어로 치면 array[i] 임. 아래 Message1에서 하나하나씩\tcmp cl, 0                   ;0과 만나는지 봄\tje .MESSAGEEND              ;만나면 탈출\tmov byte[es:di],cl\t\tadd si, 1                   ;문자를 나타내는 인덱스\tadd di, 2                   ;비디오메모리에서 쓰이는 인덱스\tjmp .MESSAGELOOP.MESSAGEEND\tjmp $MESSAGE1:\tdb 'Hello World. Boot Loader Start', 0 times 510 - ($-$$) db 0x00db 0x55db 0xAA대충 주석좀 달아봤다 귀찮아 아무튼  잘 나온다. 딱히 뭔가 부트로더의 역할을 하는건 아니고 그냥 프레임버퍼에 글자 띄우는 바이너리가 되시겠다. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","FrameBuffer"],
        "url": "https://devsdk.github.io/ko/development/2017/06/27/Develop-OS.html"
      },{
        "title": "리얼모드에서 메모리 접근하는 방식",
        "excerpt":"2시간 날렸는데, 내가 잊어먹고 있던거였다. 분명 읽었었는데 왜 잊어버린걸까. es레지스터에 들어간 0x020을 512로 표현하고 있길레 2시간동안 엄한대서 해매고 있었네 물론 저 숫자만 보고선 32다. 절대로 512일리가 없지 잊지말자. CS, DS, ES, FS, SS 등등등 리얼모드에선 세그멘트 레지스터에 16을 곱한뒤 범용레지스터 값과 더한걸 물리 메모리 주소로 쓴다. 즉 어셈블리에 mov si, 0x0020 mov es, si이런 코드가 있으면 뒤에 0하나 더 붙는다고 생각하자. 분명 기본적인거고, 봤던건데 잊고있었다. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Memory"],
        "url": "https://devsdk.github.io/ko/development/2017/06/27/RealModeMemory.html"
      },{
        "title": "그 어느 서적을 읽던, 이상하다 싶으면 오탈자인지 찾아보셔야 합니다.",
        "excerpt":"OS 책 읽으면서 (64비트 멀티코어 OS 원리와 구조) 설명을 읽고, 내 지식을 가지고 example code를 한참 들여다 보았다. 149쪽 함수 호출쪽. 그 이유는 스택 프레임에서 함수 안에는 변수 하나밖에 없는데, 스텍포인터를 8바이트나 내려버렸다. 뒷 내용도 그래서 뭔가 이상했다. 그래서 좀 더 찾아보고 오탈자 여부를 찾아보고 커뮤니티같은곳에 가서 확인해본 결과 저자분게서 Visual Studio 상에서 나온 코드를 바로 넣어서 그렇게 나왓다고 하신다. 분명 VS가 뭔짓을 한게 분명해. 아무튼 한참 들여다 본 코드는     int Add(int a, int b, int c)    {        return a+b+c;    }    void main()    {        int Result;        Result = Add(1,2,3);    }나도 안다 void main은 표준이 아닌거. 책에 이렇게 써있음. 이 코드가 어셈블리로 Add:    push ebp    mov ebp, esp        mov eax, dword[ebp + 8]    add eax, dword[ebp + 12]    add eax, dword[ebp + 16]    pop ebp        ret 12main:    push ebp    mov evp, esp    sub esp, 8    push 3    push 2    push 1    call Add    mov dword[ebp - 4],eax    ret이렇게 변한다고 써있다. 문제가 됬던건 main 함수에서 3번째 그리고 마지막에서 위로 2번째 sub esp, 8mov dword[ebp - 4], eax스택프레임에서 남은 4바이트는 어디로 사라지는건가 했다. 뭔가 안에서 필요한건지, 아님 단순 오타인지 모르겠다. 아무튼 분명 c코드에는 변수 하나밖에 없는데 왠 8바이트인가 했다. 예전에 컴파일러 공부했을때도 그냥 변수당 size를 스택에 할당 해서 넣던데, 뭔가 이상했다. OS개발할땐 또 다른가 아냐 그럴리가 없어 하면서 스택프레임에 뭘 더 집어넣나 해서 보니까 그런거도 아님 찾아보니까 저자분께서 VS에서 내놓은 바이너리를 역어셈블리해서 나온코드를 넣으셔서 저렇게 들어갔다고 한다. 아무튼간, 정말 재대로 된 코드는 아마도 sub esp, 4mov dword[ebp], eax가 아닐까 싶다. 찾아보니까 저자분께서 맞다고 하신다 아무튼 또 하나 해결 ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","function"],
        "url": "https://devsdk.github.io/ko/development/2017/06/27/Do-not-believe-examplecode-in-a-book.html"
      },{
        "title": "0SOS의 첫 BootLoader.",
        "excerpt":"뭔가를 습득한다는건 참 즐겁다. 물론 좀 고생해가면서 습득해야 기억에 남기때문에, 책의 example code를 전부 따라치진 않는다. 이름 바꾸고 순서 바꾸고, 함수로도 바꿔보고. 기타등등 해보고 몇몇가지가 빠져서 고생도 해보고. 나름 그렇게 하면 재밌다. 물론 시간은 몇배 더 걸리지만. 이번에는 좀 부트로더라고 부를 수 있을거같다. 물론 플로피디스크를 대상으로 하는 것이지만, 나중에 하드디스크를 대상으로도 바꿀 수 있겠지. 아직은 배워가는 단계니까 이정도로 만족하기로 한다. 부트로더 실행해서 가상이미지 호출한 모습.  잘 실행 된다. 뒤에 1234567… 이렇게 숫자가 있는 이유는 부트로더가 재대로 돌아가는지 로드한 메모리로 점프했기 때문이다. (로드한 메모리에는 섹터마다 숫자를 증가시키게끔 만들어 두었다(askii값때문에 10보다 커질 수 없음) 참고로 숫자 개수는 정확히 1024. 불러온 섹터의 숫자이다. 아무튼 부트로더의 실행 순서는 다음과 같다. 실행하자마자 일단 초기화를 진행한다. (스택, 주소등) 그러곤 메시지 출력 함수를 실행한다. 호출규약은 C언어로 치자면 cdecl 방식이다. 인자를 호출해준 쪽이 해제하니까. 뭐 이건 별로 중요하진 않음. stdcall로 바꿔도 문제 없다. 그러곤 바이오스 서비스를 이용하기 위해서 인터럽트를 건다. 오류 발생하면 오류 핸들러쪽으로 넘기고 아니면 완료. 그러곤 로드한 메모리로 점프함. 코드 [ORG 0x00][BITS 16]SECTION .textjmp 0x07C0:START;;;;;;;;;;;;;;;;;;;;; CONFIG ;;;;;;;;;;;;;;;;;;;;;;TOTALSECTOR: dw 1024 ;START:\tmov ax, 0x07C0\tmov ds, ax\t;;;;;;;;;; STACK INITALIZATION ;;;;;;;;;;\tmov ax, 0x0000\tmov ss, ax\tmov sp, 0xFFFE\tmov bp, 0XFFFE\tmov si, 0\tcall CLEAR \t;;;;;;;;;; PRINT HELLO ;;;;;;;\tpush HELLO\tpush 0\tpush 0\tcall PRINT\tadd sp, 6\t;;;;;;;;;; PRINT LOAD INFO ;;;;;;\tpush LOADINFO\tpush 0\tpush 1\tcall PRINT\tadd sp, 6\tDISKRESET:\tmov ax, 0\tmov dl, 0\tint 0x13\tjc ERRORHANDLER\t;;;;;;;;;;; READ DISK SECTOR ;;;;;;;\tmov si, 0x1000\tmov es, si\tmov bx, 0x0000\tmov di, word[TOTALSECTOR].READ:\tcmp di, 0\tje BREAKREAD\tsub di, 0x1\tmov ah, 0x02\tmov al, 0x1\tmov ch, byte[TRACK]\tmov cl, byte[SECTOR]\tmov dh, byte[HEADER]\tmov dl, 0x00\tint 0x13\tjc ERRORHANDLER\t;;;;;;;;;; calculate Address\tadd si, 0x0020\tmov es, si\tmov al, byte[SECTOR]\tadd al, 0x01\tmov byte[SECTOR],al\tcmp al, 19\tjl .READ\txor byte[HEADER], 0x01\tmov byte[SECTOR], 0x01\tcmp byte[HEADER], 0x00\tjne .READ\tadd byte[TRACK], 0x01\t\tjmp .READBREAKREAD:\tpush LOADSUCCESS\tpush 24\tpush 1\tcall PRINT\tadd sp,6\tjmp 0x1000:0x0000ERRORHANDLER:\tpush DISKERROR\tpush 24\tpush 1\tcall PRINT\tjmp $PRINT:\tpush bp,\tmov bp, sp\t\tpush es\tpush si\tpush di\tpush ax\tpush cx\tpush dx\t\tmov ax, 0xB800\tmov es, ax\tmov ax, word[bp + 4]\tmov si, 160\tmul si\tmov di, ax\tmov ax, word[bp + 6]\tmov si, 2\tmul si\tadd di, ax\tmov si, word[bp+8].PRINTLOOP\tmov cl, byte[si]\tcmp cl,0\tje .ENDPRINTLOOP\tmov byte[es:di], cl\tadd si, 1\tadd di, 2\tjmp .PRINTLOOP.ENDPRINTLOOP\tpop dx\tpop cx\tpop ax\tpop di\tpop si\tpop es\tpop bp\tretCLEAR:\tpush bp\tmov bp, sp\t\tpush es\tpush si\tpush di\tpush ax\tpush cx\tpush dx\tmov ax, 0xB800\tmov es, ax\t.CLEARLOOP:\tmov byte[es:si],0\tmov byte[es:si+1], 0x0B\tadd si,2\t\tcmp si,80*25*2\tjl .CLEARLOOP\t\tpop dx\tpop cx\tpop ax\tpop di\tpop si\tpop es\tpop bp\tret\tHELLO: db 'Welcome To 0SOS.',0DISKERROR: db 'ERROR', 0LOADSUCCESS: db 'SUCCESS',0LOADINFO: db 'Now Loading From DISK...', 0SECTOR:\tdb 0x02HEADER:\tdb 0x00TRACK:\tdb 0x00times 510 - ($ - $$) db 0x00db 0x55db 0xAA로드 잘 됨. 잘 동작함. 이제 32비트 모드를 만질차랜가보다. 그전에 이전 작업들좀 처리하고. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Booting","function"],
        "url": "https://devsdk.github.io/ko/development/2017/06/27/MyFirstBootLoader.html"
      },{
        "title": "Comet Engine에 만들 컨테이너 라이브러리 고민",
        "excerpt":"이번 엔진은 정말 느릿느릿, 재대로 만들꺼다. 그렇다보니 빨랐으면 하고, 견고했으면 한다. 그것의 첫걸음으로 엔진 자체에서 Custom Allocator를 제공한다. 여기서 해당 내용을 볼 수 있다 아무튼간, 정말 Low-Level 하부 시스템부터 에디터까지 천천히 만들까 한다. 물론 계획된 개발 기간도 없음. (예상으론 2년 넘게 걸리지 않을까 싶다.) 두번째 걸음으로는 이제, 데이터 컨테이너 라이브러리 제공을 위한 컨테이너의 설계 및 구현이겠다. 이것도 버전을 두개로 나눠버릴까 싶다. Custom Allocator를 쓰는 버전과, System Allocator를 쓰는 버전으로. STL보단 빠를거다. 물론 동일한 알고리즘 안에서는 그리고, 추후에 수정 보완이 더 손쉬울꺼라고 믿는다. 고민중인건 Custom Allocator를 쓰는 버전에 접두사를 붙일까말까 C를 붙여볼까 고민해봤다. CArrayList&lt;int&gt;뭔가 안이뻐보이면서도 엔진 이름하고 절묘하게 맞네 시스템 얼로케이터 쓰는곳은 그냥 접두사 없이 해놔야지 아마 시스템 얼로케이터로는 VirtualAlloc를 쓸거같다. 네임스페이스도 나름 고민중인데  아마 쓰게될 후보는 CometEngine::Core::Container::C //Custom AllocatorCometEngine::Core::Container::S //System Allocator혹은 S나, C 가 없는 버전이 되겠다. 저안에 이제 열씸히 Class 화 시켜서 구조화 시켜야지 급한거 아니니까 정말 천천히 고민해가면서. 대충 STL 뜯어봐야겠다. 추가 아 그러고보니까 젠장, Thread-Safe 하게 만들어야 하는구나. 안그래도 많은 흰머리 늘겠네. ","categories": ["development"],
        "tags": ["CometEngine","GameEngine","Container","Library","Optimazation"],
        "url": "https://devsdk.github.io/ko/development/2017/06/28/ContainerConcerning.html"
      },{
        "title": "Comet Engine에 구현할 컨테이너의 구조를 대충 생각했다.",
        "excerpt":"최근에는 OS개발이 너무 재밌다 초반이라 그런가 그래서 엔진은 아마 잠깐 동결하지 않을까 싶은데.. 물론 완전히 멈춰버린다는건 아니다. 오래걸리는거 빼고 천천히 만들어야지. 몇주는 쉬었다가, 다시 잡았다가 할수도 있겠다. 몇주는 많고 몇일? 정도려나. 아무튼 오늘은 엔진에 관심좀 주자하면서 고심했다. 일단 Visual Studio 상에서 나온 Custom Memory 부분의 Warnings을 제거했다. c style casting을 static_cast 로 바꾸니까 케스팅쪽은 대부분 사라지더라 아무튼, 컨테이너라는 작지않은 라이브러리를 만들어야 한다. 그래서 코드대신에 UML을 대충 그렸다. 참고한건 Java의 컨테이너와 C#의 콜렉션이다. C++ STL도 참고했음.  함수나 맴버는 아직 정해진게 없어서 뺌 이름도 사실 확정된건 아니다. 그냥 모양세만 나온듯.. 나중에 종이에 그려가면서 고민해봐야겠다. Iterator이나 그런 패턴들은 나중에 추가할꺼다. 아무튼 기왕 Custom Allocator도 만들었겠다, 컨테이너도 만들어야지. 아무래도 Custom Allocator은 크기가 제한되어있으니까. ( Memory block을 넣어줘야하니까) 뭔가 이걸 Wrapping해서 메모리 사이즈를 늘려주는 매커니즘을 하나 해야할꺼같다. 이것만 생각해도 머리아프네. ArrayList쯤이야 그런건 손쉽겠지만, LinkedList 는… 대충 추상화해서 메모리 더 요구하는 그런코드는 하나로 묶든 해야겠다. 메모리 포인터가 바뀌게 되면 생기는 문제야 뭐… 사용자 측에서 데이터 Address 에 절대 접근 못하게 해야지. 아직 뼈대도 안나왔네 생각해보면 그리고 또 고민해야할껀 컨테이너 사에서 Thread-Safe함을 보장할껏인가. 흰머리 늘어난다. 이럼 또 느려질탠데. 대충 필요한 기능이나 이런걸 도출할 필요가 있겠다. 그건 나중에 해야하려나 STL은 영 뜯어보고 싶지가 않은 라이브러리라. 젠장 템플릿. 목표는 일단 STL보다 빠른거 근데 종종 엔진개발도 해야하는데…. 라는 생각이 들면 우울하다 OS 개발하고싶은데. 시간을 좀더 쪼개야겠다. ","categories": ["development"],
        "tags": ["CometEngine","GameEngine","Container","Library","Optimazation"],
        "url": "https://devsdk.github.io/ko/development/2017/06/28/Design-of-the-GameEngine.html"
      },{
        "title": "0SOS의 32비트 모드. Hello 32bit ProtectedMode",
        "excerpt":"와 신난다. 이제, 0SOS는 32비트 코드를 실행 할 수 있다. 그말은즉슨, 32비트 범용레지스터를 쓸 수 있다는 이야기. eax, esi 등등 같은거 말이다. 아 기뻐라. 이걸 봐라.  보면 잘 돌아간다. C언어로 하면 되는데요 같은 헛소리 할꺼면 창 닫기를 아무튼 이해하려고 용썻다. 다 이해했다. 젠장맞을, 세그먼트 테이블하고, 메모리 사용 범위, 스택때문에 좀 머리아팠음. 일단 16비트 리얼모드에서 32비트 보호모드로 바꾸려면 GDT 테이블을 구성하고 프로세서에 GDT의 크기와 위치를 알린다. 그 테이블 안에 첫번째 요소로는 NULLDescriptor이라고, 모든 필드가 0으로 초기화 한 세그먼트 디스크립터를 넣고 그다음에는 우리가 정의하는데 나와 책 저자분은 Code, Data 세그먼트 디스크립터를 넣었다. 여기서 이해하려고 용썼는데, 나는 코드와 데이터 디스크립터의 베이스 주소, 제한이 동일하길레 둘이 겹치면 안되는 거 아닌가 라는 생각을 했는데, 내가 잘못 전제를 깔고 들어갔던거다. 젠장 결국 현재 코드에선, 정확힌 지금 정의된 테이블에선 코드영역하고 Data영역하고 세그먼트 디스크립터가 구분해주지 않는다 둘다 다 0~4GB를 가르킬 수 있는 디스크립터. 그리고 스택은 위에서 아래로 자라기때문에, Data영역의 데이터랑 겹칠일은 없다. (64kb가 제한이기 떄문, 코드에서 esp, ebp를 보기 바람) 그래서 코드에 상대주소값으로 계산하는 코드가 있구만 (LABEL - $$ + 0x10000) 같은거. 아무튼 완전히 이해했으니 넘어가고 그러고 나선, 운영모드를 관리하는 CR0 레지스터를 설정해준다. 설정값은 아레 코드에 표로 만들어져 있뒀으니까 보시고, 각 요소가 뭔지 궁금하면 검색하세요. 변환후 32비트 코드영역으로 점프하면 완성. 와 신나. 아무튼 32비트 전환을 위하면서 시작점이 될 Kernel Entry Point는 다음과 같다. [ORG 0x00][BITS 16]SECTION .textSTART:\tmov ax, 0x1000\tmov ds, ax\tmov es, ax\t\tcli\t\t;Ignore Interrupt\tlgdt[GDTR]\t;\tNow Switch Protected Mode.\t;\t;   CR0 Register\t;\tSummary: \t;\t\tDisable Paging, Disable Cache, Internal FPU, Disable Align Check\t;\t;   fields:\t;\t;\t|PG|CD|NW|  |  |  |  |  |  |  |  |  |  |AM|  |WP|\t;\t31---------------------------------------------16\t;\t| 0| 1| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|\t;\t;\t|  |  |  |  |  |  |  |  |  |  |NE|ET|TS|EM|MP|PE| \t;\t15----------------------------------------------0\t;\t| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 1| 1| 1| 0| 1| 1|\t;\t;\t0b01000000000000000000000000111011\t\t; \t0x4000003B\t;\tmov eax, 0x4000003B\tmov cr0, eax\tjmp dword 0x08 : (PROTECTEDMODE - $$ + 0x10000)\t; Following Code Now Prtoected Mode[BITS 32]PROTECTEDMODE:\tmov ax, 0x10\tmov ds, ax\tmov es, ax\tmov fs, ax\tmov gs, ax\tmov ss, ax\tmov esp, 0XFFFE\tmov ebp, 0XFFFE\t\t\tpush (SWITCHMESSAGE - $$ + 0x10000)\tpush 2\tpush 0\tcall PRINT\tadd  esp, 12\tjmp $PRINT:\tpush ebp\tmov ebp, esp\tpush esi\tpush edi\tpush eax\tpush ecx\tpush edx\tmov eax, dword [ebp + 12]\tmov esi, 160\tmul esi\tmov edi, eax\t\t\tmov eax, dword[ebp + 8]\tmov esi, 2\tmul esi\tadd edi, eax\t\t\tmov esi, dword[ebp + 16]\t.PRINTLOOP:\tmov cl, byte[esi]\t\tcmp cl,0\tje PRINTEND\t\tmov byte[edi + 0xB8000], cl\t\tadd esi,1\tadd edi,2\t\tjmp .PRINTLOOP PRINTEND:\tpop edx\tpop ecx\tpop eax\tpop edi\tpop esi\tpop ebp\tret;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATA AREA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;align 8, db 0dw 0x0000\t;For AlignGDTR:\tdw GDTREND - GDT -1\tdd GDT - $$ + 0x10000GDT:\tNULLDescriptor:\tdw 0x0000\tdw 0x0000\tdb 0x00\tdb 0x00\tdb 0x00\tdb 0x00\tCODEDescriptor:\tdw 0xFFFF\t; Limit[15:0]\tdw 0x0000\t; Base[15:0]\tdb 0x00\t\t; Base[23:16]\tdb 0x9A\t\t; P = 1, DPL = 0, Code Segment, Execute/Read\tdb 0xCF\t\t; G = 1, D = 1, L = 0, Limit [19:16]\tdb 0x00\t\t; Base[31:24]\t\tDATADescriptor:\tdw 0xFFFF\t; Limit\tdw 0x0000\t; Base\tdb 0x00\t\t; Base\tdb 0x92\t\t; P=1, DPL =0, Data Segment, Read/Write\tdb 0xCF\t\t; G= 1, D= 1, L= 0, Limit\tdb 0x00\t\t; BaseGDTREND:SWITCHMESSAGE: db 'Switch Success. Now Running 32bit Protected Mode.',0times 512 - ( $ - $$) db 0x00리얼모드와 보호모드는 확실하게 메모리 접근이 다르다 이거이거 IA-32e 에서는 얼마나 복잡할지 기대되는데 게다가 페이징도 Disable인상태라 페이징 넣으면 얼마나 복잡해지려나 ㅋㅋㅋ… 아무튼 , 코드에 있는 표 나름 이쁘게 만들었다. vim에선 이렇게 보이는데  위에 코드는 어떻게 보일지 모르겠네. 아무튼 32비트 완성 이제 커널코드 작성해야겠네. ","categories": ["development"],
        "tags": ["0SOS","OS","ProtectedMode","Operating System","System","Booting","32bit"],
        "url": "https://devsdk.github.io/ko/development/2017/06/28/Hello32BIt.html"
      },{
        "title": "0SOS가 이제 C언어 코드 엔트리로 넘어갑니다. 이제 C언어다",
        "excerpt":"이번 글은 좀 길꺼같다. 휴, 하루종일 OS만 만지니까 재밌네 하나하나가 다 새롭구만 오늘 오후쯤에 0SOS는 32비트로 넘어갔었다. 뭐 잡다한 과정을 거쳤다. GDTR을 구성하고 GDT구성하고 등등등.. 자세한건 여기서 보시길 이번에는 C언어 커널 소스코드로 넘어간다.  저 한줄을 위해 몇시간을 삽질했는가. 위에서 돌린 C 코드는 다음과 같다. #include \"Types.h\"void PrintVideoMemory(int x, int y, const char* _str);void __Kernel__Entry(){\tPrintVideoMemory(0,3, \"Now C Language Binary.\");\t\twhile(1);}void PrintVideoMemory(int x, int y, const char* _str){\tCHARACTER_MEMORY* Address = ( CHARACTER_MEMORY* ) 0xB8000;\t\tint i = 0;\t\t+= ( y * 80 ) + x;\tfor ( i = 0; _str[i] != 0; i++)\t{\t\tAddress[i].bCharactor = _str[i];\t}}이 코드가 위에 보는거처럼 잘 동작한다! 이번에도 뭐가 필요한 준비과정도 많았고 삽질도 많았는데, 일단 필요한건, 링커가 동작하는걸 제어하고, 코드에 대한 빌드 스크립트 수정, 엔트리포인트에서 C언어 엔트리포인트로 점프 기본적으로 32비트 코드를 쓸 수 있기때문에 컴파일러가 뱉어내는 데이터를 쓸 수 있다. 물론 제공되는 설정으로는 쓸 수 없다. 기본적으로 제공되는 설정에서는 코드의 위치나, 재배치를 위한 코드 운영체제를 위한 코드 등등등 커널코드에 불필요한 내용들이 많기 때문이다. 라이브러리를 붙이고, 링크까지 해버리는 경우도 있다. 게다가 내가 정의한 섹션정보마져 다르다. 그래서 필요한건 링크스크립트를 수정해야 하는것. 물론 나는 링크스크립트에 대한 지식이 없었다. 저자분도 그 부분을 설명하려면 책한권분량이 나온다고 해서 일단 따라쳤다. 대충 이해가 간다. 물론 큰 구조만. 작성한 링크스크립트 전부를 올리진 않겠다. 그게 중요한게 아니다. 보고싶으시면 여기로 가서 보시길 일단 내용을 전부 이야기하기는 힘들다. 기반이 되는 코드는 /usr/lib/ldscript/elf_i386.x 에서 가져와서 불필요한 부분으로 생각되는걸 제거하고 필요한것인 섹션순서를 바꾸고, 주소를 지정해 주었다. 일단 가장 중요한 부분이 \t/*생략*/    .text 0x10200      :  {    *(.text.unlikely .text.*_unlikely .text.unlikely.*)    *(.text.exit .text.exit.*)    *(.text.startup .text.startup.*)    *(.text.hot .text.hot.*)    *(.text .stub .text.* .gnu.linkonce.t.*)    /* .gnu.warning sections are handled specially by elf32.em.  */    *(.gnu.warning)  }\t/* 생략 */  .data           :  {    *(.data .data.* .gnu.linkonce.d.*)    SORT(CONSTRUCTORS)  }  \t/* 생략 */}일단 아마, 기존의 코드를 절반이상 수정한 것 같다. 대충 보면 .text 섹션의 시작점을 0x10200으로 지정하고 데이터 섹션을 뒤에 오도록 한다. 대충 이렇게 수정하고 커널로 쓸 c언어 파일을 gcc로 옵션을 잔뜩 붙여서 컴파일한다. gcc -c -m32 -ffreestanding Main.c이렇게 컴파일하면 링킹이안되고, 32비트 코드 그리고 다른 라이브러리를 불러오지 않는다. 그렇게 생긴 목적파일을 다시 링킹해준다. 이상태로는 실행 못하고 그냥 목적파일일 뿐이다. 디스어셈블링 하면 다음과 같다. 참고로 이미지에 있는 어셈블리 코드는 위의 커널코드가 아니라 이거 글 작성용로 수 3개 더하는 함수로 예를 든거다.  보면 명령주소가 0부터 시작이다. 그래서 아까 열씸히 작성해준 링커스크립트를 이용해 링크하는데  ld -elf_i386 -nostdlib -T LinkerScript.x Main.o Main.elf뒤에 뭐가 더 붙긴하는데 생략. 저렇게 하면 명령어도 재배치가 되고 쓸수 있게끔 만들어준다.  명령어가 중요한게 아니다 그냥 시작 주소가 다르다. 아무튼, 이렇게 지정해뒀다면 마지막으로 작성한 커널 엔트리 포인트에서 32비트 코드를 초기화하고 C언어로 뽑아낸 시작점으로 점프하는 일이다.   [BITS 32]  PROTECTEDMODE:     mov ax, 0x10     mov ds, ax     mov es, ax     mov fs, ax     mov gs, ax      mov ss, ax     mov esp, 0XFFFE     mov ebp, 0XFFFE      push (SWITCHMESSAGE - $$ + 0x10000)     push 2     push 0     call PRINT     add  esp, 12      jmp dword 0x08:0x10200      ;Let's Jump To C이렇게 하고 빌드 스크립트 작성하는거도 좀 빡셧다. 아무래도 makefile 부분을 한번 살펴봐야 할거같다. 아무튼, 한두시간 삽질해가면서 빌드스크립트 쓰고 오류 수정해서 빌드 완료. 두근두근, 실행하는 순간  첫 사진처럼 나왔어야 하는데.. VM이 터져버렸다. 왜 터진지는 짐작이 갔다. 저번에 수정한 부트로더 읽을 섹션을 하나밖에 지정해주지  않았기 때문이겠지.. 수정하니까 윗 사진처럼 재대로 동작한다. 이제 저렇게 터졌을때 나온 덤프파일 읽어서 왜 그렇게 되는가를 도출해보는 연습을 해야겠다. 후우, 점점 복잡해지기 시작하는구만 끝까지 한번 해보자. ","categories": ["development"],
        "tags": ["0SOS","OS","ProtectedMode","Operating System","System","32bit","Booting","C Language"],
        "url": "https://devsdk.github.io/ko/development/2017/06/29/LetsJumpToC.html"
      },{
        "title": "출력 개선, 64비트 코드로 넘어갈 준비 끝, 이제 넘어가면 된다.",
        "excerpt":"32비트 모드로 전환하고, C언어 커널로 들어간게 바로 전인데, 또 부랴부랴 64비트 모드로 넘어갈 준비를 해야한다. 일단 그전에 이전의 출력이 맘에 안들기도 했고 책에서 보여주는 사진도 그렇고 출력을 좀 개선하기로 했다.  이게  이렇게 바뀌였다. 두번째 SUCCESS가 아니라 SICCESS 인거, 수정했다. 다만 스샷찍기 귀찮아서 그냥 기존 이미지 쓰기로 함 이거 하려고 코드좀 많이 넘나들면서 고쳤는데, 일단 16비트 부트로더에서 출력하는 부분인 1~2줄을 위해서 어셈코드를 고쳤다. 일단 이전에 출력 함수를 호출하는 구문은 \tpush HELLO\t\tpush 0\tpush 0\tcall PRINT\tadd sp, 6즉, 색상을 지정하는 코드가 없음. 그래서 고쳤다, 현제 16비트 부트로더에서 출력을 하기위해선 4개의 파라미터가 필요하다. 지금 출력을 하는 코드는 \tpush HELLO\t\tpush 0x0B\tpush 30\tpush 1\tcall PRINT\tadd sp, 8함수 내부에서도 좀 수정을 가했다. PRINT:\tpush bp,\tmov bp, sp\t\tpush es\tpush si\tpush di\tpush ax\tpush cx\tpush dx\t\tmov ax, 0xB800\tmov es, ax\tmov ax, word[bp + 4]\tmov si, 160\tmul si\tmov di, ax\tmov ax, word[bp + 6]\t\tmov si, 2\tmul si\tadd di, ax\tmov si, word[bp+10]\tmov bl, byte[bp+8]\t.PRINTLOOP\tmov cl, byte[si]\t\t\tcmp cl,0\tje .ENDPRINTLOOP\tmov byte[es:di], cl\tmov byte[es:di+1], bl\tadd si, 1\tadd di, 2\tjmp .PRINTLOOP길다, 젠장. 다 필요없고 파라미터를 처리하는 구문인 byte[bp + 8] 이런식으로 되어있는 부분중 bl 레지스터에다가 입력한 속성코드를 넣고, 출력할때 지정하는 형식으로 바꾼거다. 그 다음 3번째 줄인 32비트 보호모드 전환성공 메시지 출력을 위해 32비트 코드로 전환하는 엔트리 포인트에서 사용하는 어셈 함수를 고쳤다. 고친 내용은 비슷하다. \tpush (SUCCESS - $$ + 0x10000)\tpush 0x0A\tpush 4\tpush 60\tcall PRINT\tadd  esp, 16대충 속성을 넣는 구문이 추가됬다. 함수 부분도 역시 똑같이 고쳐졌다. PRINT:\tpush ebp\tmov ebp, esp\tpush esi\tpush edi\tpush eax\tpush ecx\tpush edx\tmov eax, dword [ebp + 12]\tmov esi, 160\tmul esi\tmov edi, eax\t\t\tmov eax, dword[ebp + 8]\tmov esi, 2\tmul esi\tadd edi, eax\tmov bl, byte[ebp + 16]\tmov esi, dword[ebp + 20]\t.PRINTLOOP:\tmov cl, byte[esi]\t\tcmp cl,0\tje PRINTEND\t\tmov byte[edi + 0xB8000], cl\tmov byte[edi + 0xB8000+1], bl\t\tadd esi,1\tadd edi,2\t\tjmp .PRINTLOOP똑같이 mov bl, byte[ebp+16] 으로 값을 넣은뒤, 출력구문에서 잘 활용한다. 그러고 나서 C언어로 진입했을때 사용하는 출력 함수인 PrintVideoMemory 함수도 파라미터를 하나 더 추가했다. 구현은 다음과 같다. void PrintVideoMemory(int x, int y, BYTE Attribute ,const char* _str){\tCHARACTER_MEMORY* Address = ( CHARACTER_MEMORY* ) 0xB8000;\t\tint i = 0;\t\tAddress+= ( y * 80 ) + x;\tfor ( i = 0; _str[i] != 0; i++)\t{\t\tAddress[i].bCharactor = _str[i];\t\tAddress\t\t[i].bAttribute = Attribute;\t\t}}뭐 내 만족을 위해서 책에 나와있지도 않은인지, 아직 안나온건진 모르겠지만 아무튼 바꿧다. 이쁘게 나오니까 기분이 좋다. 그리고, 64비트 커널이 사용할 메모리를 확보하기 위해 메모리 사이즈를 체크하고 그 공간을 0으로 초기화 하는 구문도 넣었다. BOOL Initalization64KernelMemoryArea(){\tDWORD* Address\t = (DWORD*) 0x100000;\t\twhile((DWORD) Address\t &lt; 0x600000)\t{\t\t*Address\t\t = 0x00;\t\tif( *Address\t\t != 0 )\t\t\treturn FALSE;\t\tAddress\t\t++;\t}\t\t\t\treturn TRUE;}BOOL CheckMemorySize(){\tDWORD* Address\t = (DWORD*) 0x100000;\t\twhile( (DWORD) Address\t&lt; 0x4000000 )\t{\t\t*Address\t\t = 0x12345678;\t\tif( *Address\t\t != 0x12345678)\t\t\treturn FALSE;\t\tAddress\t\t += (0x100000 / 4);\t}\treturn TRUE;\t}그 내용이다. 이걸 엔트리 함수에서 활용해 체크하고, 메시지를 출력한다. 정상 동작하나 테스트를 위하여 launch_qemu.sh 안의 내용을 좀 고쳐봤다. 기존에 정상 동작하던 옵션은 qemu-system-x86_64 -L . -m 64 -fda disk.img -localtime -M pc이다. 이렇게 지정하면 vm에게 -m 64 옵션에 의해 64바이트의 메모리를 할당해준다.  이렇게 잘 출력된다. 그럼 VM에게 메모리를 덜 줘보겠다.     qemu-system-x86_64 -L . -m 32 -fda disk.img -localtime -M pc-m 32 로 메모리를 32MB만 줬다.  오 예스 원하던데로 출력이 잘 된다. 이제 남은건 페이징 키고 여타 자질구래한거 준비해서 64비트 모드에 시동 거는 일만 남았다. 그리고 코드를 좀더 이쁘게 바꿔야지 의식의 흐름대로 쓴 코드인거 다 티난다. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Booting","function"],
        "url": "https://devsdk.github.io/ko/development/2017/06/30/preparing64.html"
      },{
        "title": "Page 관련 자료구조 정의, 64비트로 시동 걸 준비.",
        "excerpt":"자꾸 64비트로 넘어가기만 하면 된다고 했는데 이번엔 정말이다. 64비트 모드에 키까지 꼽아놓고 돌리기만 하면 된다. 일단, 32비트 보호모드는 IA-32e 모드로 전환하기 위한 전단계기 때문에, 보호모드일때는 페이징을 활성화 하지 않았고, 관련 자료구조도 정의하지 않았다. 아무튼, 64비트 모드인, IA-32e 모드에서는 메모리 페이징 기능을 사용할 것이기 때문에 관련된 자료구조를 정의해줄 필요가 있다. 이중에서 메모리를 2MB씩 4단계를 거쳐 접근하는 4단계 페이징 방식과, 메모리를 4KB씩 5단계를 거쳐 접근하는 5단계 페이징 기법이 있다. 해당 구조는 다음과 같다. 그림에는 4-KB인 5단계로 써있지만, 나는 2MB를 쓰는 4단계 페이징 방식을 사용할 것이다. PT 안씀.  난 여기서 4단계 페이징 방식을 사용할 것이다. 페이지 디렉터리 테이블 속의 엔트리하나는 2MB크기의 메모리를 페이징 하고, 그 테이블에는 512개의 엔트리가 들어올 수 있다. 즉 페이지 디렉터리 하나당 512 * 2MB = 1GB를 표현할 수 있으며, 우리는 64GB까지 지원할 것이기 때문에,  페이지 디렉터리 포인터는  64개가 필요하다. 따라서 그 전단계인 PML4 테이블엔 엔트리 하나만 있으면 된다. 즉, 초기화해줘야 할 곳, 확보해줘야 할 메모리는 PML4 테이블, 페이지 디렉터리 포인트 테이블, 페이지 디렉터리 테이블이다. 각각 소스코드에선 PML4, PDPT, PD로 나타낸다. 또한, 각각의 엔트리마다 겹쳐지는 FLAG도 많기 때문에 메크로 BITFLAG를 제공한다. 이 자료구조로 필요한 총 크기는 PML4 엔트리는 8바이트씩, 512개가 필요하므로 512 * 8Byte PDPT 엔트리도 8바이트씩, 512개가 필요하므로 512 * 8Byte PD 엔트리는 8바이트 엔트리가 512개가 64개 있어야 함으로 (64GB 지원) 512 * 64 * 8Byte 각각 4KB, 4KB, 256KB 다 더해서 총 264KB 가 필요하다. 우리는 64비트 커널을 2메가바이트 영역을 엔트리로 지정할것이므로 1~2MB영역에 이걸 적재하기로 한다. #ifndef __PAGE_H__#define __PAGE_H__#include \"Types.h\"#define PAGE_FLAG_P\t\t\t0x00000001#define PAGE_FLAG_RW\t\t0x00000002#define PAGE_FLAG_US\t\t0x00000004#define PAGE_FLAG_PWT\t\t0x00000008#define PAGE_FLAG_PCD\t\t0x00000010#define PAGE_FLAG_A\t\t\t0x00000020#define PAGE_FLAG_D\t\t\t0x00000040#define PAGE_FLAG_PS\t\t0x00000080#define PAGE_FLAG_G\t\t\t0x00000100#define PAGE_FLAG_PAT\t\t0x00001000\t#define PAGE_FLAG_EXB\t\t0x80000000\t#define PAGE_FLAG_DEFAULT\t(PAGE_FLAG_P | PAGE_FLAG_RW)#define PAGE_TABLE_SIZE\t\t0x1000 //4KB#define PAGE_DEFAULT_SIZE\t0X200000#define PAGE_MAX_ENTRY_COUNT\t\t512#pragma(push, 1)/*\tFor IA-32e Paging\tIA-32e Address Structure\t63\t\t\t48 47\t39 38\t\t\t   30 29\t   21 20\t\t\t0\t|SIGNEXTENSION| PML4 | DIRECTORY POINTER | DIRCTORY  |    OFFSET     |\tPML4 Refernce PML4 ENTRY\tand, that Refernce DIRECTORY POINTER ENTRY using DIRECTORY POINTER\tand, that Refernce DIRCTORY ENTRY using DIRECTORY \tand, DIRECTORY + OFFSET is Memory Address. \t\tso, We Need Space for this Structure\t\tPML4 Table Need 512 * 8 Byte = 4KB\tPAGE DIRECTORY POINTER Table Need 512 * 8 Byte = 4KB\tPAGE DIRECTORY Need 512 * 8 Byte * 64 = 256KB (for 64GB Memory)\t\tSo we using 4KB + 4KB+ 256KB = 264KB Memory Space.    The following code is its implementation.    \t\tWe Use 4 Level Paging, So NOT USE PTENTRY.*/typedef struct __Struct_PageEntry{\t\t\t/*0----------------31 bit */\tDWORD dwLowAddress;\t/*32---------------64 bit */\tDWORD dwHighAddress;} PML4ENTRY, PDPTENTRY, PDENTRY, PTENTRY;\t#pragma(pop)void InitializePageTable();void SetPageEntryData(PTENTRY* pEntry, DWORD dwHighBaseAddress, \t\t\t\t\t  DWORD dwLowBaseAddress, DWORD dwLowFlag, DWORD dwHighFlag);#endif /*__PAGE_H__ */-_- 젠장, 애써 달아놓은 주석이 다 깨지네. 원래는 이렇게 보인다.  이중 __Struct_PageEntry 는 64bit 크기의 테이블 엔트리를 표현하기 위함으로 정의되었다. 구조체중 PTENTRY는 사용되지 않는다. (5단계 페이징용.) 구현부는 다음과 같다. #include \"Page.h\"void InitializePageTable(){\tPML4ENTRY*\tpml4entry  = (PML4ENTRY*) 0x100000;\tPDPTENTRY*\tpdptentry  = (PDPTENTRY*) 0x101000;\tPDENTRY*\tpdentry    = (PDENTRY*\t) 0x102000;\tSetPageEntryData(&amp;pml4entry[0], 0x00, 0x101000, PAGE_FLAG_DEFAULT, 0);\tfor(int i = 1; i&lt; PAGE_MAX_ENTRY_COUNT; i++)\t{\t\tSetPageEntryData(&amp;pml4entry[i], 0,0,0,0);\t}\tfor(int i = 0; i &lt; 64; i++)\t{\t\tSetPageEntryData(&amp;pdptentry[i], 0, 0x102000 + i * PAGE_TABLE_SIZE,\t\t\t\t\t\t PAGE_FLAG_DEFAULT, 0);\t}\tfor(int i=64; i &lt; PAGE_MAX_ENTRY_COUNT; i++)\t{\t\tSetPageEntryData(&amp;pdptentry[i], 0, 0, 0, 0);\t}\tDWORD LowMapping = 0; \t    /*\t\t'high' for Calculate out of 32bit area. using HighAddressArea \t*/\tfor(int i=0; i&lt;PAGE_MAX_ENTRY_COUNT * 64; i++)\t{\t\tDWORD high = (i * (PAGE_DEFAULT_SIZE &gt;&gt; 20) ) &gt;&gt; 12;\t\tSetPageEntryData(&amp;pdentry[i], high, LowMapping, \t\t\t\t\t\tPAGE_FLAG_DEFAULT | PAGE_FLAG_PS, 0);\t\t\t\t\t\tLowMapping += PAGE_DEFAULT_SIZE;\t}\t }void SetPageEntryData(PTENTRY* pEntry, DWORD dwHighBaseAddress, DWORD dwLowBaseAddress,\t\t\t\t\t  DWORD dwLowFlag, DWORD dwHighFlag){\tpEntry-&gt;dwLowAddress  = dwLowBaseAddress  | dwLowFlag;\tpEntry-&gt;dwHighAddress = (dwHighBaseAddress &amp; 0xFF )| dwHighFlag;}복잡해 보일 수 있는데, 그렇게 복잡하진 않다. 중간에 »20 » 12 이건, 32비트를 넘어서는 주소에대한 계산이다. 구조체를 이용해 64비트를 표현했으니까 말이다. 우리가 잘 정의한 FLAG들을 각 엔트리 주소에 넣어주는 것이며, 그 구조는 다음과 같다.  그림판으로 대충 그린거니까 양해 바란다. 저렇게 해서 메모리에 다 넣어준뒤 Main.c에 초기화 구문을 넣어준다. \tPrintVideoMemory(5,7, 0x0F,\"Initalization PML4, PDPT, PD .........................\");\tInitializePageTable();\tPrintVideoMemory(60,7,0x0A,\"[SUCCESS]\");뭐, 이건 메모리 사이즈 체크를 끝내고 오류 발생할게… 없을것이다. 아마도… 그래서 그냥 SUCCESS. 출력해서 보면  저 한줄이 또 추가되서 기쁘다. 이제, 진짜로 64비트만 남았다. 이제 10장, 64비트로 전환하자. 또 링크스크립트 만지고, 잘 알지 못하는 makefile을 대거 수정할 생각하니까 걱정이 앞서긴 하지만 지금까지 만든거 보면 나름 뿌듯하다. 이제 부팅과정의 끝에 와간다. FULL 소스코드는 GITHUB에 올리고 있다. 내친김에 스타도 박아주셧으면 좋을것 같다.. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Booting","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/06/30/readytojump64.html"
      },{
        "title": "32비트 보호모드 안녕~  이제 64비트.",
        "excerpt":"드디어, IA-32e모드의 문턱까지 왔다. 이제 32비트 보호모드에서 작업할 일은 없다.  오 예스~~~ 뿌듯함 기대가 앞서는구만. 현제 상태는 CR0 레지스터 하나의 값만 바꾸면 64비트 운용모드로 전환되는 상태. 물론, 전환후 점프할 64비트 코드가 없기때문에, 직전에 무한루프를 걸었다. 아무튼, 이제 32비트와는 안녕~~. 일단, 64비트 모드로 전환을 위해서는 IA-32e 모드 전용으로 쓸 세그먼트 디스크립터가 필요하다. 그 다음으로는 CR4 레지스터의 PAE 비트를 1로 설정해준다. (32비트 이상의 물리 메모리를 사용할지 여부 결정) 그 뒤로는 CR4 레지스터에 PML4 테이블의 주소를 저장해주고 IA32_EFER 레지스터의 LME 비트를 1로 바꿈. 마지막으로 CR0 레지스터의 PG비트를 1로 바꾸면서 페이징을 활성화 해버린다. 다음은 아까 지정해준 IA-32e 세그먼트 디스크립터를 세그먼트 설렉터로 지정한다음 64비트 코드로 점프. 32비트 보호모드에서 64비트 IA-32e모드로 전환하는 과정이다. 물론 해야할 작업은, CPU가 64비트를 지원하는가에 대해 검사를 해줘야 한다. 요즘 나오는 CPU는 죄다 64비트 지원하는데 옛날껀 아니라서.. #ifndef __MODESWITCH_H__#define __MODESWITCH_H__#include \"Types.h\"/*\tGet System  CPUID\tin_eax \t: CPUID Parameter\tout_eax : Output CPUID eax register \tout_ebx : Output CPUID ebx register\tout_ecx : Output CPUID ecx register\tout_edx : Output CPUID edx register*/void GetCPUID(DWORD in_eax, DWORD* out_eax,DWORD* out_ebx ,DWORD* out_ecx, DWORD* out_edx);/*\tSwitch 64Bit Kernel Mode \t\tSet CR4 Register PAE = 1\tSet CR3 Register PML4 Table Address 0x100000\tSet IA32_EFER.LME = 1 to Enable IA-32e\tSet CR0 Register NW = 0 CD = 0 PG 1\t */void ModeSwitchAndJumpKernel64();#endif /*__MODESWITCH_H__*/길어보이는데 그냥 함수 두개짜리 해더파일이다. 각각 CPUID 기능을 사용하기 위한 함수와, 말그대로 64비트 모드로 전환하는 함수다. 일단 CPUID 기능으로 무엇을 하냐면, CPU제조사 이름 가져오고 이 CPU가 64비트 명령어를 지원하는가에 대한 체크다. 저 함수들의 구현이다. [BITS 32]global GetCPUID, ModeSwitchAndJumpKernel64SECTION .text; Get Cpu ID; Following Function Use with c language ; void GetCPUID(DWORD in_eax, DWORD* out_eax, DWORD* out_ecx, DWORD* out_edx) ; in_eax \t: cpuid Parameter; out_eax \t: output eax register; out_ecx \t: output ecx register ; out_edx\t: output edx registerGetCPUID:\tpush ebp\tmov ebp, esp\tpush eax\tpush ebx\tpush ecx\tpush edx\tpush esi\tmov eax, dword[ebp + 8]\tcpuid\tmov esi, dword[ebp + 12]\tmov dword[esi], eax\t\tmov esi, dword[ebp + 16]\tmov dword[esi], ebx\t\tmov esi, dword[ebp + 20]\tmov dword[esi], ecx\tmov esi, dword[ebp + 24]\tmov dword[esi], edx\tpop esi\tpop edx\tpop ecx\tpop ebx\tpop eax\tpop ebp\tret\t; Switch IA-32e Mode And Jump 64 Bit Kernel ; void ModeSwitchAndJumpKernel64() ;ModeSwitchAndJumpKernel64:\t\t\t; Set 1 CR4 Register PAE Bit\tmov eax, cr4\tor eax, 0x20\tmov cr4, eax\tmov eax, 0x100000\tmov cr3, eax\t\tmov ecx, 0xC0000080\trdmsr\tor eax, 0x0100\twrmsr\t\tjmp $\t\t;Write Table\tmov eax, cr0\tor eax, 0xE0000000\txor eax, 0x60000000\tmov cr0, eax\t\t\t;Not Entry\tjmp $\t마지막에 mov eax, cr0 전에 jmp $ 걸어둔건, 점프할 64비트 커널이 없기 때문이다. 따라서 그냥 해당 위치에서 대기하도록 만듬. 그리고 GDT 수정한다음, 기존 코드에서 보호모드를 가르키던 주소를 다 변경해 주었다 GDT:\tNULLDescriptor:\tdw 0x0000\tdw 0x0000\tdb 0x00\tdb 0x00\tdb 0x00\tdb 0x00\tIA_32eCodeDescriptor:\tdw 0xFFFF\t; Limit[15:0]\tdw 0x0000\t; Base[15:0]\tdb 0x00\t\t; Base[23:16] \tdb 0x9A\t\t; P = 1, DPL = 0, Code Segment, Execute/Read\tdb 0xAF\t\t; G = 1, D = 0, L = 1, Limit [19:16]\tdb 0x00\t\t; Base[31:24]\t\tIA_32eDataDescriptor:\tdw 0xFFFF\t; Limit[15:0]\tdw 0x0000\t; Base[15:0]\tdb 0x00\t\t; Base[23:16] \tdb 0x92\t\t; P = 1, DPL = 0, Code Segment, Execute/Read\tdb 0xAF\t\t; G = 1, D = 0, L = 1, Limit [19:16]\tdb 0x00\t\t; Base[31:24]\t\tCODEDescriptor:\tdw 0xFFFF\t; Limit[15:0]\tdw 0x0000\t; Base[15:0]\tdb 0x00\t\t; Base[23:16]\tdb 0x9A\t\t; P = 1, DPL = 0, Code Segment, Execute/Read\tdb 0xCF\t\t; G = 1, D = 1, L = 0, Limit [19:16]\tdb 0x00\t\t; Base[31:24]\t\tDATADescriptor:\tdw 0xFFFF\t; Limit\tdw 0x0000\t; Base\tdb 0x00\t\t; Base\tdb 0x92\t\t; P=1, DPL =0, Data Segment, Read/Write\tdb 0xCF\t\t; G= 1, D= 1, L= 0, Limit\tdb 0x00\t\t; BaseGDTREND:그리고 커널 Main함수에 추가된 코드 \tPrintVideoMemory(5,8, 0x0F,\"CPU Company .......................................... [            ]\");\t\tDWORD out_eax, out_ebx, out_ecx, out_edx;\tGetCPUID(0x00000000, &amp;out_eax, &amp;out_ebx, &amp;out_ecx, &amp;out_edx);\tchar CPU_Name[13] = {0};\t*( DWORD*)CPU_Name \t\t= out_ebx;\t*((DWORD*)CPU_Name+1)\t= out_edx;\t*((DWORD*)CPU_Name+2)\t= out_ecx;\tPrintVideoMemory(61,8, 0x0F, CPU_Name);\t\t\tGetCPUID(0x80000001, &amp;out_eax, &amp;out_ebx, &amp;out_ecx, &amp;out_edx);\tPrintVideoMemory(5,9, 0x0F,\"Check CPU Support 64Bit ..............................\");\tif(out_edx &amp; ( 1 &lt;&lt; 29))\t{\t\t\tPrintVideoMemory(60,9,0x0A,\"[SUCCESS]\");\t}\telse\t{\t\t\tPrintVideoMemory(60,9,0x0C,\"[ERROR]\");\t\twhile(1);\t}\t\tPrintVideoMemory(5,10, 0x0F,\"Now 64 Bit Mode.\");\tModeSwitchAndJumpKernel64();CPUID를 쓸때 eax에 0을 넣으면 CPU 제조사 문자열이 나온다. 그거 맞춰서 출력해주고, 다시 CPUID를 쓰는데 이번에는 0x80000001 을 eax에 집어넣고 호출하면 각종 정보가 나오는데, 필요한건 EDX 레지스터의 29번째 비트이다. 이게 0이냐 1이냐에 따라 CPU가 64 비트를 지원하냐 마냐를 결정한다. 따라서 edx에 29째 비트와 and 연산을 해 1인지0인지 검사한다. 성공했으면 64비트 모드로 전환! 정상적으로 동작하는지 테스트를 해보았다. 일단, qemu의 default cpu는 왠지 모르지만 AMD 로 인식한다. 그래서 뒤에 옵션을 주었다. qemu-system-x86_64 -L . -m 64 -fda disk.img -localtime -M pc -cpu Nehalem뒤에 -cpu Nehalem 은 i7 개열 CPU를 나타낸다. 따라서 64비트 지원 정상적으로 출력된다.  그럼, 옵션을 바꿔 32비트만 지원하는 CPU로 바꿔보겠다. qemu-system-x86_64 -L . -m 64 -fda disk.img -localtime -M pc -cpu n270뭐, n270이라는 CPU가 있는데, 왠지 32비트만 지원할꺼 같아서 해봤다. 결과는 우리가 생각한 대로 나온다. 코딩 막 하다가 막 쓴 글이라 그런지 의식의 흐름대로 썻다.  FULL 소스코드는 GITHUB에 올리고 있다. 스타도 눌러주시면 좋겠다. 이제 32비트 코드를 만질 일이 크게 없을것 같다. 다음부턴 64비트 커널로 점프하는 일이 남은것이겠지. 일단 지금까지 했던거 싹 정리하고 곱씹은다음 넘어가야겠다. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Bootings","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/06/30/bye32bit.html"
      },{
        "title": "부팅 완료, 길고 긴 여정이 끝났습니다. Hello 64Bit",
        "excerpt":"예이 성공했다. 이제 64비트에서 C언어 엔트리로 진입한다.  이번에 구글 IO 같은  일정이 있어서 24시간 카페에서 사람만나서 밤을 보내기로 했었다. 물론 모두 안와서 혼자서 밤을 보냈지만. 아무튼간 오기로했던 사람들이 다 안와서, 나홀로 카페에서 구석에 처박혀서 코딩을 했다.  물론 개발하면서 보던 책은 무거워서 안들고 갔기에, 책없이 OS 개발을 시작했다. 물론, 마지막 남은 64비트 진입 및, C언어 엔트리 진입까지 만들어 보겠다고 시작했다. 즉, 부팅을 완성해보자고 시작했다. 아무튼간, 16비트에서 32비트로 전환하는거를 책보면서 하나하나 이해해가며 했기  때문에, 구조는 비슷할것이라고 생각했고, 이전에, 64비트 관련된 페이지 자료구조 및, 기타등등을 전에 어느정도 완성해놨기 때문에, 간단할거라고 시작했다. 일단 가장 처음 해야할건, 저번에 점프했던 2MB부터의 영역을 엔트리포인트로 두도록 해야하는것이다. 즉, 링크스크립트를 수정해야한다. 뭐 저번에는 시작지점이 0x10200이였으니 그걸 0x200000 으로 변경하면 되겠지 게다가 저번껀 32비트 전용이였으니 x86-64를 지원하게끔 해줘야 할것이다. 처음부터 작성하기보단 기존에 있는걸 좀 뜯어보기로 했다. /usr/lib/ldscript/elf_x86_64 파일이 64비트를 대상으로하는 링크 스크립트다. 보니까, 지금 쓰고있는 LinkScript32.x 과 그렇게 큰 차이가 나지않아 수정해야할 부분을 찾기위해 diff를 걸었다. 물론, 보기 편하라고 colordiff를 걸었다.  오? 그렇게 바꿔야 할게 많지 않다. 시작점을 0x200000 으로 두고, 링크스크립트를 작성했다. 책이 없었기 때문에, 감으로 하고 있었는데, 막상 링크스크립트를 작성해 0x200000을 엔트리로 두니까 어??? 64비트 커널은 어셈 엔트리 포인트가 없는건가??? 이런생각을 가지게 됬었다. 왜냐면 32비트때는, 0x10000에 EntryPoint.s 를 올리고, 0x10200 으로 호출해 C언어로 진입했기 때문인데, 둘중 하나는 0x200000에서 시작할탠데… 로 고민을 하고 연구를 했다. 책이 없어서 이런거 하나하나를 확인하면서 넘어갔는데, 뭔가 링커에 비밀이 있을것이라 판단했고, 테스트를 진행했다. makefile를 확인해본결과 역시나, EntryPoint의 바이너리가 링킹의 가장 첫번째 대상으로 들어가고, 0x200000을 기점으로 시작해 아래에 있는 커널 함수나, 기타등등을 활용하게 된다. 이게 일단, 어느정도 이해가 끝나 실질적으로 개발을 시작했는데, 이제 수정했던건 LinkScript, makefile 등등이였다. 또한, OS 책 커뮤니티에서 보이고 구현된 소스코드에서 보였던 메모리 로드 방식을 가져왔다. 일단 부트로더에 의해 모든 데이터를 불러온다. 차곡차곡 쌓는 느낌. 그 단위는 512Byt 지금 있는 Kernel32의 경우 5섹터가 Kernel64의 경우 1섹터가 나오는데, 이걸 부트로더는 0x10000 위치에 읽어들인다. 아직 책을 못 읽어봐서 왜 이렇게 하는지는 모른다. 곧 돌아가면 읽어보려고 기대하는 중이다. 추측하건데, 남는 공간을 활용하기 위해서이거나, 속도의 이점을 위하기 떄문이라고 생각한다. 이걸 구현하기 위해선 디스크 이미지 앞에 정보를 가지고 있어야 한다. 총 섹터 수 혹은, kernel64 섹터 수 Kernel32 섹터의 수 가 필요하다. 그뒤 그 정보를 이용해 메모리에 올리게 된다. 아무튼, 64Bit커널의 경우 2MB가 되는 지점에 복사해놓는다, 그 후 IA-32e 모드 스위치 후 2메가바이트의 위치로 점프한다. 점프했을때 정상적으로 동작했다면 바로 성공했을 텐데, 이전에 작성했던 코드중에서 오타나, 발견하지 못한 오류로 인해 디버깅에 조금 힘을 썼다. 일단, 페이지 디렉터리 포인터 테이블의 시작 위치가 잘못됬었다. 0x10200 이 아니라 0x102000 임. //Page.c\tfor(int i = 0; i &lt; 64; i++)\t{\t\tSetPageEntryData(&amp;pdptentry[i], 0, 0x10200 /*0x102000*/        + i * PAGE_TABLE_SIZE, PAGE_FLAG_DEFAULT, 0);\t}그리고 상위 어드레스를 구하는 식에 PAGE_DEFAULT_SIZE가 아니라 PAGE_FLAG_DEFAULT 가 들어가 있었다. 젠장     //Page.c\tDWORD high = (i * (PAGE_FLAG_DEFAULT &gt;&gt; 20) ) &gt;&gt; 12;\t//위 코드는 오류 코드임    //아래가 올바른 코드    DWORD high = (i * (PAGE_DEFAULT_SIZE) &gt;&gt; 20) ) &gt;&gt; 12;\t페이지 관련 설정이 이상하니까 ModeSwitchAndJumpKernel64 함수를 통해 r0 레지스터에서 페이징을 활성화 시키니까 부팅도 이상하고 계속 깜빡깜빡 거렸던것 같다. 아무튼 고치니까 이상 없음. 문제는 아무리 해도 2MB 위치에 있는 엔트리에 점프해도 아무일도 안일어났던것이였다. ModeSwitchAndJumpKernel64:\t\t\t; Set 1 CR4 Register PAE Bit\tmov eax, cr4\tor eax, 0x20\tmov cr4, eax\tmov eax, 0x100000\tmov cr3, eax\t\tmov ecx, 0xC0000080\trdmsr\tor eax, 0x0100\twrmsr\t\t\t;Write Table\tmov eax, cr0\tor  eax, 0xE0000000\txor eax, 0x60000000\tmov cr0, eax\t\tjmp 0x08:0x200000\t\t;Not Entry\tjmp $\t\t이코드중 jmp 0x08:0x200000 위치로 점프하는 구문이 있는데, 점프해도 아무일이 안일났었다. 혹시 어디서 문제있나 해서 해당 라인까지 코드가 진행이 안되는지도 테스트해보고 이거저거 의심하며 찾았다. 그중 정확한 단서를 찾아내는데, qemu에서 컨트롤 + R + 2번을 누르면 커멘드쉘이 등장한다. 거기서 주소내의 값 여부를 알 수 있는데 x 0x200000항상 아무값도 안들어왔다 따라서 복사쪽혹은 데이터 자체가 잘못되었을거라고 생각했다. 혹시, 디스크 이미지에 넣은 데이터가 잘못된건 아닐까 싶어, vim에서 hex 값을 봤는데 정상이였다. %!xxd 그리고, qemu를 이용헤 데이터가 복사되기 전까지 잘 올라 오나 보기위해 세그먼트에 512 * 5를 한 0x10A00 부터 차래차래 확인헀는데 데이터는 잘 불러오고 있었다. copy 함수를 들여다 보았다. void LoadKernel64ImageToMemory(DWORD _address){\tWORD TotalKernelSector \t= *( (WORD*) 0x7C05);\tWORD Kernel32Sector \t= *( (WORD*) 0x7C07);\t\tDWORD* SourceAddress = (DWORD*) 0x10000 + Kernel32Sector * 512;\tDWORD* DestAddress\t= (DWORD*) 0x200000; \t\tfor(int i=0; i&lt; 512 * (TotalKernelSector -Kernel32Sector) / 4; i++)\t{\t\t*DestAddress = *SourceAddress;\t\tDestAddress++;\t\tSourceAddress++;\t}\t}아 저거구나. \tDWORD* Source = ((DWORD*) (0x10000 + Kernel32Sector * 512));연산자 우선순위. 젠장, 초보적인 실수를 범했다. 아무튼 저렇게 고치니까. 2MB 지점에 엔트리포인트인 다음 코드를 올려 놓게 되고, [BITS 64]SECTION .textextern __KERNEL_ENTRYSTART:\tmov ax, 0x10\tmov ds, ax\tmov es, ax\tmov fs, ax\tmov gs, ax\tmov ss,  ax\tmov rsp, 0x6FFFF8\tmov rbp, 0x6FFFF8\tcall __KERNEL_ENTRY\tjmp $해당 엔트리는 C 엔트리 함수를 호출하면서 #include \"Types.h\"void PrintVideoMemory(int _x, int _y, BYTE _Attribute, const char* _str);void __KERNEL_ENTRY(){\tPrintVideoMemory(5,12, 0x0F,\"64 bit C Language Kernel.\");\t}void PrintVideoMemory(int _x, int _y, BYTE _Attribute ,const char* _str){\tCHARACTER_MEMORY*  = ( CHARACTER_MEMORY* ) 0xB8000;\t\tint i = 0;\t\tAddress+= ( _y * 80 ) + _x;\t\tfor ( i = 0; _str[i] != 0; i++)\t{\t\tAddress[i].bCharactor = _str[i];\t\tAddress[i].bAttribute = _Attribute;\t\t\t}}위 이미지같이 정상적으로 동작하게 된다! 뭐, 코딩도 코딩 나르대로 오래 했지만 디버깅 시간도 만만찮았다. 아무래도 GDB같은걸 익숙하게 써버릇 해야겟다. 이제 부팅 과정이 다 끝난거 같다. 밤을 꼴딱 새고 이동하면서 글을 이어 이어 이어 쓴거라 문맥흐름도 이상하고 중간중간 끊긴 느낌일 수 도 있다.. 양해 바람. 어떨진 모르겠지만 내가 해둔거 책하고 비교해서 볼생각하니까 좋네. 좀 쉬었다가 이전 포스팅에서 잘못된 값 올려놓은 코드 수정해야지 이제, 시작이다! ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Booting","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/07/02/Hello64Bit.html"
      },{
        "title": "QEMU + GDB로 디버깅 환경 조성",
        "excerpt":"현제 작성중인 OS는 Ubuntu (Windows Bash) + Vim 으로 개발 중이다 지금까진 감당하기야 하겠는데, 점점 프로그램이 커지면 디버깅 도구가 필요할 듯 했다. QEMU 자체에도 어느정도의 디버깅이 가능하게끔 해뒀지만, 전문 디버거를 사용하는 것 보단 부족할 것이다. 전에, 메모리에 재대로 데이터가 들어오는가에 대해 알아보기 위해 해당 기능을 사용했었는데, 컨트롤 알트 + 2 로 qemu 콘솔에 들어가서 x [주소]로 메모리에 있는 데이터를 볼 수 있다. 그걸로 어찌어찌 해결 보긴 했지만, 바로 이전 글에서 성공한 64비트 커널 엔트리를 만들면서 디버거의 도움이 있었다면 더 빠르게 만들 수 있었을 것 이라고 생각이 들었다. 보니까, qemu 자체에서 gdb host를 하는 기능을 지원한다. qemu 실행 옵션으로 -gdb tcp::[prot]를 주면 된다. 물론 포트는 원하시는 걸로.. 그리고 gdb 측에선 gdb를 실행하고 (gdb) target remote tcp::[port]를 하게 되면 연결이 된다. 이상태로도, 어느정도의 디버깅은 가능하다. 메모리를 직접 다루는 구문등 말이다. (gdb) break *0x200000로 브레이킹 포인트를 해당 어드레스에 지정하고 (gdb) continue하면 그 어드레스를 실행할때 브레이킹을 걸고 디버깅 콘솔로 넘어간다.  하지만 심볼데이터가 없기때문에, 특정 구문, 함수에서 멈추거나 할 수 없기에 반쪽짜리 느낌이다. 많은 기능을 못 쓰고, list 같은거도 못쓴다. 심볼을 추가하기 위해선 일단, OS를 빌드하는 makefile에서 gcc 구문에 -g를 추가해 준다. 그럼 빌드 되었을때 디버깅 정보가 같이 들어간다.  그림은 링킹이 끝난 .elf 파일을 objdump로 열어본 결과이다. 그럼 그걸 gdb 실행시 연결하면 된다 gdb -s [경로]링킹이 끝난 .elf 파일을 지정해 줘도 된다. 뭐 나같은 경우 64비트 커널에서만 개발 할 것으로 생각되기에 02_Kernel64/Obj/Kernel64.elf 로 지정해 주었다. 그러니까  함수 이름으로 브레이킹 포인트를 걸 수 있다. 그리고 Continue로 진행하고 해당 지점에 도달했을때 list를 입력해 보았다.  이제 디버깅 환경이 구성되었다. GDB 처음 써보는데, 잘 쓸 수 있을지 걱정이긴 하다. 혹시 qemu와 gdb를 연결해 디버깅 해야 할 사람이라면, 이 글이 도움이 되었길 바란다. 이제 본격적인 OS개발 시작~! ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Debug","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/07/03/QemuAndGdb.html"
      },{
        "title": "PortIO 메모리와 PS/2 Keyboard IO 입력처리",
        "excerpt":"어제부터 오늘까지 고민하면서 만든 결과물이다.  저기  저 빨간글씨가 방금 입력한 텍스트. 이제 0SOS는, 키보드 입력을 지원한다. 물론 아직 쉘 이런건 아니고, 키보드 드라이버가 완성이 되었다. 입력받은걸 Video Memory에 넣는 정도. 조금 걱정인건 이게, PS/2 인터페이스 (옛날 컴퓨터에 있는 동그란 그거) 버전이다. 물론, 책에 이렇게 써있다고 그대로 개발할 내가 아니다. 그렇지만… 자료를 찾아보고 고민해보고, 심지어, 저자분께 직접 물어본 결과   라고 하신다. PCI를 직접 제어해야 한다고 하셔서 일단 보류하고, 추후에 추가가 가능하게끔 작성하도록 해야겠다. 대충 책을 훑어보니까 Input데이터를 Queue에 넣어서 Buffer처럼 활용하는 형태기 때문에, Queue를 인터페이스로써 활용이 가능해보인다. 일단 나중에 USB Driver, PCI Control 이 가능해질때쯤 다시 작성하기로 하고 일단, PS/2 버전의 키보드로 작성하기로 한다. 다행스럽게도 노트북 키보드는 PS/2로 내부적으로 연결되어있다고 한다. 개발에 큰 지장은 없어보인다. 슬슬 본격적으로 개발에 들어가기 때문에, 소스코드를 구분해 줄 필요가 있어보인다. 그래서 Source 폴더 안에, Driver 라는 디렉토리를 만들고 생각하기로 한다. 내가 사용할 방법은 포트 맵 IO 이기 때문에, PortIO 관련된 디렉토리 키보드와 관련된 디렉토리를 구분했다. 그렇게 대충 디렉토리를 구분해서 tree 만들었다.  *gch파일은 뭐 왜 추가되는진 모르겠다, 젠장 gcc 돌릴때 해더파일하고 같이 들어가면 저렇게 된다던데 통 해결법을 모르겠다. - 나중에 시간들여서 make를 한번 더 뜯어야 할듯 일단, 디렉토리가 생기면서 발생하는 include의 ../../ 가 싫어서 gcc에 옵션으로 Source디렉토리를 Include Path로 지정해주었다. gcc -I ../Source그러면 이제, #include \"../../Types.h\" //을 아래처럼 쓸 수 있다.#include &lt;Types.h&gt;아무튼 좀 더 나아지게끔 하려고 노력좀 했다. 이제  대망의 빌드. 빌드가 안됨 undefined reference to PS2~~이런 메시지가 뜬다 좀더 자세히 보면 해더만 컴파일하고, 소스파일은 컴파일을 하지 않고 냅둔다. 아마도 책에서는 단일경로를 기준으로 작성이 되어서 그런듯 해보인다. 이제 makefile을 뜯어고치기 시작. 삽질 엄청 하면서 한 3시간정도 고생한거 같은데, 이것저것 해보다가 결과적으로 바꾼곳은 다음이다. 02_Kernel64/makefile 이다. CSOURCEFILES = $(wildcard ../$(SOURCEDIR)/*.c)ASSEMBLYSOURCEFILES = $(wildcard ../$(SOURCEDIR)/*.asm)C코드와, 어셈블리 코드를 지정해 주는 식을 CSOURCEFILES = $(shell find ../$(SOURCEDIR)/ -name *.c)ASSEMBLYSOURCEFILES = $(shell find ../$(SOURCEDIR)/ -name *.asm)로 변경해 주었다, 이러니까 모든 c 파일을 대상으로 가져오기는 하는데, 컴파일을 제대로 하지 않았다. 그래서 저상태로 돌리면 ld 명령어로 링크하는 과정에 파일이 없어서 링크를 못하는 상황. 그래서 o 파일을 만드는 규칙을 수정했다. %.o: ../$(SOURCEDIR)/%.c\t\t  \t\t$(GCC64) -c $&lt;\t\t %.o: ../$(SOURCEDIR)%.asm\t\t$(NASM64) -c $@ $&lt;위 코드를, $(COBJECTFILES): $(CSOURCEFILES)\t$(GCC64) -c $^$(ASSEMBLYOBJECTFILES): $(ASSEMBLYSOURCEFILES)\t$(NASM64) -o $@ $&lt;로 수정하면서, 모든 파일들을 빌드한뒤 Obj 디렉터리 안에 넣게 된다. 그래서 링커가 실행되고 정상적으로 디스크가 구워진다.  이 장면을 보고 소리지를 뻔 -_- 아무튼간, 빌드에는 성공했고, 기쁜 마음으로 실행 깜빡깜빡 -_-;;; 왜그런가 이유를 찾아다녔다. gdb를 써보고 싶었는데 통… 못쓰겠다. 게다가 qemu에서 호스트해주는거라 스탭스탭 밟는거도 안되는 듯 해보인다. 나중에 GUI 버전을 찾아봐야겠다. 무튼, 그 이유를 찾았는데, PortIO 어셈블리 함수 두개와 그걸 잇는 해더파일의 함수와 반대로 이어져 있었다. 그래서 반환도 재대로 안되고, 인자도 재대로 안들어가서 스택 터지고 다운이 된듯 하다. 그렇게 PortIO 기능을 쓸 수 있게 되고 PS/2 Keyboard 포트를 이용해 키보드 드라이버를 작성하기 시작했다. 키보드 드라이버 소스코든는 좀 긴거 같으니까, 전체 코드는 여기서 사용자가 키보드를 누르면 스캔 코드가 전달되는데, 쉬프트와 캡스락과 같은 기능을 쓰기 위해서 키보드의 상태를 담당할 g_KeyboardStatus를 두고, 해당 키를 누를시 업데이트 하는 형태로 구현했다. //Keyboard.htypedef struct _KeyboardSataus{\tBOOL isShiftKeyDown;\tBOOL isCapsLockOn;\tBOOL isNumLockOn;\tBOOL isScrollLockOn;\tBOOL isExtendCode;\tint  SkipPauseCount;} KeyboardStatus;static KeyboardStatus\tg_KeyboardStatus= { 0,};그리고 스캔코드-아스키코드 맵을 만들었다. 조합키가 입력될경우와, 일반적인 경우를 구분했다. //Keyboard.htypedef struct _StructKeyMapEntry{\tBYTE \tNormalCode;\tBYTE \tCombinedCode;} KeyMapEntry;static KeyMapEntry \t\tg_KeyMapScanTable[KEYMAP_TABLE_SIZE] = {\t{ KEY_NONE\t\t\t\t,\t\tKEY_NONE\t\t}, //    0\t{ KEY_ESC \t\t\t\t,\t\tKEY_ESC\t\t\t}, //    1\t{ '1'\t\t\t\t\t, \t\t'!'\t\t\t\t}, //    2\t{ '2'\t\t\t\t\t,\t\t'@'\t\t\t\t}, //    3\t{ '3'\t\t\t\t\t,\t\t'#'\t\t\t\t}, //    4\t{ '4'\t\t\t\t\t,\t\t'$'\t\t\t\t}, //    5\t{ '5'\t\t\t\t\t,\t\t'%'\t\t\t\t}, //    6\t{ '6'\t\t\t\t\t,\t\t'^'\t\t\t\t}, //    7\t{ '7'\t\t\t\t\t,\t\t'&amp;'\t\t\t\t}, //    8\t{ '8'\t\t\t\t\t,\t\t'*'\t\t\t\t}, //    9\t{ '9'\t\t\t\t\t,\t\t'('\t\t\t\t}, //    10\t{ '0'\t\t\t\t\t,\t\t')'\t\t\t\t}, //    11\t{ '-'\t\t\t\t\t,\t\t'_'\t\t\t\t}, //    12    // 나머지는 생략 89개다.아무튼 저 테이블을 참조하여, 키보드 입력 처리를 하게 된다. 내부 구현은 깃헙에서. 그래서 커널 엔트리에서 사용할땐 //__Kernel_Entry.cvoid __KERNEL_ENTRY(){\tPrintVideoMemory(5,12, 0x0F,\"64 bit C Language Kernel.\");\t\tBYTE flags;\tint i = 14;\tchar temps[2] = {0,};\tif(PS2ActivationKeyboard() == FALSE)\t{\t\tPrintVideoMemory(5,15, 0x0F,\"Keyboard Error\t.\");\t\t\twhile(1);\t}\t\t\twhile(1)\t{\t\tif(PS2CheckOutputBufferNotEmpty() == TRUE)\t\t{\t\t\tBYTE temp = PS2GetKeyboardScanCode();\t\t\tif(ConvertScancodeToASCII( temp, &amp;temps[0], &amp;flags) == TRUE)\t\t\t\tif(flags &amp; KEY_DOWN )\t\t\t\t\tPrintVideoMemory(i++, 15, 0x0C, temps);\t\t\t\t\t\t\t}\t\t\t}\t}로 사용한다 보면 입력값이 있으면 그 값을 가져오고 ASKII로 변경한뒤, 키 입력인지를 판별해 출력해주는 형태. 아직 인터럽트를 사용하지 않는다. 아무튼 잘 나오니까 너무 기쁘다. 드디어 곧 쉘이라는걸 내 손에…. 아무튼 다음은 인터럽트네.. 조금 험난할껏 같다. Kernel64의 Full Source Code 자세한걸 보고싶으신 분은 여기서 Driver 쪽과, 커널 엔트리를 보시면 될것 같다. 내친김에.. 스타도….눌러주시면… ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Input","Keyboard","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/07/05/PortIOAndKeyboard.html"
      },{
        "title": "GDT 변경 & IDT 정의 TSS 설정",
        "excerpt":"중간중간, 다른거 할것도 생겼었고 이번건 디버깅이 좀 더 오래걸리기도 해서 지금 개발 일지를 올린다. 음…. 일단, 지금까지 0SOS는 인터럽트를 처리할 수 있는 코드가 없었다. 그렇다 보니, 인터럽트가 발생하면 시스템이 다운되거나, default handler에 의해 처리되곤 했다. 아무튼간, 그건 맘에 안든다. 앞으로 키보드 입력할때건, 기타 여러 상황에서 인터럽트를 활용하기 위해 이번에는 IDT라는 인터럽트 처리를 위한 준비물을 만들었다.  아직, 더미 핸들러로 연결이 되있긴 하지만 인터럽트가 발생을 했고, 그 인터럽트를 처리하기 위한 핸들러가 실행이 되었다. 저것을 위해 인터럽트 핸들링에 쓸 Stack Switching 용 IST 자료구조를 7~8MB 영역에 정의해주었다. 그리고 TSS Segment 를 이용해 IST를 지정해 주었고 IDT에 들어간 100여개의 더미 디스크립터는 Dummy Handler 함수와 연결했다. 메모리 맵을 만들면 대충 이럼.  다음엔 그냥 그림판으로 그려야겠다. 귀찮아져버려 아무튼 이번 코드의 핵심은 GDT에서 TSS Selector를 두는것과 TSS를 정의하는것 IDT를 만드는거라고 볼 수 있겠다. 아무튼, 말로만 하니까 저렇게 간단해 보이는데 음… 코드를 보자. 그리고 디버깅 일지를 쓰겠다. 일단 더미 핸들러. void DummyHandler(){    Pt(0,0,0x0F ,\"===============================\");    Pt(0,1,0x0F ,\"===============================\");    Pt(0,2,0x0F ,\"===    Test Interrupt Hander===\");    Pt(0,3,0x0F ,\"===============================\");    Pt(0,4,0x0F ,\"===============================\");        while(1);   //복귀 코드 없음}어떤 인터럽트가 발생하면 일단 저쪽으로 연결된다. 즉, 숫자 나누기 0같은 연산을 시도했을때 인터럽트가 발생되어 저 함수가 실행이 된다. 결과는 첫 이미지처럼. 아무튼 이제 GDT를 재정의하고, TSS를 이용해 IST를 지정하고, IDT를 만들어 인터럽트를 처리할 수 있게 만들어야 한다. 그러기 위해 Descriptor 디렉토리를 만들고, 그 안에 그를 담당하는 파일들을 정의해 주었다.  Descriptor.asm과 Descriptor.h는, GDTR, IDTR , TSS 를 프로세서에 올리기 위한 어셈 코드들을 처리하며 IDT.c IDT.h 는 IDT와 관련된 코드 GDT.c GDT.h 는 GDT와 관련된 코드를 정의했다. 일단 GDT.h를 자세하게 보고 싶으시면 이곳에서 보길 바란다. 너무 길다. 앞으로 자주 쓸 코드만 OR로 묶어서 define 해두었다. 아무튼간, 해더파일은 저렇고, 구현은 다음과 같다. //GDT.c#include \"GDT.h\"#include \"IDT.h\"#include &lt;Utility/Memory.h&gt;void InitializeGDTWithTSS(){    GDTR* _gdtr = (GDTR*)GDTR_POINTER;    GDT_ENTRY8* _gdt_entry      = (GDT_ENTRY8*)(GDTR_POINTER + sizeof(GDTR));     TSS_SEGMENT* _tss_segment    = (TSS_SEGMENT*)((QWORD)_gdt_entry+GDT_TABLE_SIZE);        _gdtr-&gt;Size         = GDT_TABLE_SIZE - 1;    _gdtr-&gt;BaseAddress  = (QWORD)_gdt_entry;    SetGDT_Entry8((&amp;_gdt_entry[0]), 0, 0, 0, 0, 0);    SetGDT_Entry8((&amp;_gdt_entry[1]),0,0xFFFFF, GDT_ENTRY_HIGH_CODE, GDT_ENTRY_LOW_KERNEL_CODE, GDT_TYPE_CODE);    SetGDT_Entry8((&amp;_gdt_entry[2]),0,0xFFFFF, GDT_ENTRY_HIGH_DATA, GDT_ENTRY_LOW_KERNEL_DATA, GDT_TYPE_DATA);        SetGDT_Entry16(((GDT_ENTRY16*)(&amp;_gdt_entry[3])), (QWORD)_tss_segment, sizeof(TSS_SEGMENT)-1, GDT_ENTRY_HIGH_TSS,                    GDT_ENTRY_LOW_TSS, GDT_TYPE_TSS);    InitializeTSSSegment(_tss_segment);    }void SetGDT_Entry8(GDT_ENTRY8* _entry, DWORD _BaseAddress,                     DWORD _Size, BYTE _HighFlags, BYTE _LowFlags, BYTE _Type){    _entry-&gt;Low_Size            =   _Size &amp; 0xFFFF;    _entry-&gt;Low_BaseAddress     = _BaseAddress &amp; 0xFFFF;    _entry-&gt;Low_BaseAddress1    = ( _BaseAddress &gt;&gt; 16 ) &amp; 0xFF;    _entry-&gt;Low_Flags           = _LowFlags | _Type;    _entry-&gt;High_FlagsAndSize   = ((_Size&gt;&gt;16) &amp; 0xFF) | _HighFlags;    _entry-&gt;High_BaseAddress    = (_BaseAddress&gt;&gt;24) &amp; 0xFF;}void SetGDT_Entry16(GDT_ENTRY16* _entry, QWORD _BaseAddress,                     DWORD _Size, BYTE _HighFlags, BYTE _LowFlags, BYTE _Type){    _entry-&gt;Low_Size            = _Size &amp; 0xFFFF;    _entry-&gt;Low_BaseAddress     = _BaseAddress &amp; 0xFFFF;    _entry-&gt;Mid_BaseAddress     = (_BaseAddress &gt;&gt; 16 ) &amp; 0xFF;    _entry-&gt;Low_Flags           = _LowFlags | _Type;    _entry-&gt;High_FlagsAndSize   = ((_Size &gt;&gt; 16) &amp; 0xFF) | _HighFlags;    _entry-&gt;High_BaseAddress    = (_BaseAddress  &gt;&gt; 24) &amp; 0xFF;    _entry-&gt;High_BaseAddress2   = (_BaseAddress&gt;&gt;32);    _entry-&gt;Reserved            = 0;}void InitializeTSSSegment(TSS_SEGMENT* _tss){    _MemSet(_tss, 0, sizeof(TSS_SEGMENT));        _tss-&gt;IST[0] = IST_POINTER + IST_SIZE;    _tss-&gt;IOMapBaseAddress  =  0xFFFF;}뭐, 자세히 보면 InitializeGDTWithTSS함수를 통하여, GDT관련 데이터를 메모리에 올려놓는다. (GDTR_POINTER를 유심히 보고, 계산하면 메모리가 딱딱 맞아 떨어진다.) 기존의 GDT구조랑 다른게 없으니 그건 구글링 해보시길 권장 그리고 IDT 쪽을 보자 IDT.h의 해더파일이다. //IDT.h#ifndef __IDT_H__#define __IDT_H__#include \"GDT.h\"#define IDT_TYPE_INTERRUPT      0x0E    //0b00001110#define IDT_TYPE_TRAP           0x0F    //0b00001111#define IDT_ENTRY_DPL0          0x00    //0b00000000#define IDT_ENTRY_DPL1          0x20    //0b00100000#define IDT_ENTRY_DPL2          0x40    //0b01000000#define IDT_ENTRY_DPL3          0x60    //0b01100000#define IDT_ENTRY_P             0x80    //0b10000000#define IDT_ENTRY_IST1          1#define IDT_ENTRY_IST0          0#define IDT_ENTRY_KERNEL    (IDT_ENTRY_DPL0 | IDT_ENTRY_P)#define IDT_ENTRY_USER      (IDT_ENTRY_DPL3 | IDT_ENTRY_P)#define IDT_MAX_ENTRY_COUNT     100#define IDTR_POINTER            (sizeof(GDTR) + GDTR_POINTER \\                                + GDT_TABLE_SIZE + TSS_SEGMENT_SIZE)#define IDT_POINTER            (sizeof(IDTR) + IDTR_POINTER)#define IDT_TABLE_SIZE          (IDT_MAX_ENTRY_COUNT + sizeof(IDT_ENTRY))#define IST_POINTER         0x700000#define IST_SIZE            0x100000#pragma pack(push, 1)typedef struct _Struct_IDT_Entry{    WORD Low_BaseAddress;    WORD SegmentSelector;    BYTE IST;    //3Bit IST, 5Bit set 0    BYTE FlagsAndType;    // 4Bit Type, 1 Bit set 0, 2Bit DPL, 1Bit P    WORD Mid_BaseAddress;    DWORD High_BaseAddres;    DWORD Reserved;}IDT_ENTRY;#pragma pack(pop)void InitializeIDTTables();void SetIDTEntry(IDT_ENTRY* _entry, void* _handler, WORD _Selector,                     BYTE _IST, BYTE _Flags, BYTE _Type);void Pt(int _x, int _y, BYTE _Attribute ,const char* _str);void DummyHandler();#endif /* __IDT_H__ */IDT.h 해더파일은 아직 길진 않다. 자세히보면 알겠지만, 각각 시작주소를 나타내는 _POINTER의 경우 직접 지정하는것 보단, sizeof에 의해 메모리에 연속되게 배치되게끔 만들어졌다. 그리고 구현인 IDT.c //IDT.c#include \"IDT.h\"void InitializeIDTTables(){    IDTR* idtr = (IDTR*) IDTR_POINTER;    IDT_ENTRY* entry =  (IDT_ENTRY*)(IDTR_POINTER + sizeof(IDTR));        idtr-&gt;BaseAddress   = (QWORD)entry;    idtr-&gt;Size          = IDT_TABLE_SIZE - 1;    for(int i = 0; i &lt; IDT_MAX_ENTRY_COUNT; i++)     {        SetIDTEntry(&amp;entry[i],DummyHandler,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    }}void SetIDTEntry(IDT_ENTRY* _entry, void* _handler, WORD _Selector,                     BYTE _IST, BYTE _Flags, BYTE _Type){    _entry-&gt;Low_BaseAddress =  (QWORD) _handler &amp; 0xFFFF;    _entry-&gt;SegmentSelector = _Selector;    _entry-&gt;IST             = _IST &amp; 0x3;    _entry-&gt;FlagsAndType   = _Flags | _Type;    _entry-&gt;Mid_BaseAddress = ((QWORD)_handler &gt;&gt; 16) &amp; 0xFFFF;    _entry-&gt;High_BaseAddres = ((QWORD)_handler &gt;&gt; 32);    _entry-&gt;Reserved        = 0;}//Pt, DummyHandler 생략대충 dummyhandler하고, print vide memory를 담당했던 함수는 생략했다. 위 코드를 이용해 IDT를 정의하고 메모리에 불러오게 된다. 프로세서에 해당 핸들러를 이어주고 하는 역할을 하는게, Descriptor.h와 Descriptor.asm 이다. //Descriptor.h#ifndef __DESCRIPTOR_H__#define __DESCRIPTOR_H__void LoadGDTR(QWORD _GdtrAddress);void LoadTR(WORD _TssSegmentOffset);void LoadIDTR(QWORD _IDTRAddress);#endif /*__DESCRIPTOR_H__*/위 코드는 어셈블리랑 연결되어 있다. 해당 기능을 제공하는 어셈블리는 ;Descriptor.asm[BITS 64]                     global LoadGDTR, LoadTR, LoadIDTR                        SECTION .textLoadGDTR:    lgdt[rdi]    retLoadTR:    ltr di    retLoadIDTR:    lidt[rdi]    ret간단하다. 그저, 각 테이블을 프로세서에게 알리는 코드이다. 그리고 마지막 대망의 커널 엔트리에는     //__Kernel_Entry.c\tPrintVideoMemory(5,12, 0x0F,\"Initialize GDT........................................\");\tInitializeGDTWithTSS();\tLoadGDTR(GDTR_POINTER);\tPrintVideoMemory(60,12,0x0A,\"[SUCCESS]\");\tPrintVideoMemory(5,13, 0x0F,\"Load TSS Segment .....................................\");\tLoadTR(GDT_TSS_SEGMENT);\tPrintVideoMemory(60,13,0x0A,\"[SUCCESS]\");\tPrintVideoMemory(5,14, 0x0F,\"Initialize IDT .......................................\");\tInitializeIDTTables();\tLoadIDTR(IDTR_POINTER);\tPrintVideoMemory(60,14,0x0A,\"[SUCCESS]\");    //...이 코드를 추가해 초기화 및 프로세서에 연결을 취해주고 키보드 입력할때 숫자를 0으로 나눠 divide by zero 인터럽트를 발생시켰다. //__Kernel_Entry.c\tif(flags &amp; KEY_DOWN )\t{\t\tPrintVideoMemory(i++, 15, 0x0C, temps);\t\tint b = 10 / 0;\t}여기까지가 코드상에 추가된 내용이다. 음… 앞으로 포스팅할때 코드를 다 붙여넣는건 고려를 좀 해봐야겠다. 더 나은 방법이 있을거같다. 위에 Kernel Entry 쓰는거 처럼. 이제 위 내용을 구현하며 했던 삽질과 디버깅 일지를 쓰겠다. 위 내용을 열씸히 코딩하고 나서, 기쁜 마음으로 Build를 시도했다. undefined reference to ....젠장. 뭐가 문제인지 찾아보기 시작했다. 링크 로그를 뚫어져라 보니, 어셈블리 목적파일이 이상한갑다. 그래서 objdump로 확인해보니 이럴수가 … 파일 이름만 다르지 두 파일의 내옹이 똑같았다. 즉 asm code의 목적코드 변환이 이상하게 된것. (대충 PortIO.o와 Descriptor.o 안에, Port.o 내용이 있었다.) nasm은 gcc랑 대충 동작은 비슷한데 파일 여러개를 묶어서 빌드하는건 안되나보다. $(ASSEMBLYOBJECTFILES): $(ASSEMBLYSOURCEFILES) \t$(NASM64) -o $@ $&lt;사실 $&lt; 때문에 빌드가 된거지 $^ 박았으면 인자 많다고 nasm에서 멈췄을것이다. 저번까진 asm파일이 하나였으니 별 문제를 일으키진 않았는데, asm 파일이 두개 이상이 되니 빌드가 이상하게 됐다. gcc는 그냥 -c 옵션에 뒤에 소스파일을 죄다 주면 목적파일로 차근차근 빌드하나 싶었는데, nasm은 여러가지 파일을 인자로 안받는다 젠장. 그래서 방법을 고민했다. 처음엔 nasm 자체 기능으로 해결해볼까… 할수 있을까 고민했는데, 없었다. 아니 모르는건가…? 아무튼, 그냥 makefile에 foreach문을 넣는거로 해결했다. $(ASSEMBLYOBJECTFILES):$(ASSEMBLYSOURCEFILES)$(foreach var,$(ASSEMBLYSOURCEFILES),$(NASM64) $(var) -o $(notdir $(patsubst %.asm, %.o,  $(var))) ;)이 짧막한(아닌)코드를 위해 몇시간을 날려먹었다.  이제…makefile건들일은 많이 없겠지. 아무튼 빌드는 잘 된다. 실행해보았다. 딱히 동작하지 않는다. makefile때문에 멘탈이 흔들거렸던 나는 말그대로 부들부들 상태. 좀 쉬었다가, 다시 잡았다. 디버깅 할 내용은, GDT, IDT, TSS 데이터가 메모리에 잘 올라갔는지 확인하는것. 가장 처음으로 해볼껀, 명시적으로 메모리 주소를 지정했던 GDTR을 살펴보는 것 이다.  초록색위는 GDTR, 빨간색은 GDT 테이블이다. GDTR의 가장 중요한 역할은 GDT의 위치를 지정해 주는 것이다. 나는 GDTR바로 뒤에 GDT를 위치시켰으니 0x142010을 참조하고 있어야 할테고 HEX를 보면 재대로 저장이 되어 있음을 볼 수 있다. 그리고 뒤에나오는 GDT를 살펴보자. 아무튼, GDTR 지정하고 프로세서한테 넘기고 출력까지 잘 되기 때문에 GDT 테이블 내용 자체의 문제는 없을꺼라 생각했다. 다만, TSS 세그먼트디스크립터는 자세히 봤다. 시작점은 0x142028 표로 정리하면 다음과 같다.  메모리에 잘 불러와 지는지 보고 있었으므로, 일단 Base Address를 살펴본다. TSS 테이블 또한 GDT바로 뒤에 위치하게끔 의도했으므로 0x142038부터 위치해야한다. 일단 TSS 세그먼트디스크립터의 Base Address는 문제가 없어보인다.  한두번 다시 봤다. 뭔가 이상해 마지막 2바이트 IOMap 설정에는 FFFF를 넣어놨는데 어디갔지? IST의 기준주소인 0x800000 은 어디간거지. 코드로 돌아갔다. 아뿔싸 멀쩡한 InitializeTSSSegment 함수를 잘 만들얻두고 호출을 안했다. InitializeGDTWithTSS 함수 마지막에 위 함수를 호출함으로 해결했다.  … 뭐가 달라진진 잘 안보이지만 마지막 2바이트가 FFFF로 들어갔고 잘 보면 IST 기준 주소도 저장이 되었다. 일단 여기까진 정상이다. 그래도 동작 안한다. 이제 그 뒤에 위치한 IDT를 살펴보았다. 흐음.  음…?? 메모리 주소 계산이 이상하다. 의도한건 바로 뒤였는데 왜 0x1421A0로 지정이 되어있는가..?? 코드를 살펴보았다. IDT_ENTRY* entry =  (IDT_ENTRY*)IDTR_POINTER + sizeof(IDTR);또 똑같은 실수를 -_- 저러면 당연히 뒤에 지정된다. 포인터로 케스팅하고 더해버리니까. 위 코드를 IDT_ENTRY* entry =  (IDT_ENTRY*)(IDTR_POINTER + sizeof(IDTR));로 변경하며 해결. 참고로 이 코드는 동작하는데 전혀 문제가 없다. 다만 의도랑 다를 뿐더러 추후에, 문제를 일으킬 수 있다. 예를들면, IDT 바로 뒤에 어떤 데이터를 넣는다고 했을때 주소게산이 되서 덮어써버릴 수 있다. 당장 안보이는 문제고, 주의깊게 보지 않으면 잡기 힘든 버그긴 하다. (IDTR에 들어간 메모리 주소와 실제 IDT 위치가 같기 떄문이다. 실제로 0x2021A0에 가면 IDT가 있다.) 수정하니 정상적으로 데이터가 들어간다.  모든 데이터가 잘 들어갔다. 이상하게 동작을 안하네. 일단, 인터럽트가 걸리면 시스템이 다운되었다. 이상하다. 설마 해서 프로세서에게 전달을 잘못했나 살펴봤다. [BITS 64]                     global LoadGDTR, LoadTR, LoadIDTR                        SECTION .textLoadGDTR:    lgdt[rdi]    retLoadTR:    ltr di    retLoadIDTR:    lgdt[rdi]    ret아 ㅆ.. LoadIDTR 함수에서 lgdt를 해버리는 실수를 저질렀다. 위 코드를 [BITS 64]                     global LoadGDTR, LoadTR, LoadIDTR                        SECTION .textLoadGDTR:    lgdt[rdi]    retLoadTR:    ltr di    retLoadIDTR:    lidt[rdi]    ret이 코드로 변경 함으로 해결 LoadIDTR 함수의 명령어를 lgdt 를 lidt로 변경했다. 이러서 코드가 정상적으로 돈다. 흠… 이번 글은 길다. 이곳에서 Full Source Code를 볼 수 있다간김에 스타도 박아주면 좋겠다. 이제 남은건, 키보드처리를 인터럽트로 만드는것 이려나. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Interrupt","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/07/10/ReadyInterrupt.html"
      },{
        "title": "PIC 인터럽트, 인터럽트 핸들링, 인터럽트 활성화",
        "excerpt":"사실 오늘 오후쯤에 만들었는데, 잠깐 서버 작업할게 생겨서 글을 지금쯤 쓴다. 이번에는 PIC인터럽트 핸들링을 성공했다.  딱히, 티나진 않지만 우측 상단에 작게 INT 라고 써있다. 뒤에 바로 나오는 숫자는 인터럽트 번호, 뒤에 나오는건 카운터이다. 그냥 실행시켜두면 카운터가 00부터 99까지 계속 증가한다 32는 타이머 인터럽트. 아무튼간 이번에 해준일은 PIC드라이버 제작, IDT에 인터럽트 핸들링을 위한 루틴을 연결, 인터럽트 핸들링 하기전 문맥을 저장, 처리후 복원하는 것을 다뤘다. 우선 최근에는 더 많은 기능을 제공하는 APIC를 사용한다고 한다. 책에서는 나중에 다룬다고 하니 일단 패스. 그래서 그냥 PIC를 다루는데, 이제 PIC라고 하는 것의 드라이버를 작성해야 한다.  작성할 PIC 드라이버의 다이어그램이다. 마스터와 슬레이브로 나뉘어있고, 각각  PortIO Map 방식으로 마스터는 0x20, 0x21 슬레이브는 0xA0, 0xA1로 연결되어있다. 여기서, ICW (Initalize Command Word)로 초기화를 해주고 사용할때는 OCW (Operation Command Word)로 사용한다. 이곳 그림 참고 초기화 할때는 Port IO Mapping을 사용한다. 저번에 만들었던 Port IO 드라이버를 쓰면 되겠다. Driver 디렉토리에 PIC 디렉토리를 만들고, PIC.h, PIC.c를 만들었다. 내용은 다음과 같다. //PIC.h#ifndef __PIC_H__#define __PIC_H__#include &lt;Types.h&gt;#define PIC_MASTER_PORT_1   0x20#define PIC_MASTER_PORT_2   0x21#define PIC_SLAVE_PORT_1    0xA0#define PIC_SLAVE_PORT_2    0xA1#define PIC_IRQ_VECTOR      0x20void InitializePIC();void MaskPICInterrupt(WORD _IRQ_Mask);void SendPIC_EOI(int _IRQ_Number);#endif /* __PIC_H__ */위에서 4개는 포트 번호, 아래는 Interrupt 루틴의 시작 벡터 (시스템 예외로 예약된 31번까지를 제외하고 32부터 사용한다.) 그리고 ICW, OCW를 이용해 함수를 만들었다. 그 구현 //PIC.c#include \"PIC.h\"#include &lt;Driver/IO/PortIO.h&gt;void InitializePIC(){    //Initalize Master PIC    //ICW1 IC4 = 1    PortIO_OutByte(PIC_MASTER_PORT_1, 0x11);    //ICW2 Interrupt Vector Offset = 0x20 (32)    PortIO_OutByte(PIC_MASTER_PORT_2, PIC_IRQ_VECTOR);    //ICW3 Master-Slave Pin S2=1   |  0x04    PortIO_OutByte(PIC_MASTER_PORT_2, 0x04);    //ICW4 SFNM = 0 BUF = 0 M/S = 0 AEOI = 0 uPM = 1     PortIO_OutByte(PIC_MASTER_PORT_2, 0x01);        //Initalize Slave PIC    //ICW1 IC4 = 1    PortIO_OutByte(PIC_SLAVE_PORT_1, 0x11);    //ICW2 Interrupt Vector Offset = 0x28    PortIO_OutByte(PIC_SLAVE_PORT_2, PIC_IRQ_VECTOR + 8);    //ICW3 Master-Slave Pin Number = 2 | 0x2    PortIO_OutByte(PIC_SLAVE_PORT_2, 0x02);    //ICW4 SFNM = 0 BUF = 0 M/S = 0 AEOI = 0 uPM = 1    PortIO_OutByte(PIC_SLAVE_PORT_2, 0x01);}   void MaskPICInterrupt(WORD _IRQ_Mask){    //OCW1 IRQ0~IRQ7    PortIO_OutByte(PIC_MASTER_PORT_2, _IRQ_Mask);    //OCW1 IRQ8~IRQ15    PortIO_OutByte(PIC_SLAVE_PORT_2 , (BYTE)(_IRQ_Mask&gt;&gt;8));}void SendPIC_EOI(int _IRQ_Number){    //OCW2 NonSpecific EOI Command.    PortIO_OutByte(PIC_MASTER_PORT_1, 0X20);    //If Slave Interrupt.    if(_IRQ_Number&gt;=8)    {        PortIO_OutByte(PIC_SLAVE_PORT_1, 0x20);    }}사실, Port IO를 이용해 계속 Command Word 를 날리는게 이 드라이버의 역할이다. 그리고 인터럽트 처리를 위한 코드들  각각 인터럽트 설정, 인터럽트 핸들러, 인터럽트 서비스 루틴이 들어있다. //Interrupt.h#ifndef __INTERRUPT_H__#define __INTERRUPT_H__#include &lt;Types.h&gt;void EnableInterrupt();void DisableInterrupt();QWORD ReadFlags();#endif /*__INTERRUPT_H__*/이런 짧은 해더파일이다. 이 코드는 어셈블리 코드랑 직접 연결된다. ;Interrupt.asm[BITS 64]SECTION .textglobal EnableInterrupt, DisableInterrupt, ReadFlagsEnableInterrupt:    sti    retDisableInterrupt:    cli    retReadFlags:    pushfq    pop rax    ret인터럽트를 활성화(sti), 비활성화(cli), Flag 레지스터 조회(pushfq)에 사용된다. 그리고 인터럽트 서비스 루틴 인터럽트 서비스 루틴은, 인터럽트 핸들러를 호출하기 전 Context의 보관(스택에 싹 집어넣기)  후, Cotext 복원 (pop pop pop pop!!) (Error Code가 있을경우 파라미터 처리) 후 다시 스택 스위칭하고 원래 코드로 복귀하는 역할을 한다. 인터럽트 서비스 루틴의 해더파일은 다음과 같다. //InterService.h#ifndef __INTERRUPT_SERVICE_H__#define __INTERRUPT_SERVICE_H__//Reserved Exceptionsvoid ISRDividError();void ISRDebug();void ISRNMI();void ISRBreakPoint();void ISROverflow();void ISRBoundRangeExceeded();void ISRInvalidOpCode();void ISRDeviceNotAvailable();void ISRDoubleFault();void ISRCoProcessorSegmentOverrun();void ISRInvalidTSS();void ISRSegmentNotPresent();void ISRStackSegmentFault();void ISRGeneralProtection();void ISRPageFault();void ISR15();void ISRFloatingPointError();void ISRAlignmentCheck();void ISRMachineCheck();void ISRSIMDError();void ISRDefaultException();//PIC Interruptvoid ISRTimer();void ISRPS2Keyboard();void ISRSlavePIC();void ISRSerialPort2();void ISRSerialPort1();void ISRParallel2();void ISRFloppy();void ISRParallel1();void ISRRTC();void ISRReserved();void ISRNotUsed1();void ISRNotUsed2();void ISRPS2Mouse();void ISRCoprocessor();void ISRHDD1();void ISRHDD2();void ISRDefaultInterrupt();#endif /* __INTERRUPT_SERVICE_H__ */위 해더파일은 전부 어셈블리 구현으로 연결되며, 코드가 너무 길어서 일부만 가져왔다. ;InterruptService.asm;...생략...ISRDividError:    SAVECONTEXT    mov rdi, 0    call DefaultExceptionHandler    LOADCONTEXT    iretqISRDebug:    SAVECONTEXT    mov rdi, 1    call DefaultExceptionHandler    LOADCONTEXT    iretqISRNMI:    SAVECONTEXT    mov rdi, 2    call DefaultExceptionHandler    LOADCONTEXT    iretqISRBreakPoint:    SAVECONTEXT    mov rdi, 3    call DefaultExceptionHandler    LOADCONTEXT    iretqISROverflow:    SAVECONTEXT    mov rdi, 4    call DefaultExceptionHandler    LOADCONTEXT    iretq;...생략...SAVECONTEXTLOADCONTEX는 각각 Contex를 보관,복귀 할때 쓰는 코드의 메크로. 인터럽트 서비스 루틴 어셈블리 Full Source Code 저 서비스 루틴은 Handler함수를 호출하게 되는데, InterruptHandler 에 구현이 되어있다. 그 전에, 이번에 비디오메모리에 출력하는 함수를 이파일 저파일에서 사용하게 되서 Utility/Console.h 에 PrintVideoMemory를 옮겼다. 인터럽트 핸들러의 해더파일이다. //InterruptHandler.h#ifndef __INTERRUPT_HANDLER_H__#define __INTERRUPT_HANDLER_H__#include &lt;Types.h&gt;void DefaultExceptionHandler(int _Vector, QWORD _ErrorCode);void DefaultInterruptHandler(int _Vector);void KeyboardInterruptHandler(int _Vector);#endif /*__INTERRUPT_HANDLER_H__*/각각, 기본 핸들러, 키보드 핸들러다. 구현은 다음과 같다. //InterruptHandler.c#include \"InterruptHandler.h\"#include &lt;Driver/PIC/PIC.h&gt;#include &lt;Utility/Console.h&gt;void __DebugIntOutput(int _Vector, int _Count){    char Buffer[] = \"[INT:  ,  ]\";    Buffer[5] = _Vector/10 + '0';    Buffer[6] = _Vector%10 + '0';    Buffer[8] = _Count/10  + '0';    Buffer[9] = _Count%10  + '0';      PrintVideoMemory(69,0,0x0F,Buffer);}void DefaultExceptionHandler(int _Vector, QWORD _ErrorCode){    char Buffer[3] = {0,};    Buffer[0] = '0' + _Vector/10;    Buffer[1] = '0' + _Vector%10;    PrintVideoMemory(0,0,0xF,\"================================================================================\");    PrintVideoMemory(0,1,0xF,\"Exception:                                                                      \");    PrintVideoMemory(0,2,0xF,\"                                                                                \");    PrintVideoMemory(0,3,0xF,\"================================================================================\");    PrintVideoMemory(11,1,0xF, Buffer);    while(1);}void DefaultInterruptHandler(int _Vector){        static int g_DefaultInterruptCounter = 0;    g_DefaultInterruptCounter = (g_DefaultInterruptCounter + 1)%100;    __DebugIntOutput(_Vector, g_DefaultInterruptCounter);    SendPIC_EOI(_Vector - PIC_IRQ_VECTOR);}void KeyboardInterruptHandler(int _Vector){        static int g_KeyboardInterruptCounter = 0;    g_KeyboardInterruptCounter = (g_KeyboardInterruptCounter + 1)%100;    __DebugIntOutput(_Vector, g_KeyboardInterruptCounter);    SendPIC_EOI(_Vector - PIC_IRQ_VECTOR);}내용을 보면 예외가 발생하면 일단, 시스템을 정지시키고 예외 번호를 보여주게 만들어뒀고, 인터럽트 처리구믄을 보면 더이상 멈춰있지않고 반환을 한다. 또한, 인터럽트 발생정보와, 발생횟수를 우측 상단에 출력한다! 이제, 아까 만들었던 인터럽트 서비스 루틴을 저번에 열씸히 만든 IDT에 싹 올려놓으면 된다. 저번의 IDT 초기화 구문은 이랬다. void InitializeIDTTables(){    IDTR* idtr = (IDTR*) IDTR_POINTER;    IDT_ENTRY* entry =  (IDT_ENTRY*)(IDTR_POINTER + sizeof(IDTR));        idtr-&gt;BaseAddress   = (QWORD)entry;    idtr-&gt;Size          = IDT_TABLE_SIZE - 1;    for(int i = 0; i &lt; IDT_MAX_ENTRY_COUNT; i++)     {        SetIDTEntry(&amp;entry[i],DummyHandler,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    }}이제, 더미 핸들러는 버리고 실제로 동작하는 핸들러와 잇는다. //IDT.cvoid InitializeIDTTables(){    IDTR* idtr = (IDTR*) IDTR_POINTER;    IDT_ENTRY* entry =  (IDT_ENTRY*)(IDTR_POINTER + sizeof(IDTR));        idtr-&gt;BaseAddress   = (QWORD)entry;    idtr-&gt;Size          = IDT_TABLE_SIZE - 1;    SetIDTEntry(&amp;entry[0],ISRDividError,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[1],ISRDebug,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[2],ISRNMI,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[3],ISRBreakPoint,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[4],ISROverflow,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[5],ISRBoundRangeExceeded,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[6],ISRInvalidOpCode,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[7],ISRDeviceNotAvailable,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[8],ISRDoubleFault,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[9],ISRCoProcessorSegmentOverrun,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[10],ISRInvalidTSS,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[11],ISRSegmentNotPresent,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[12],ISRStackSegmentFault,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[13],ISRGeneralProtection,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[14],ISRPageFault,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[15],ISR15,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[16],ISRFloatingPointError,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[17],ISRAlignmentCheck,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[18],ISRMachineCheck,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[19],ISRSIMDError,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[20],ISRDefaultException,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    for(int i= 21; i &lt; 32 ; i++)    {        SetIDTEntry(&amp;entry[i],ISRDefaultException,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    }    SetIDTEntry(&amp;entry[32],ISRTimer,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[33],ISRPS2Keyboard,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[34],ISRSlavePIC,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[35],ISRSerialPort2,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[36],ISRSerialPort1,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[37],ISRParallel2,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[38],ISRFloppy,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[39],ISRParallel1,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[40],ISRRTC,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[41],ISRReserved,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[42],ISRNotUsed1,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[43],ISRNotUsed2,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[44],ISRPS2Mouse,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[45],ISRCoprocessor,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[46],ISRHDD1,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[47],ISRHDD2,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);        for(int i = 48; i &lt; IDT_MAX_ENTRY_COUNT; i++)    {        SetIDTEntry(&amp;entry[i],ISRDefaultInterrupt,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    }}뭔가 많은데, 반복되는 코드일 뿐이다. 저번에 더미 코드로 이어주었던 이 코드를 아까 만든 서비스루틴하고 이은것이다. 아무튼 위 코드를 작성하고 빌드하고, 자잘한 버그 고치고 실행 깜빡거린다 흠… 왜 그런지 찾아보고 찾아봤다. 일단 깜빡거리는게 발생하는건 인터럽트를 활성화 할때였다. 1차 멘붕오고 다시 멘탈 잡고 코드를 자세히 봤다. 인터럽트 활성화 코드를 잠깐 빼고, Divide By Zero 예외를 발생시켰는데 동작한다. 이상하다. IDT 자체가 이상하면 둘다 안됬어야 하는데, 이상하게 일부만 동작한다. 그래서 좀더 자세하게 코드를 보니 IDT_MAX_ENTRY_COUNT * sizeof(IDT_ENTRY)여야 할 코드가 IDT_MAX_ENTRY_COUNT + sizeof(IDT_ENTRY)로 되어있었다. 이러니까, 0번 익셉션인 Divide By Zero 는 먹히고 PIC의 Timer Interrupt 처리는 못해서 시스템이 다운되고 켜지고 반복했던거다. 해결해서 인터럽트가 동작하고, 카운터 올라가는 모습을 보니 뿌듯하다. 이제 인터럽트 방식으로 키보드 처리하게끔 키보드 드라이버를 업데이트 하는 일이 남았다. 그다음은 드디어 쉘! 이 길고 긴 글 읽어주셔서 고맙다고 인사를 드리고 싶다. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Interrupt","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/07/12/InterruptHandling.html"
      },{
        "title": "키보드 드라이버의 업데이트-인터럽트 방식",
        "excerpt":"이번글은 짧지 않을까 싶다. 오늘은 이상하리만큼 집중하기 힘들다. 이상하다..흐음 오전에 이상하게 집중이 잘되더니 이상하게 지금은 맥이 빠진다 아무튼, 이번에는 만든거 종합해서 적용시키는 것만 했으니 그렇게 길지도 않을것 같다. 지금까지 쓰던 방식은 Port Map IO 로 PS/2의 메모리를 버퍼삼아 썼는데, 이제 인터럽트 방식으로 쓰면 저 버퍼를 쓸수 없다. 데이터를 넣는 시간과 빼는 시간이 너무 다르기 때문이다. 아무튼 이걸 해결하기 위해 보통 말하는 InputBuffer 를 만들었다. 자료구조는 Queue 범용으로 사용할 것이라 디렉토리 이름 고민을 좀 했다. DS는 뭔가 닌텐도 DS생각나서 싫고 DataStructure 는 뭔가 길다. 그래서 그냥 universal data structure 해서 UDS라고 했다. UDS 안에 Queue.h Queue.c 파일을 만들어 줬다. 보통 말하는 원형 큐다. 진짜, 범용 큐기때문에 대충 자료구조 수업이나 지식을 가지고 있다면 별다른 어려움 없을것이다. C로 구현해서 Queue Descriptor 을 첫번째 인자로 주면서 구별한다. 아무튼, 구체적인 구현이다. //Queue.h#ifndef __QUEUE_H__#define __QUEUE_H__#include &lt;Types.h&gt;#pragma pack(push, 1)typedef struct _struct_QueueDescriptor{    int DataSize;    int MaxDataCount;    void* MemoryArray;    unsigned int Front;    unsigned int Rear;    BOOL isLastPut;} QUEUE;#pragma pack(pop)void InitializeQueue(QUEUE* _QD, void* _QueueBuffer, int _MaxDataCount, int _DataSize);BOOL IsQueueFull(const QUEUE* _QD);BOOL IsQueueEmpty(const QUEUE* _QD);BOOL PushQueue(QUEUE* _QD, const void* _Src);BOOL PopQueue(QUEUE* _QD, void* _Dst);#endif /*__QUEUE_H__*/많이 보는 그저 Queue일 뿐이다. 설명은 생략 //Queue.c#include \"Queue.h\"#include &lt;Utility/Memory.h&gt;void InitializeQueue(QUEUE* _QD, void* _QueueBuffer, int _MaxDataCount, int _DataSize){    _QD-&gt;MaxDataCount = _MaxDataCount;    _QD-&gt;DataSize = _DataSize;    _QD-&gt;MemoryArray = _QueueBuffer;    _QD-&gt;Front = 0;    _QD-&gt;Rear = 0;    _QD-&gt;isLastPut = FALSE;}BOOL IsQueueFull(const QUEUE* _QD){    if((_QD-&gt;Rear == _QD-&gt;Front) &amp;&amp; (_QD-&gt;isLastPut == TRUE))        return TRUE;    return FALSE;}BOOL IsQueueEmpty(const QUEUE* _QD){    if((_QD-&gt;Rear == _QD-&gt;Front) &amp;&amp; (_QD-&gt;isLastPut == FALSE))        return TRUE;    return FALSE;}BOOL PushQueue(QUEUE* _QD, const void* _Src){    if(IsQueueFull(_QD))        return FALSE;    _MemCpy(((char*)_QD-&gt;MemoryArray) + (_QD-&gt;DataSize * _QD-&gt;Front),  _Src, _QD-&gt;DataSize);    _QD-&gt;Front = (_QD-&gt;Front + 1) % _QD-&gt;MaxDataCount;    _QD-&gt;isLastPut = TRUE;    return TRUE;}BOOL PopQueue(QUEUE* _QD, void* _Dst){    if(IsQueueEmpty(_QD))        return FALSE;    _MemCpy(_Dst, (char*)_QD-&gt;MemoryArray + (_QD-&gt;DataSize * _QD-&gt;Rear ) , _QD-&gt;DataSize);    _QD-&gt;Rear = (_QD-&gt;Rear + 1) % _QD-&gt;MaxDataCount;    _QD-&gt;isLastPut = FALSE;    return TRUE;}코드가 보기 싫으면 그저, 큐라고 생각하고 넘어가도 될듯. 아무튼 이 자료구조를 이용해서 키보드 인풋 버퍼를 만들고 Interrupt Handling 함수에서 써먹게끔 해주면 된다. 일단, 범용큐를 keyboard.h 에 추가해준다. 그와더불어 키 데이터 관련 구조체를 추가해준다. //Keybuard.h//....생략#define KEY_BUFFER_SIZE 100typedef struct _KeyDataStruct{\tBYTE ScanCode;\tBYTE ASCIICode;\tBYTE Flags;} KEYDATA;static QUEUE g_KeyBufferQueue;static KEYDATA g_KeyBufferMemory[KEY_BUFFER_SIZE];void InitalizeKeyboardBuffer();BOOL ConvertScanCodeWithPushKeyQueue(BYTE _ScanCode);BOOL GetKeyData(KEYDATA* _data);//....생략위 함수들의 구현은 다음과 같다. //Keyboard.c//...생략void InitalizeKeyboardBuffer(){\tInitializeQueue(&amp;g_KeyBufferQueue, g_KeyBufferMemory, KEY_BUFFER_SIZE, sizeof(KEYDATA));}BOOL ConvertScanCodeWithPushKeyQueue(BYTE _ScanCode){\tKEYDATA keydata;\tkeydata.ScanCode = _ScanCode;\tBOOL result = FALSE;\tif(ConvertScancodeToASCII(_ScanCode, &amp;keydata.ASCIICode, &amp;keydata.Flags) == TRUE)\t{\t\tBOOL interrupt_status = SetInterruptFlag(FALSE);\t\tresult = PushQueue(&amp;g_KeyBufferQueue, &amp;keydata);\t\tSetInterruptFlag(interrupt_status);\t}\treturn result;BOOL GetKeyData(KEYDATA* _data){\tBOOL result = FALSE;\tif(IsQueueEmpty(&amp;g_KeyBufferQueue))\t\treturn FALSE;\tBOOL interruptstatus = SetInterruptFlag(FALSE);\tresult = PopQueue(&amp;g_KeyBufferQueue,_data);\tSetInterruptFlag(interruptstatus);\treturn result;}}//...생략위에서부터 버퍼로 쓸 큐를 초기화 하는 함수, 큐에 데이터를 집어넣을 용도인 ScanCode를 받아 키 데이터로 Push해주는 함수 큐에서 KeyData를 가져오는 함수입니다. 여기서 Queue에 집어넣는 코드에서 BOOL interrupt_status = SetInterruptFlag(FALSE);로 인터럽트를 꺼버리는 걸 볼 수 있다. 그리고 큐에 삽입하고나서 다시 복구한다. 이는 흔히말하는 동기화 문제 와 비슷한 문제를 막기 위함이다. 큐 관련 연산도중엔 인터럽트를 막아, 인터럽트에 의한 연산 순서 변경 및 프로그램의 예끼치 못한 동작을 막는다. SetInterruptFlag 함수는 Utility/Flags.h 에 정의되어있다. 구현 내용은 //Flags.cBOOL SetInterruptFlag(BOOL _flag){    QWORD flag;    flag = ReadFlags();    if(_flag == TRUE)        EnableInterrupt();    else        DisableInterrupt();    if(flag &amp; 0x0200)        return TRUE;    else        return FALSE;}저번에 만든 ReadFlags, EnableInterrupt, DisableInterrupt를 이용해 구현한다. 그 다음으로는, LED나 키보드 활성화 같은 요청을 보내고 결과를 대기하는 코드의 변경이다. BOOL WaitACKWithScanCodePushQueue(){\tBOOL result = FALSE;\tfor(int i = 0; i&lt; 100; i++)\t{\t\tfor(int j = 0 ; j &lt; 0xFFFF; j++)\t\t{\t\t\tif(PS2CheckOutputBufferNotEmpty())\t\t\t\tbreak;\t\t}\t\t\t\tBYTE data = PortIO_InByte(0x60);\t\tif(data == 0xFA)\t\t{\t\t\tresult = TRUE;\t\t\tbreak;\t\t}\t\telse\t\t{\t\t\tConvertScanCodeWithPushKeyQueue(data);\t\t}\t}\treturn result; \t}이 코드가 추가되었고     for(int i=0; i&lt; 100; i++)    {        //....    }이렇게 ACK를 대기하는 코드부분에 result = WaitACKWithScanCodePushQueue();\tif(result == FALSE)\t\treturn FALSE;대기함수를 추가해 변경했다. 좀더 자세히 보려면 여기서 그리고 Interrupt Handler 쪽 함수는    if(PS2CheckOutputBufferNotEmpty() == TRUE)    {        BYTE scancode = PS2GetKeyboardScanCode();        ConvertScanCodeWithPushKeyQueue(scancode);    }이 코드가 추가되면서 처리가 가능해졌다. 그리고 커널 엔트리의 입력 처리 부분을 큐를 사용하게 바꾼다. \t\tif(GetKeyData(&amp;keydata) == TRUE)\t\t{\t\t\tif(keydata.Flags &amp; KEY_DOWN)\t\t\t{\t\t\t\ttemps[0] = keydata.ASCIICode;\t\t\t\tPrintVideoMemory(i++, 17, 0x0C, temps);\t\t\t}\t\t}이렇게 바꾸면서 큐를 이용해 입력을 처리 할 수 있게 되었다. 인터럽트 방식은 덤! 결과는 뭐… 보이는건 똑같다  이제 Input Queue를 사용하기 때문에 나중에 추가적인 키보드 Input Driver를 추가적으로 구현하고 이 큐에 Push 하면 큐를 이용한 쪽은 문제가 없을것이다. 한마디로 하나의 층이 생긴거다.. 나중에 USB Keyboard Driver를 작성할때 활용할 것으로 생각이 된다. 읽어주셔서 감사합니다. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Interrupt","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/07/13/InterruptKeyboard.html"
      },{
        "title": "운영체제 다운 모습을 드디어! 셸 개발 완료!",
        "excerpt":"이번 글도 꾀나 장문이 될 것 같다. 셸, 쉘? 셸 Shell 이다. 드디어 내 0SOS의 CLI 의 초기버전이 완성이 되었다. 이제 무언가 OS같은 모습을 가지게 되었달까… 그와 더불어 소스 트리가 커지고 있다. 무서울정도로…  현제 0SOS의 소스 트리이다. 다룰것도 많고 다룬것도 많다. 아무튼, 이번건 개발을 이곳 저곳에서 했는데, 얼마전에는 또 저번에 혼자 밤을 보냈던 24시간 카페에서 아는 지인들과 떠들면서 코딩하면서 Printf 함수와 SPrintf 함수를 구현했다.  근데 사실, 떠든게 더 많아서 그런지 카페에선 밍기적밍기적 코딩했다. 그러고 다음날도 코딩하고 다다음날도 코딩… 막, 폭풍처럼 개발하고 쉬엄 쉬엄 블로그 포스팅하며 정리하는거도 참 소소한 즐거움 인것 같다. 이 글도 아마 한번에 다 쓴글이 아니라 중간중간 틈틈히 쓸거 같긴 하다. 아무튼 아무튼, 0SOS는 콘솔 셸을 가지게 되었다. 멋지게 스크롤 하는 모습도 멋지다. 이미지로만 보면 별롤 지도 몰라서 이번엔 영상으로 준비했다. 저렇게 명령어 셸로 돌리기 위해 얼마나 많은 코드와 준비를 거쳤는가…. 16비트 어셈코드로 이뤄진 부트로더부터 시작하여, 16비트 모드에서 열씸히 준비해서 32비트 커널로 넘어가고 32비트에선 또 64비트로 넘어가기 위해 준비해서 (말이 준비지 별별게 다 필요한… 쿨럭) 64비트로 올라오고, 키보드 드라이버, 인터럽트핸들링을 위해 준비하고, 인터럽트를 활용하고.. 이번에는 Printf함수를 만들고(나중에 쓰려고 SPrintf함수도 만들고), GetCh 함수를 만들어서 입력을 받는다. 그리고 셸 코드쪽에서 처리하는 형식. 이번에도 책은 잘 안봤다. 동작만 똑같이 하면 되지 하며…(게다가 무거워서 저번과 똑같이 책을 안들고 갔었다 ㅋㅋ) 일단, 가변인자를 사용하는거야 뭐… 많은 C언어 예제들이 있으니까 크게 걱정 없었다. 다만, 이걸 OS개발시 써먹을 수 있는지에 대해 좀 찾아보긴 했었다. 문제없이 사용 가능해 보인다. 일단 가변인자는 해결 완료. 그럼 그걸 쓸 쪽인 출력 포멧과 이스케이프 시퀀스를 구현해야 한다. 결과적으로, %d 와 %x, %o는 숫자-&gt;문자열 화를 거친뒤 화면에 또는 메모리에 출력해야 한다. itoa 같은 표준에서 제공하는 함수는 분명히 효율적인 알고리즘을 가진 상태로 있을 것 이라고 생각했고, 구글링을 좀 해본 결과 아주 멋진 코드를 발견했다. BOOL _itoa(long _value, char* _result, int _base){\tif (_base &lt; 2 || _base &gt; 36) { *_result = '\\0'; return FALSE; }\tchar* ptr = _result, *ptr1 = _result, tmp_char;\tint tmp_value;\t//음수 양수 상관없이 처리가 가능함.\tdo {\t\ttmp_value = _value;\t\t_value /= _base;\t\t*ptr++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\"[35 + (tmp_value - _value * _base)];\t} while (_value);\t//Sign 처리\tif (tmp_value &lt; 0) *ptr++ = '-';\t*ptr-- = '\\0';\t//Reverse\twhile (ptr1 &lt; ptr) {\t\ttmp_char = *ptr;\t\t*ptr-- = *ptr1;\t\t*ptr1++ = tmp_char;\t}\treturn TRUE;}약간 내 코드로 변경하긴 했지만 동작 구조는 똑같다. gcc에서 사용하던 itoa 라고 한다. 문자열 테이블을 만들고, 양수 음수에 상관없게끔 reverse테이블을 준비해둔다. 그리고 그걸 이용해서 숫자에서 문자로 뽑아낸다. 이제 2진수에서 36진수까지 지원하는 itoa함수가 있으니, 문자를 숫자로 바꾸는 함수인 atoi 함수를 구현하기로 한다. 이 함수는 굳이 안찾아봐도 효율적인 방법이 보여서 걍 구현했다. BOOL _atoi(const char* _number, long* _value, int _base){\tif (!_number)\t\treturn FALSE;\tif (_base &lt; 2 || _base &gt; 36)\t\treturn FALSE;\tint sign = 1;\tint i = 0;\tif (_number[0] == '-')\t{\t\tsign = -1;\t\ti = 1;\t}\tlong result = 0;\tchar c = 0;\twhile ((c = _number[i++]) != '\\0')\t{\t\tint num = _ctoi(c);\t\tif (num &gt; _base)\t\t\treturn FALSE;\t\tresult = result * _base + num;\t}\t*_value = sign*result;\treturn TRUE;}위 코드에서 _ctoi 함수는 문자와 대응하는 숫자를 반환한다 ex) ‘a’ 는 10 (전체 코드를 보려면 여기서) 받은 숫자를 가지고 r = r * base + v 형태로 자릿수마다 반복했다. 예를 들어, ‘202’ 라는 10진수 숫자가 들어오면 1) r =  0 * 10  + 2 r = 2 2) r = 2 * 10  + 0 r = 20 3) r = 20 * 10 + 2 r = 202 종료 해서 202를 뽑아낸다, 16진수, 8진수라고 해서 다르지 않다. 아무튼, 활용을 위해 두 함수를 Utility/String.c 에 구현했다. 이제 문자를 숫자로 변환하는 함수가 준비되었으니 대망의 Printf와 SPrintf 함수를 구현해야한다. 그전에, 출력시 사용하는 attribute에 대한 정보와, 커서위치정보등을 해더파일에 정의해두었다. //Console.h#ifndef __CONSOLE_H__#define __CONSOLE_H__#include &lt;Types.h&gt;#include &lt;stdarg.h&gt;#define FORMAT_BUFFER_SIZE 200    #define PRINT_MEMORY 0x01#define PRINT_OUTPUT 0x02#define CONSOLE_WIDTH 80#define CONSOLE_HEIGHT 25#define CONSOLE_VIDEO_MEMORY    0xB8000#define CONSOLE_BACKGROUND_BLACK    0x00#define CONSOLE_BACKGROUND_BLUE     0x10#define CONSOLE_BACKGROUND_GREEN    0x20#define CONSOLE_BACKGROUND_CYAN     0x30#define CONSOLE_BACKGROUND_RED      0x40#define CONSOLE_BACKGROUND_MAGENTA  0x50#define CONSOLE_BACKGROUND_BROWN    0x60#define CONSOLE_BACKGROUND_WHITE    0x70#define CONSOLE_BACKGROUND_BLINK    0x80#define CONSOLE_FOREGROUND_DARKBLACK    0x00#define CONSOLE_FOREGROUND_DARKBLUE     0x01#define CONSOLE_FOREGROUND_DARKGREEN    0x02#define CONSOLE_FOREGROUND_DARKCYAN     0x03#define CONSOLE_FOREGROUND_DARKRED      0x04#define CONSOLE_FOREGROUND_DARKMAGENTA  0x05#define CONSOLE_FOREGROUND_DARKBROWN    0x06#define CONSOLE_FOREGROUND_DARKWHITE    0x07#define CONSOLE_FOREGROUND_BLACK        0x08#define CONSOLE_FOREGROUND_BLUE         0x09#define CONSOLE_FOREGROUND_GREEN        0x0A#define CONSOLE_FOREGROUND_CYAN         0x0B#define CONSOLE_FOREGROUND_RED          0x0C#define CONSOLE_FOREGROUND_MAGENTA      0x0D#define CONSOLE_FOREGROUND_BROWN        0x0E#define CONSOLE_FOREGROUND_WHITE        0x0F#define COLOR_DEFAULT (CONSOLE_BACKGROUND_BLACK|CONSOLE_FOREGROUND_WHITE)#pragma pack(push, 1)typedef struct _Struct_ConsoleCursor{    int cursor_offset;    DWORD current_attribute;} CONSOLESYSTEM;typedef struct _Charactor_Struct{\tBYTE bCharactor;\tBYTE bAttribute;} CHARACTER_MEMORY;#pragma pack(pop)static CONSOLESYSTEM g_console_system = {0,COLOR_DEFAULT};void _PrintStringXY(int _x, int _y, BYTE _Attribute ,const char* _str);void _PrintChar_offset(int _offset, BYTE _attribute, char _ch);void _Printf(char* _str, ...);void _SPrintf(void* _dst, char* _str, ...);char _GetCh();void __VSPrintf(BYTE _type, const void* _dst, char* str, va_list _arg);void __NextLine();void __NextScroll();void __SetConsole_System(CONSOLESYSTEM value);CONSOLESYSTEM __GetConsole_System();#endif /*__CONSOLE_H__*/define이 많다 하지만 자세히보면 그냥 Framebuffer를 구성할때 사용하는 attribute의 속성값이다. CONSOLESYSTEM g_console_system 변수가 이제 커서의 위치, 출력 색상등을 담당한다. //Console.cvoid __UpdateWithCheckConsoleCursor(){\tif(g_console_system.cursor_offset + 1 &gt;=\t\tCONSOLE_HEIGHT * CONSOLE_WIDTH)\t\t\t{\t\t\t__NextScroll();\t\t\t\tg_console_system.cursor_offset = CONSOLE_WIDTH*(CONSOLE_HEIGHT - 1);\t\t\t}\t\telse\t\t{\t\t\tg_console_system.cursor_offset++;\t\t\t}}void __putch(char _ch, BYTE _attribute){\t_PrintChar_offset(g_console_system.cursor_offset, _attribute, _ch);\t__UpdateWithCheckConsoleCursor();}void __PrintOutInteger(long _value, char* _buffer, int _base){\t_itoa(_value, _buffer, _base);\tfor (int i = 0; _buffer[i] != '\\0'; i++)\t{\t\t__putch(_buffer[i], g_console_system.current_attribute);\t}}char* __PrintMemInteger(long _value, char* _dst, int _base){\tchar Buffer[FORMAT_BUFFER_SIZE];\t_itoa(_value, Buffer, _base);\tint length = __StringLength(Buffer);\t_MemCpy(_dst, Buffer, length);\treturn _dst + length;}void __VSPrintf(BYTE _type, const void* _dst, char* str, va_list _arg){\tchar* ptr = str;\tchar Buffer[FORMAT_BUFFER_SIZE];\tchar* dst = (char*)_dst;\twhile (*ptr != '\\0')\t{\t\tchar output = *ptr;\t\t\tint value = 0;\t\tchar ch = 0;\t\tchar* str = 0;\t\tQWORD qvalue = 0;\t\tif (*ptr == '%')\t\t{\t\t\tptr++;\t\t\tswitch (*ptr)\t\t\t{\t\t\t\tcase 'd':\t\t\t\tvalue = (int)(va_arg(_arg, int));\t\t\t\tif (_type == PRINT_OUTPUT)\t\t\t\t\t__PrintOutInteger(value, Buffer, 10);\t\t\t\telse if (_type == PRINT_MEMORY)\t\t\t\t\tdst = __PrintMemInteger(value, dst, 10);\t\t\t\tbreak;\t\t\tcase 'o':\t\t\t\tvalue = (int)(va_arg(_arg, int));\t\t\t\tif (_type == PRINT_OUTPUT)\t\t\t\t\t__PrintOutInteger(value, Buffer, 8);\t\t\t\telse if (_type == PRINT_MEMORY)\t\t\t\t\tdst = __PrintMemInteger(value, dst, 8);\t\t\t\tbreak;\t\t\tcase 'x':\t\t\t\tvalue = (int)(va_arg(_arg, int));\t\t\t\tif (_type == PRINT_OUTPUT)\t\t\t\t\t__PrintOutInteger(value, Buffer, 16);\t\t\t\telse if (_type == PRINT_MEMORY)\t\t\t\t\tdst = __PrintMemInteger(value, dst, 16);\t\t\t\t\t\t\t\t\tbreak;\t\t\t\t//case 'f':\t\t\t\t//case 'g':\t\t\t\t//TODO: Floating Point\t\t\tcase 'p':\t\t\t\tqvalue = (QWORD)(va_arg(_arg, void*));\t\t\t\t\tif (_type == PRINT_OUTPUT)\t\t\t\t{\t\t\t\t\t__putch('0', g_console_system.current_attribute);\t\t\t\t\t__putch('x', g_console_system.current_attribute);\t\t\t\t\t__PrintOutInteger(qvalue, Buffer, 16);\t\t\t\t}\t\t\t\telse if (_type == PRINT_MEMORY)\t\t\t\t{\t\t\t\t\tdst[0] = '0';\t\t\t\t\tdst[1] = 'x';\t\t\t\t\tdst = __PrintMemInteger(qvalue, dst+ 2, 16);\t\t\t\t}\t\t\t\t\t\t\t\t\tbreak;\t\t\tcase 'c':\t\t\t\tch = (char)(va_arg(_arg,int));\t\t\t\tif (_type == PRINT_OUTPUT)\t\t\t\t\t__putch(ch, g_console_system.current_attribute);\t\t\t\telse if (_type == PRINT_MEMORY)\t\t\t\t{\t\t\t\t\tdst[0] = ch;\t\t\t\t\tdst++;\t\t\t\t}\t\t\t\tbreak;\t\t\tcase 's':\t\t\t\tstr = (char*)(va_arg(_arg, char*));\t\t\t\tif (_type == PRINT_OUTPUT)\t\t\t\t\t_Printf(str);\t\t\t\telse if (_type == PRINT_MEMORY)\t\t\t\t{\t\t\t\t\t_SPrintf(dst, str);\t\t\t\t\tint len = __StringLength(str);\t\t\t\t\tdst += len;\t\t\t\t}\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;\t\t\t}\t\t}Printf 함수와 SPrintf 함수의 심장이 되는 VSPrintf 내부 모습이다. 위엔 VSPrintf 함수 구현을 돕기위해 정의한 함수들이다. 책과는 아마 많이 다르게 구현되있을탠데, 책에서는 Printf 에서 Buffer를 중간에 두고 있는점때문에 버퍼를 안두고 바로 쓰게끔 했다. 그중에 __putch도 있다. 아무튼 자세히 보면 %문자를 만나면 처리하는 형태로 출력문자를 처리하고, Sprintf 냐 Printf냐에 따라 구현을 조금씩 다르게 했다. 잘 보면 %s 에 대해 다시 _Printf 를 하건 _SPrintf 를 하건 한다. 그 이유는 문자열안에 이스케이프 시퀀스가 등장하는것에 대한 처리때문이다. 이어서 Printf와 SPrintf함수의 구현을 보면 단순히 _VSPrintf를 타입에 맞추어 호출하고 커서위치를 조정해 주는 역할을 한다. //Console.cvoid _Printf(char* _str, ...){\tva_list _arg;\tva_start(_arg, _str);\t__VSPrintf(PRINT_OUTPUT, 0, _str, _arg);\tva_end(_arg);\t_SetCursor(g_console_system.cursor_offset % CONSOLE_WIDTH, \t\t\t\tg_console_system.cursor_offset / CONSOLE_WIDTH);}void _SPrintf(void* _dst, char* _str, ...){\tva_list _arg;\tva_start(_arg, _str);\t__VSPrintf(PRINT_MEMORY, _dst, _str, _arg);\tva_end(_arg);}void _PrintStringXY(int _x, int _y, BYTE _Attribute ,const char* _str){\tCHARACTER_MEMORY* Address = ( CHARACTER_MEMORY* ) CONSOLE_VIDEO_MEMORY;\tint i = 0;\tAddress+= ( _y * 80 ) + _x;\t\tfor ( i = 0; _str[i] != 0; i++)\t{\t\tAddress[i].bCharactor = _str[i];\t\tAddress[i].bAttribute = _Attribute;\t\t\t}}void _PrintChar_offset(int _offset, BYTE _attribute, char _ch){\tCHARACTER_MEMORY* Address = ( CHARACTER_MEMORY* ) CONSOLE_VIDEO_MEMORY;\tint i = 0;\tAddress+= _offset;\tAddress[0].bCharactor = _ch;\tAddress[0].bAttribute = _attribute;}void __NextLine(){\tint addoffset =CONSOLE_WIDTH - (g_console_system.cursor_offset%CONSOLE_WIDTH);\tif( g_console_system.cursor_offset + addoffset &gt;= CONSOLE_HEIGHT * CONSOLE_WIDTH)\t\t\t{\t\t\t__NextScroll();\t\t\tg_console_system.cursor_offset = CONSOLE_WIDTH*(CONSOLE_HEIGHT - 1);\t\t}\telse\t\tg_console_system.cursor_offset += addoffset;}void __NextScroll(){\t_MemCpy(CONSOLE_VIDEO_MEMORY, \t\tCONSOLE_VIDEO_MEMORY + CONSOLE_WIDTH* sizeof(CHARACTER_MEMORY), \t\t\t(CONSOLE_HEIGHT-1) * CONSOLE_WIDTH * sizeof(CHARACTER_MEMORY)  );\tCHARACTER_MEMORY* target = (CHARACTER_MEMORY*)(CONSOLE_VIDEO_MEMORY) + (CONSOLE_HEIGHT-1) * CONSOLE_WIDTH ;\tfor(int i = 0; i &lt;CONSOLE_WIDTH; i++)\t\ttarget[i].bCharactor = ' ';}라인을 넘기는거라던가, 스클을 넘기는거라던가 좀 까다롭긴 해도 원리는 단순하다. 스크롤 내리는건, 비디오메모리에서, 한칸을 밀어버린다고 생각하면 된다(마지막줄은 초기화) 그러곤 커서위치를 정한다. 이렇게 까지 오고 마지막으론 _GetCh 함수를 구현했다. 잘 알듯이 단순히 문자 하나 받아오는 함수이다. //Console.cchar _GetCh(){\tKEYDATA keydata;\twhile(1)\t{\t\tif(GetKeyData(&amp;keydata) == TRUE)\t\t{\t\t\tif(keydata.Flags &amp; KEY_DOWN)\t\t\t{\t\t\t\treturn keydata.ASCIICode;\t\t\t}\t\t}\t}}이렇게 셸 만들 준비가 되었다. 일단, 좀 복잡할지도 모르지만 셸의 해더파일을 보면 //Shell.c#ifndef __SHELL_H__#define __SHELL_H__#include &lt;Types.h&gt;#define SHELL_INPUT_BUFFER_SIZE 500#define SHELL_PROMPT_MESSAGE    \"0SOS&gt;\"typedef void (*CommandCallBack) (const char* parameter);#pragma pack(push, 1)typedef struct __Struct_ShellCommandEntry{    char* Command;    char* Comment;    CommandCallBack command_callback;} SHELLCOMMAND;typedef struct __Struct_Shell_Parameters{    const char* Buffer;    int Length;    int CurrentPosition;} PARAMETERLIST;#pragma pack(pop)//--------------------------------------------------- *void Command_Help(const char* _Parameter);void Command_Clear(const char* _Parameter);void Command_ShutDown(const char* _Parameter);void Command_TotalRamSize(const char* _Parameter);void Command_StringToNumber(const char* _Parameter);//---------------------------------------------------*static SHELLCOMMAND g_ShellCommandTable[] = {     {\"clear\", \"clear the consol\\n-f {white, green, cyan,black} front color\\n-b {black, white, blue} back ground\\n\"    , Command_Clear},    {\"help\", \"help for 0SOS\", Command_Help},    {\"shutdown\", \"Shutdown PC\", Command_ShutDown},    {\"strtod\", \"String To Hex or Decimal\", Command_StringToNumber},    {\"totalram\", \"Show Ram Size\", Command_TotalRamSize}};void Clear();void SetAttribute(BYTE _attribute);void StartShell();void ExecuteCommand(const char * CommandBuffer);void InitalizeParameter(PARAMETERLIST* _List, const char* _Parameter);int GetNextParameter(PARAMETERLIST* _List, char* _Parameter_Out);#endif /*__SHELL_H__*/셸 해더파일이다. (…) 대충 구조는 커널 엔트리에서 StartShell 함수를 호출해서 무한 루프를 돌며 명령어를 받고 출력하고 해주는 역할을 한다. 여기서 눈에 띄는 친구가 있다. typedef void (*CommandCallBack) (const char* parameter);짜잔, 함수 포인터다. 이친구는 SHELLCOMMNAD 구조체 안에 들어가 있으면서 g_ShellCommandTable 을 통해 명령어와 함수를 이어줬다. 그리고 InitalzieParameter 과 GetNextParameter 함수는 각각 파라미터 문자열을 등록하고, 그 문자열에서 파라미터 하나씩 때오는 함수다. 그 구조를 위해 PARAMETERLIST 구조체가 있다. 그리고 Command_로 시작하는 함수는 죄다 명령어 처리를 위한 콜백함수. //Shell.cvoid StartShell(){    __InitializeMemoryCheck();    char CommandBuffer[SHELL_INPUT_BUFFER_SIZE];    _SetCursor(0, 17);    int CommandBufferIndex = 0;    _Printf(SHELL_PROMPT_MESSAGE);    const int Prompt_length = sizeof(SHELL_PROMPT_MESSAGE);\twhile(1)\t{       \tBYTE c = _GetCh();        if(c == KEY_BACKSPACE)        {            if(CommandBufferIndex &gt; 0)            {                int x, y;                _GetCursor(&amp;x, &amp;y);                int dx = x - Prompt_length;                   for(int i = dx; i &lt; CommandBufferIndex; i++)                {                    CommandBuffer[i] = CommandBuffer[i + 1];                }                                for(int i = 0; i&lt; CONSOLE_WIDTH; i++)                {                    _PrintStringXY(i,y, __GetConsole_System().current_attribute, \" \");                    }                                _SetCursor(0, y);                _Printf(SHELL_PROMPT_MESSAGE);                _Printf(\"%s\", CommandBuffer);                if((x-1) &gt;= Prompt_length)                    _SetCursor(x-1, y);                else                    _SetCursor(x, y);                               CommandBufferIndex --;                if(CommandBufferIndex == 0)                {                    _SetCursor(Prompt_length-1, y);                                    }            }        }        else if(c == KEY_ENTER)        {            _Printf(\"\\n\");            if(CommandBufferIndex &gt; 0)            {                CommandBuffer[CommandBufferIndex] = '\\0';                ExecuteCommand(CommandBuffer);            }            _Printf(SHELL_PROMPT_MESSAGE);            CommandBufferIndex = 0;            _MemSet(CommandBuffer,0 , SHELL_INPUT_BUFFER_SIZE);        }        else if( (c == KEY_LSHIFT) || (c == KEY_RSHIFT) || (c == KEY_CAPSLOCK)                || (c == KEY_NUMLOCK) || (c == KEY_SCROLLLOCK))        {            ;        }        else if (c == KEY_ARROW_LEFT)        {            int x,y;            _GetCursor(&amp;x, &amp;y);            if((x - 1) &gt;= Prompt_length)            {                _SetCursor(x - 1, y);            }        }        else if(c == KEY_ARROW_RIGHT)        {            int x,y;            _GetCursor(&amp;x, &amp;y);            if((x + 1) &lt;= CommandBufferIndex)            {                _SetCursor(x + 1, y);            }        }        else        {            if(c == KEY_TAB)                c = ' ';            if(CommandBufferIndex &lt; SHELL_INPUT_BUFFER_SIZE)            {                CommandBuffer[CommandBufferIndex ++ ] = c;                _Printf(\"%c\", c);            }        }\t}    }Start Shell 함수이다. 초반에 __InitalieMemoryCheck 함수는 Utility/Memory 에 구현되어있으며 메모리 사이즈를 체크해 글로벌 변수에 넣어두고 __GetTotalRamSize() 함수를 통해 가져온다. 뭐, 별거 없음. 밑에 코드를 보면, 대충 화살표나, 쉬프트, 캡스락 키에 대해 무시하게끔 만들었다. 지금까지는, 쉬프트나 그런 키를 입력할때 이상한 문자가 같이 딸려왔었다. 저 코드로 완전히 해결되었다. (다만 저기에 없는 ALT 키같은경우는 여전히 생긴다, 나중에 싹 추가해야지) 뭐, 백스페이스로 지우는거 처리를 하고 그런 역할을 한다. 그리고 가장 중요한 엔터를 누를때 명령어에 대한 처리는, ExecuteCommand함수를 통해 처리된다. void ExecuteCommand(const char * CommandBuffer){    int command_index = 0;    const int length = __StringLength(CommandBuffer);    for(command_index = 0; command_index &lt; length; command_index++)    {        if(CommandBuffer[command_index] == ' ')            break;    }    const int CommandTableSize = sizeof(g_ShellCommandTable)/sizeof(SHELLCOMMAND);    for(int i = 0; i &lt;CommandTableSize; i++)    {        int command_length = __StringLength(g_ShellCommandTable[i].Command);        if((command_length == command_index) &amp;&amp; (_MemCmp(g_ShellCommandTable[i].Command, CommandBuffer, command_index) == 0))        {            g_ShellCommandTable[i].command_callback(CommandBuffer + command_index + 1);            return;        }     }      _Printf(\"\\'%s\\' command not found\\n\",CommandBuffer);  }이 함수는 간단하게, 명령어와 파라미터를 분리시키고, 명령어 테이블에서 명령어에 맞는 함수를 호출한다. 호출하면서 파라미터를 문자열로 넘겨주는 역할을 한다. 커멘드에 있는 모든 함수를 다 소개하기엔 너무 긴거같으니까 help 함수만 보고, 나머지는 깃헙에서 봐주면 좋겠다! //Shell.cvoid Command_Help(const char* _Parameter){    _Printf(\"\\n\");    _Printf(\"============================= Help ===========================\\n\");    const int command_table_size = sizeof(g_ShellCommandTable) / sizeof(SHELLCOMMAND);    int max_command_length = 0;    for(int i = 0; i &lt;command_table_size; i ++)    {        int length = __StringLength(g_ShellCommandTable[i].Command);        if(length &gt; max_command_length)            max_command_length = length;    }    int x,y;    for(int i = 0; i &lt; command_table_size; i++)    {        _Printf(\"%s\", g_ShellCommandTable[i].Command);        _GetCursor(&amp;x, &amp;y);        _SetCursor(max_command_length, y);        _Printf(\" : %s\\n\", g_ShellCommandTable[i].Comment);    }    _Printf(\"============================= Help ===========================\\n\");    _Printf(\"\\n\");    }간단히 말하면 만들어둔 테이블 덕분에 help 땅 치면 위 함수가 호출이 된다. 셸까지 와보니까 슬슬 현대의 OS가 얼마나 대단한건지 보인다. 실제로 개발해보면 운영체제 개론에서 흔히 말하는 부팅과정과는 차원이 다르게 준비할 게 많다. 게다가 부트로더는 저장매체마다 다르게 동작해서 그것도 준비해야하고 …. 하지만 뭐랄까, 눈이 트인다고 해야하나? 로우레벨 프로그래밍에 대해서 눈이 확 트이기 시작하는 느낌이다. 다만, 시간이 많이 들어가긴 한다. 이제 다음은.. 타이머 디바이스 드라이버와, 다다음은 대망의… 테스크 기능으로 넘어가는…쿨럭 아무튼.. 많이 오긴 왔지만, 갈길이 더 멀다! 힘내서 개발하자! ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","CLI","Shell","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/07/18/shell.html"
      },{
        "title": "시간과 관련된 드라이버 개발 완료.",
        "excerpt":"후 드디어 OS개발에 손댈 수 있는 시간이 났다. 그동안 이곳 저곳 다니고 일정이 계속 겹쳐서 시간이 나질 않았다. 사실 노트북 들고다니면서 중간 중간 만지긴 했는데 큰 변화는 아니라서 글 쓰진 않았다. 본문이 시작되기 전에 변경된건 Types.h 에 정의되어있는 BOOL 타입을 unsigned char 을 c99 이후 정의된 _Bool 타입으로 변경했다. 그 이유는 말하자면 조금 복잡한데. 여러이유가 있겠지만 unsigned char 에 대한 ! 연산을 이유로 들겠다. 보통 Not 연산을 진행할때 n xor 1 로 처리하개 되면 빠르게 연산 할 수 있다. 그런데 얼마전에 unsigned char (이전의 BOOL) 에 대한! 연산자랑 n xor 1 의 차이를 보았다.   두 코드를 살펴보면 확실하게 차이가 난다. 물론 컴파일러 최적화 옵션인 -O3 같은 옵션을 붙이면 아마 xor로 변하겠지만, 아무래도 최적화 옵션을 적용했을때 의도하지 않은 동작을 할 가능성이 높다. 일단 최적화 옵션을 붙이지 않는 가정 하에 not 연산은 딱봐도 연산이 많다. cmp 후 setne를 통해 데이터를 설정하게 되는데, 이는 시스템에서 t/f 를 구분할때 쓰는 비트 외에도 사용 될 수 있음을 가정한 것이라고 정리할 수 있다. 이건 _Bool 타입으로 변경하면서 해결(컴파일 하면 두 코드가 동일하게 컴파일 된다. 기억상으론 xor을 썻던 것 같다.) 이제 드디어 본문이다. 이번에는 전반적으로 타이머, 시간과 관련된 부분을 개발했다. 좀더 구체적으로 PIT(Programmable Interval Timer) Driver 의 개발과 Timestamp 그리고 RTC(Real Time Clock) Driver 의 개발이다. 이번에 개발한 드라이버 묶음의 소스 트리이다.  일단 PIT에 접근하는 건 PortIO Driver를 통해 0x43, 0x40, 0x41, 0x42 로 접근 가능하다. 뭐 PortMapIO 가 그렇듯 여러 비트를 열씸히 설정해 주어야 한다. 그중 가장 많으 쓰일것 같은 0x43 컨트롤 필드는 7,6 - SC : Select Counter 커멘드의 대상이 되는 카운터 5,4 - RW : Read/Write 읽기 쓰기 여부     00: 카운터의 현제 값을 읽음 (2byte)    01: 카운터의 하위 바이트를 R/W (1Byte)    10: 카운터의 상위 바이트를 R/W (1Byte)    11: 카운터의 하위 바이트에서 상위 바이트 순으로 R/W (2Byte)3,2,1-Mode: PIT 컨트롤러의 카운트 모드 설정     000: 모드 0 (Interrupt during counting)    001: 모드 1 (Programmable monoflop)    010: 모드 2 (Clock rate generator)    011: 모드 3 (Square wave generator)    100: 모드 4 (Software-triggered impulse)    101: 모드 5 (Hardware-triggered impulse)0   - BCD : 카운터의 값을 바이너리 도는 BCD 포멧으로 설정한다.     BCD 포멧은 0~9999 까지    바이너리 타입은 0x00~0xFFFF 까지각 필드에 대한 자세한 설명은 생략하겠다. 아무튼 SC 필드에 의해 카운터가 선택이 되고 아래는 그 옵션이라고 보면 된다. 아래는 PIT관련된 상수 정의와 함수의 정의가 담겨있는 Driver/Time/PIT.h 이다. #ifndef __PIT_H__#define __PIT_H__#include &lt;Types.h&gt;//PIT의 동작 속도 1.193182MHz #define PIT_FREQUENCY 1193182#define MS_TO_COUNT(x) (PIT_FREQUENCY * (x)/1000)#define US_TO_COUNT(x) (PIT_FREQUENCY * (x)/1000000)#define PIT_PORT_CONTROL    0x43#define PIT_PORT_COUNTER0   0x40#define PIT_PORT_COUNTER1   0x41#define PIT_PORT_COUNTER2   0x42#define PIT_CONTROL_SC_COUNTER0   0x00#define PIT_CONTROL_SC_COUNTER1   0x40#define PIT_CONTROL_SC_COUNTER2   0x80#define PIT_CONTROL_RW_BIT11      0x30#define PIT_CONTROL_RW_BIT00      0x00#define PIT_CONTROL_MODE_0        0x00#define PIT_CONTROL_MODE_2        0x04#define PIT_CONTROL_BCD_FALSE     0x00#define PIT_CONTROL_BCD_TRUE      0x01#define PIT_COUNTER0_FLAG_ONCE  (PIT_CONTROL_SC_COUNTER0 | PIT_CONTROL_RW_BIT11 | PIT_CONTROL_MODE_0 | PIT_CONTROL_BCD_FALSE)#define PIT_COUNTER0_FLAG_INTERVAL  (PIT_CONTROL_SC_COUNTER0 | PIT_CONTROL_RW_BIT11 | PIT_CONTROL_MODE_2 | PIT_CONTROL_BCD_FALSE)#define PIT_COUNTER0_FLAG_LATCH  (PIT_CONTROL_SC_COUNTER0 | PIT_CONTROL_RW_BIT00 )// SET PIT Counter 0 = _Count and Cange state Intervalvoid InitializePIT(WORD _Count, BOOL _IsInterval);WORD ReadTimerCount0();/*    Should be disable Interrupt    Parameter _Count : &lt; 50ms*/void WaitUsingPITCounter0(WORD _Count);#endif /*__PIT_H__*/PIT 장치의 동작 클록은 1.19318 Mhz로 동작하며 매회 카운터의 값을 1씩 감소시켜 0이 될때 신호를 발생시킨다. 클록을 기준으로 동작하는 PIC를 우리가 통상 사용하는 ‘시간’으로 사용하기 위해서 t = 1193182 * rate ( ex: 1ms rate = 0.001 ) 식을 쓴다. 0SOS는 카운터 0를 사용할 것이며 이전부터 카운터 1과 2는 메인 메모리와 PC 스피커를 위해 쓰인다고 한다. 뭐 위 함수 구현하는건 어쩌피 열씸히 PortMapIO를 통해 데이터를 읽고 쓰고 하는 것 뿐이라 복잡하지 않다. #include \"PIT.h\"#include &lt;Driver/IO/PortIO.h&gt;void InitializePIT(WORD _Count, BOOL _IsInterval){    //만약 주기적으로 실행되어야 한다면 모드 2 아니면 모드 0    if(_IsInterval == TRUE)        PortIO_OutByte(PIT_PORT_CONTROL, PIT_COUNTER0_FLAG_INTERVAL);    else        PortIO_OutByte(PIT_PORT_CONTROL, PIT_COUNTER0_FLAG_ONCE);    //카운터의 하위 비트와 상위 비트를 설정    PortIO_OutByte(PIT_PORT_COUNTER0, _Count);    PortIO_OutByte(PIT_PORT_COUNTER0, _Count &gt;&gt; 8);}WORD ReadTimerCount0(){    BYTE high, low;    WORD ret = 0x0000;    //Counter 0 의 데이터를 읽어온다.    PortIO_OutByte(PIT_PORT_CONTROL, PIT_COUNTER0_FLAG_LATCH);    low = PortIO_InByte(PIT_PORT_COUNTER0);    high = PortIO_InByte(PIT_PORT_COUNTER0);    //상위 비트 하위 비트 묶어서 2바이트로 변환    ret = high;    ret = (ret &lt;&lt; 8) | low;    return ret;}void WaitUsingPITCounter0(WORD _Count){    //0~0xFFFF 까지 반복    WORD CurrentCounter = 0;    InitializePIT(0, TRUE);    const WORD LastCounter0 = ReadTimerCount0();    while(TRUE)    {        //Get Counter 0 Value        CurrentCounter = ReadTimerCount0();        //시간이 흐름에 따라 값이 커짐          if(((LastCounter0 - CurrentCounter) &amp; 0xFFFF) &gt;= _Count)            break;        }}보면 크게 복잡한 건 없다. PIT 타이머를 초기화 하는 함수와 Counter 0 의 값을 읽어오는 함수, 그리고 그럴 이용해 ms 단위 대기 함수가 끝. 그럼 다음은 타임 스탬프다. 타임 스탬프는 클록 과 버스 속도 비율에 따라 올라간다고 한다. 따라서 정확하게 올라가는데, 이를 통해 정확한 속도 측정이 가능하다. 코드는 정말로 간단한데, ;Driver/Time/TSC.asm[BITS 64]SECTION .textglobal ReadTSC;타임 스탬프 카운터를 읽어서 반환ReadTSC:    push rdx    rdtsc   ;타임 스탬프 카운터의 값을 rdx:rax에 저장    shl rdx, 32 ; rdx 레지스터의 상위 32비트 tsc 값과 rax레지스터의    or rax, rdx ; 하위 32비트 tsc값을 rax에 저장    pop rdx    retRDTSC 명령어를 이용해 불러오게 된다. 그 다음으론 RTC 드라이버인데, RTC 컨트롤러는 시간 저장을 담당하는 컨트롤러다. 또한 PC가 꺼진 이후에도 기록하기 위해 전원을 쓴다. 맞다 그 메인보드의 수은전지 와 같은것 말이다. CMOS 메모리 안에 RTC 데이터가 가 기록되어 있다. CMOS 에 접근해서 RTC 데이터를 가져와야 한다. CMOS 메모리는 는 ProtIO Driver로 접근 가능하며 메모리 어드레스 포트 0x70 과 메모리 데이터 포트 0x71로 접근이 가능하다. RTC 관련된 주소 필드 표다.  위 표를 참고해서 만들면 된다. //Driver/Time/RTC.h#ifndef __RTC_H__#define __RTC_H__#include &lt;Types.h&gt;#define  PORT_CMOS_ADDRESS      0x70#define  PORT_CMOS_DATA         0x71#define  CMOS_ADDRESS_RTC_SECOND       0x00#define  CMOS_ADDRESS_RTC_MINUTE        0x02#define  CMOS_ADDRESS_RTC_HOUR          0x04#define  CMOS_ADDRESS_RTC_DAY_OF_WEEK   0x06#define  CMOS_ADDRESS_RTC_DAY_OF_MONTH  0x07#define  CMOS_ADDRESS_RTC_MONTH         0x08#define  CMOS_ADDRESS_RTC_YEAR          0x09//BCD 코드 변환 - BCD 코드: 1바이트를 4비트씩 잘라서 10진수 2자리로 표현 ex) 0010 0001 이면 21#define  BCD_TO_BIN(x) ((((x) &gt;&gt; 4) * 10) + ((x)  &amp; 0x0F ))void ReadRTCTime(BYTE* _Out_Hour, BYTE* _Out_Minute, BYTE* _Out_Second);void ReadRTCDate(WORD* _Out_Year, BYTE* _Out_Month, BYTE* _Out_DayOfMonth, BYTE* _Out_DayOfWeek);char* ConvertDayOfWeekString(BYTE _DayOfWeek);#endif /*__RTC_H__*/주소 필드를 정의하는 것과 데이터를 가져오는것, 요일을 문자열로 변경하는역할을 한다. 그리고 CMOS에서 가져온 RTC 데이터는 BCD 코드여서 바이너리로 변경하는 코드가 필요하다. 뭐 이것도 portIO로 열씸히 가져오는거라 딱히 뭐 말할건 없다. //Driver/Time/RTC.c#include \"RTC.h\"void ReadRTCTime(BYTE* _Out_Hour, BYTE* _Out_Minute, BYTE* _Out_Second){    BYTE data;    //CMOS 메모리에서 시간에 관련된 정보를 읽어오는 함수 값은 BCD 코드    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_HOUR);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Hour = BCD_TO_BIN(data);    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_MINUTE);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Minute = BCD_TO_BIN(data);    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_SECOND);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Second = BCD_TO_BIN(data);    }void ReadRTCDate(WORD* _Out_Year, BYTE* _Out_Month, BYTE* _Out_DayOfMonth, BYTE* _Out_DayOfWeek){    BYTE data;    //CMOS 메모리에서 날자와 관련된 정보를 읽어오는 함수 값은 BCD 코드    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_YEAR);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Year = BCD_TO_BIN(data) + 2000; //연도에 2000을 더해 2000년도를 표현    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_MONTH);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Month = BCD_TO_BIN(data);    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_DAY_OF_MONTH);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_DayOfMonth = BCD_TO_BIN(data);        PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_DAY_OF_WEEK);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_DayOfWeek = BCD_TO_BIN(data);    }char* ConvertDayOfWeekString(BYTE _DayOfWeek){    //날자를 요일 문자열로 바꿔주는 함수    static char* WeekStringTable [8] = {\"NULL\", \"Sunday\", \"Monday\", \"Tushday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};    if(_DayOfWeek &gt;= 8)        return WeekStringTable[0];    return WeekStringTable[_DayOfWeek];이로서 드라이버가 완성이 되었다!! 이제 이 드라이버를 열씸히 활용하는 셸 커멘드를 만들었다. void Command_SetTimer(const char* _Parameter){    char ParameterBuffer[200];    PARAMETERLIST pList;    InitializeParameter(&amp;pList, _Parameter);    if(GetNextParameter(&amp;pList,ParameterBuffer) == 0)    {        _Printf(\"settimer {time(ms)} {interval}\\n\");        return;    }    long value;    if(_atoi(ParameterBuffer, &amp;value, 10) == FALSE)    {        _Printf(\"Parameter Decimal number\\n\");        return;    }    if(GetNextParameter(&amp;pList,ParameterBuffer) == 0)    {        _Printf(\"settimer {time(ms)} {interval}\\n\");        return;    }    long interval_value;    if(_atoi(ParameterBuffer, &amp;interval_value, 10) == FALSE)    {        _Printf(\"Parameter is not Decimal number\\n\");        return;    }        InitializePIT(MS_TO_COUNT(value), interval_value != 0);    _Printf(\"Time = %d ms. Interval = %s Change Complate\\n\",value, (interval_value == 0)? \"False\": \"True\"); }void Command_PITWait(const char* _Parameter){    char ParameterBuffer[200];    PARAMETERLIST pList;    InitializeParameter(&amp;pList, _Parameter);    if(GetNextParameter(&amp;pList,ParameterBuffer)==0)    {        _Printf(\"wait {time(ms)}\\n\");        return;    }        long value;    if(_atoi(ParameterBuffer, &amp;value, 10) == FALSE)    {        _Printf(\"Parameter is not Decimal number\\n\");        return;    }    _Printf(\"%d ms Sleep Start...\\n\", value);    DisableInterrupt();    for(long i =0; i &lt; value/30L; i++)    {        WaitUsingPITCounter0(MS_TO_COUNT(30));    }    WaitUsingPITCounter0(MS_TO_COUNT(value % 30));            EnableInterrupt();    _Printf(\"%d ms Sleep Complate.\\n\", value);    InitializePIT(MS_TO_COUNT(1), TRUE); }void Command_ReadTimeStamp(const char* _Parameter){    QWORD tsc =  ReadTSC();    _Printf(\"Time Stamp Counter = %q \\n\",tsc);}void Command_CPUSpeed(const char* _Parameter){    QWORD last_tsc;    QWORD total_tsc = 0;    _Printf(\"Now Calculate.\");    DisableInterrupt();    for(int i = 0; i &lt; 200; i++)    {        last_tsc = ReadTSC();        WaitUsingPITCounter0(MS_TO_COUNT(50));        total_tsc+= ReadTSC() - last_tsc;        _Printf(\".\");    }    InitializePIT(MS_TO_COUNT(1),TRUE);    EnableInterrupt();    _Printf(\"\\n Cpu Clock = %d MHz \\n\", total_tsc/10/1000/1000);}void Command_ShowDateTime(const char* _Parameter){    BYTE Second, Minute, Hour;    BYTE DayOfWeek, DayOfMonth, Month;    WORD Year;    ReadRTCTime(&amp;Hour, &amp;Minute, &amp;Second);    ReadRTCDate(&amp;Year,&amp;Month,&amp;DayOfMonth, &amp;DayOfWeek);    _Printf(\"Date: %d-%d-%d %s, \", Year, Month, DayOfMonth, ConvertDayOfWeekString(DayOfWeek));    _Printf(\"Time: %d:%d:%d\\n\", Hour, Minute, Second);    }복잡시럽게 보이지만 자세히 보면 양만 많지 단순히 값을 받아와서 출력하는것에 불과하다.  커멘드는 이렇게 추가 되었으며 rdtsc 명령어가 멀쩡히 동작한다.  다른 명령어에 대한 결과이다. date를 멋지게 받아오기도 하고 cpu clock 측정도 하고 특정 ms 동안 대기하기도 한다. settimer 명령어도 멀쩡히 동작하나, 이미지로 보여주기엔 한계가 있어서 뺏다. 개발하면서 두가지의 버그를 수정했는데, 하나는 _Printf 함수에 대한 unsigned 값의 의도하지 않은 동작이다. 이는 %q 출력 문자와 _u_itoa 함수를 호출하면서 해결을 하였다. 또 하나는 PIT 에서 컨트롤러0 의 값을 가져올때 실수로 control port를 넣어야 할걸 counter port 를 넣게 되어 계속 리셋이 되는 버그가 있었다. 이는 control 포트로 고치면서 해결했다. 아무튼 여기까지 왔다. 이제 테스크, 멀티쓰래드, 동기화, 실수 연산으로 나아간다. 기대중임. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Timer","Interrupt","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/08/03/timerdriver.html"
      },{
        "title": "TCB와 Context, 그리고 ContextSwitch",
        "excerpt":"이것저것 일이 생기고 시간을 퍼부울 수 있는 환경이 아니라 틈틈히 작업했다 이전에 범용 자료구조라고 Universal Data Structure 해서 UDS라고 디렉토리 이름을 지어줬는데 좀더 고민해보고 찾아보니까 Universal 보단 General 이 더 어울릴꺼같아서 UDS에서 GDS로 이름을 바꾸었다. 본문으로 넘어가서 아직 멀티테스킹 그런건 아니지만, 그것을 지원하기 위한 첫 단추로 Task를 정의하고 Context Switch 를 구현했다. 뭐 화려하고 멋진 그런 모양세는 아니지만 정적이긴 하지만 테스트로 작성한 두 테스크간의 스위칭을 볼 수 있다.  일단, 테스크를 정의하기에 앞서 Context, 문맥이라고 하는부분을 짚고 넘어갈 필요가 있다. 이 문맥이라는 녀석이, OS 개론을 배웠다면 알겠지만 프로세스면 프로세스, 테스크면 테스크 의 실행 상태를 의미한다. 뭐 실행 상태라고 하니까 뭔가 이상한데 말그대로 Register의 값들, Stack등을 문맥이라고 한다. 그 컨텍스트를 말그대로 교환한다는 뜻이고, 이거 실행하다 저거 실행하는걸 할 수 있다는 뜻이다. Task는 개별적으로 처리가 가능한 작업을 의미하는데, 테스크에서 Code, Data는 공유가 가능, Stack, Context 는 독립적임을 유지한다. 테스크의 작업을 일괄 처리 방식으로 처리할때보다 시분할로 나누어 처리할때 레이턴시가 많이 증가한다. 따라서, 0SOS는 시분할 멀티테스킹 기법을 사용할 것이다. 시분할 멀티테스킹은 PIT 컨트롤러의 수 밀리세컨드에서 수십 밀리세컨드 단위로 IRQ 0 인터럽트에 맞춰 테스크를 전환하는 기법이다. 아무튼 OS개론적인 이야기는 일단 뒤로 두고, 위 이미지의 실행 코드는 다음과 같다. //shell.cstatic TCB g_task[2] = {0.};static QWORD test_stack[1024] = {0,};void TaskTask(){    int iteration = 0;    while(1)    {        _Printf(\"[%d] Message from test task Press any key to switching\\n\",iteration++);        _GetCh();        ContextSwitch(&amp;g_task[1].Context, &amp;g_task[0].Context);    }}void Command_CreateTask(const char* _Parameter){    KEYDATA key;    InitTask(&amp;g_task[1],1,0, TaskTask, test_stack, sizeof(test_stack));        int iteration = 0;    while(1)    {        _Printf(\"[%d] message from shell Press any key to switching\\n\", iteration++);        if(_GetCh() =='q')            break;        ContextSwitch(&amp;g_task[0].Context, &amp;g_task[1].Context);          }}대충 본다면, CreateTask 테스크를 초기화(생성)하는 함수다. ContextSwitch Context를 교환해주는 함수다. Task Control Block 해서 TCB 구조체를 정의해줬고 Context에 대해 정의하고 각 Offset을 만들어줬다. 뭐 이번에 작성한 코드가 그렇게 길지 않다. 일단 Tasking 이라는 디렉터리를 만들어 줬다. 테스킹 관련 코드는 이쪽으로 넣으려고 한다. 일단, Tasking/Task.h #ifndef __TASK_H__#define __TASK_H__#include &lt;Types.h&gt;//SS, RSP, RFLAGS, CS, RIP.. 등등 Context#define CONTEXT_REGISTER_COUNT     25#define CONTEXT_REGISTER_SIZE       8#define CONTEXT_OFFSET_GS           0#define CONTEXT_OFFSET_FS           1#define CONTEXT_OFFSET_ES           2#define CONTEXT_OFFSET_DS           3#define CONTEXT_OFFSET_R15          4#define CONTEXT_OFFSET_R14          5#define CONTEXT_OFFSET_R13          6#define CONTEXT_OFFSET_R12          7#define CONTEXT_OFFSET_R11          8#define CONTEXT_OFFSET_R10          9#define CONTEXT_OFFSET_R9           10#define CONTEXT_OFFSET_R8           11#define CONTEXT_OFFSET_RSI          12#define CONTEXT_OFFSET_RDI          13#define CONTEXT_OFFSET_RDX          14#define CONTEXT_OFFSET_RCX          15#define CONTEXT_OFFSET_RBX          16#define CONTEXT_OFFSET_RAX          17#define CONTEXT_OFFSET_RBP          18#define CONTEXT_OFFSET_RIP          19#define CONTEXT_OFFSET_CS           20#define CONTEXT_OFFSET_RFLAG        21#define CONTEXT_OFFSET_RSP          22#define CONTEXT_OFFSET_SS           23#pragma pack(push,1)typedef struct __CONTEXT_STRUCT{    QWORD Registers[CONTEXT_REGISTER_COUNT];} CONTEXT;typedef struct __TCB_STRUCT{    CONTEXT Context;    QWORD ID;    QWORD Flags;    void* StackAddress;    QWORD StackSize;} TCB;#pragma pack(pop)void InitTask(TCB* _Tcb, QWORD _ID, QWORD _Flags, QWORD _EntryPointAddress, void* _StackAddress, QWORD _StackSize);//Link Assembly Filevoid ContextSwitch(CONTEXT* _CurrentContext, CONTEXT* _NextContext);#endif /*__TASK_H__*/   Definition 이 많은데 결국 생각해보면 죄다 배열의 Index고 좀더 자세히보면 다 레지스터다 배열에 때려박을때 고정적인 위치에 때려박으려고 (어셈에선 순서를 지켜줘야한다 ㅋㅋ) 정의해줬다. 그 밑으로는  Context (결국 Register 값들의 배열이다.) *아마 나중에 추가 될 것 같다. 그리고 TCB (이게 중의적일거같다. Task Control Block, Thread Control Block) TCB엔 Cotnext, ID, Flags, 스택주소와 스택 크기가 있다. 그리고 InitTask에 대한 구현인 Tasing/Task.c 이다. #include \"Task.h\"#include &lt;Utility/Memory.h&gt;#include &lt;Descriptor/GDT.h&gt;void InitTask(TCB* _Tcb, QWORD _ID, QWORD _Flags, QWORD _EntryPointAddress, void* _StackAddress, QWORD _StackSize){    _MemSet(_Tcb-&gt;Context.Registers, 0, sizeof(_Tcb-&gt;Context.Registers));        //초기화 과정의 RSP, RBP 해당 Task의 Stack Pointer 기 떄문에 + Size     _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RSP] = (QWORD)_StackAddress + _StackSize;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RBP] = (QWORD)_StackAddress + _StackSize;        //Segment Register Setup in Context     _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_CS] = GDT_KERNEL_CODE_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_DS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_ES] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_FS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_GS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_SS] = GDT_KERNEL_DATA_SEGMENT;        //Next run instruction setup    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RIP] = _EntryPointAddress;    // 0 NT  IOPL  OF DF IF TF SF ZF 0  AF 0  PF 1  CF    // 0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RFLAG] |= 0x0200;       //Setup TCB Block    _Tcb-&gt;ID            = _ID;    _Tcb-&gt;StackAddress  = _StackAddress;    _Tcb-&gt;StackSize     = _StackSize;    _Tcb-&gt;Flags         = _Flags; }결국 각 맴버들 초기화 하는 함수다. 세그먼트는 커널 세그먼트를 등록하고 여러 레지스터의 초깃값을 설정한다. 다음 실행할 코드를 (RIP 레지스터- [PC, Program Counter]) EntryPoint로 등록한다. 그리고 대망의 ContextSwitch 함수 이 함수는 어셈블리 코드와 링킹되어있다. [BITS 64]global ContextSwitchSECTION .text   %macro SAVECONTEXT 0    push rbp    push rax    push rbx    push rcx    push rdx    push rdi    push rsi    push r8    push r9    push r10    push r11    push r12    push r13    push r14    push r15    mov ax, ds    push rax    mov ax, es    push rax    push fs    push gs    mov ax, 0x10    mov ds,ax    mov es,ax    mov gs,ax    mov fs,ax%endmacro%macro LOADCONTEXT 0    pop gs    pop fs    pop rax    mov es, ax    pop rax    mov ds, ax    pop r15    pop r14    pop r13    pop r12    pop r11    pop r10    pop r9    pop r8    pop rsi    pop rdi    pop rdx    pop rcx    pop rbx    pop rax    pop rbp%endmacroContextSwitch:    push rbp    mov rbp, rsp    ;Push RFLAGS in stack    pushfq    ;if _CurrentContext is NULL    cmp rdi,0    je .LoadContext    popfq    push rax    ;For use Context Offset     ;Save SS RSP RFLAGS CS RIP Registers    mov ax, ss    mov qword[rdi + 23 * 8], rax    mov rax, rbp    ;RSP를 Contextswitch 호출 이전으로 되돌림 -(ReturnAddress + RBP)    add rax, 16    mov qword[rdi + 22 * 8], rax    ;Push FLAGS in stack    pushfq    pop rax    mov qword[rdi + 21 * 8], rax        ;Save Cs Segment    mov ax, cs    mov qword[rdi + 20 * 8], rax    mov rax, qword[rbp + 8]    mov qword[rdi + 19 * 8], rax    pop rax    pop rbp    ;Context-&gt;Registers를 채워버림    add rdi, 19*8    mov rsp, rdi    sub rdi, 19*8    SAVECONTEXT.LoadContext:    mov rsp, rsi    LOADCONTEXT    iretq일단 첫번째 파라미터가 Null(0)이면 ShellTask라고 간주한다. .LoadContext로 점프하고 그렇게 된다면 2번째 파라미터의 Context로 Load 하게 된다. 만약 아니라면, 현제 컨텍스트를 저장한다. 저장하고 나서 두번째 파라미터로 로드. 이로써 ContextSwitch 가 끝났다. 코드도 안길고 그렇게 복잡하지도 않지만 이것저것 일때문에 바빠서 오래걸렸다. 쉬엄 쉬엄 취미로 하는 느낌이니까 큰 걱정은 없다. 휴, 다음이 스케줄링이니까 또 달려야지. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Performance","Task","MultiCore","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/08/23/BeginTask.html"
      },{
        "title": "라운드 로빈 스케줄러와 시분할 ContextSwitching",
        "excerpt":"SW 마에스트로 일이 바쁘다 보니 개발 틈틈히 개발해 지금 완성했다. 사실 좀 논것도 있지만. 이번에 개발한 양이라던가, 생각할게 좀 많아서 시간이 걸리기도 했다. 아무튼 이번에 개발한 부분은 MultiTasking을 위한 Round Robin Scheduler 구현과 IRQ0 TimerInterrupt를 이용한 시분할 스케줄링의 구현이다. 구현되서 동작하는 모습이다. 셸과는 별개로 저 글자가 움직인다.(동시에 움직인다).  MultiLevel이 아니기 때문에 일단, 모든 Task는 5ms의 CPU 시간을 가질 수 있다고 지정했다. 위키백과의 말을 빌려 스케줄링이란 다중 프로그래밍이 가능하게 해주는 OS의 동작 기법이라고 한다. 뭐 대충 요약하자면 말그대로 여러 Task를 동시에 쓰는거처럼 만들고 싶은거다. 그 기법도 다양하다 FCFS, SJF … 등등 많인데, 그중에 Round Robin 기법을 사용할 것이다. 우선순위는 고려하지 않고 일단 같은 CPU 시간을 부여하는 방식이다. 뭐, 나중에 멀티레벨 큐를 구성하면 우선순위를 적용 시킬 수 있을것이라고 생각한다. 이것도 고려해야할게 생각보다 많다. 일단 데이터가 (테스크가) 수시로 추가 및 제거가 될것이기 때문에 배열기반 자료구조 보단 연결리스트 기반의 자료구조를 구성한다. 따라서 먼저 Linked List를 구현했다. 네이밍이 좀 구린거 같긴한데 딱히 다른거 안떠올라서 LinkedList라 LList로 짧게 만들었다. LList는 범용 자료구조에 속해서 /GDS/ 디렉터리 안에 구현했다. 다음은 LList의 해더파일이다. node에 list 해더를 심게끔 만들어서 범용성을 좀더 꾀해보려고 했다. #ifndef __LINKEDLIST_H__#define __LINKEDLIST_H__#include &lt;Types.h&gt;#pragma pack(push, 1)typedef struct _struct_Single_LinekdListNode{    void* NextNode; //Single Link Linked List    QWORD ID; //Address or Data}   LLIST_NODE_HEADER;/*    exmple of element data structure.typedef struct _Example_Data{    LLIST_DATA_HEADER header;        int data1;    char data2;} Example;*/typedef struct _struct_LinkedListDescriptor{    void* FirstNode;     void* LastNode;    QWORD Count; } LLIST;#pragma pack(pop)void InitializeLList(LLIST* _Ld);void Push_Back_LList(LLIST* _Ld, void* _Item);void Push_Front_LList(LLIST* _Ld, void* _Item);void* Remove_LList(LLIST* _Ld, QWORD _ID);void* Remove_Front_LList(const LLIST* _Ld);void* Remove_Back_LList(const LLIST* _Ld);void* FindLList(const LLIST* _Ld, QWORD _ID);#endif /*__LINKEDLIST_H__*/Example 구조체처럼 데이터 노드에 해당하는 구조체 앞에 LLIST_NODE_HEADER를 정의해줘야한다. Linked List를 굳이 길게 이야기 할 필요는 없어보인다. 다음은 /GDS/LinkedList.c의 내용이다. #include \"LinkedList.h\"#include &lt;Console/Console.h&gt;void InitializeLList(LLIST* _Ld){    _Ld-&gt;Count = 0;    _Ld-&gt;FirstNode = NULL;    _Ld-&gt;LastNode  = NULL;   }void Push_Back_LList(LLIST* _Ld, void* _Item){       LLIST_NODE_HEADER* header = (LLIST_NODE_HEADER*)_Item;    header-&gt;NextNode = NULL;    if(_Ld-&gt;FirstNode == NULL)    {        _Ld-&gt;FirstNode = _Item;        _Ld-&gt;LastNode  = _Item;        _Ld-&gt;Count     = 1;        return;    }    header = (LLIST_NODE_HEADER*)_Ld-&gt;LastNode;    header-&gt;NextNode = _Item;    _Ld-&gt;LastNode = _Item;    _Ld-&gt;Count++;}void Push_Front_LList(LLIST* _Ld, void* _Item){    LLIST_NODE_HEADER* header = (LLIST_NODE_HEADER*)_Item;    header-&gt;NextNode = _Ld-&gt;FirstNode;    if(_Ld-&gt;FirstNode == NULL)    {        _Ld-&gt;FirstNode  = _Item;        _Ld-&gt;LastNode   = _Item;        _Ld-&gt;Count      = 1;        return;    }    _Ld-&gt;FirstNode = _Item;    _Ld-&gt;Count++;}void* Remove_LList(LLIST* _Ld, QWORD _ID){    LLIST_NODE_HEADER* pre_headaer = (LLIST_NODE_HEADER*)_Ld-&gt;FirstNode;    for(LLIST_NODE_HEADER* iter_header = pre_headaer; iter_header != NULL; iter_header = iter_header-&gt;NextNode)    {        if(iter_header-&gt;ID == _ID)        {            if((iter_header == _Ld-&gt;FirstNode) &amp;&amp; (iter_header == _Ld-&gt;LastNode) )            {                _Ld-&gt;FirstNode = NULL;                _Ld-&gt;LastNode  = NULL;               }            else if(iter_header == _Ld-&gt;FirstNode)            {                _Ld-&gt;FirstNode = iter_header-&gt;NextNode;                            }            else if(iter_header == _Ld-&gt;LastNode)            {                _Ld -&gt;LastNode = pre_headaer;            }             else            {                pre_headaer-&gt;NextNode = iter_header-&gt;NextNode;            }            _Ld-&gt;Count--;            return iter_header;        }        pre_headaer = iter_header;    }        return NULL;}void* Remove_Front_LList(const LLIST* _Ld){    if(_Ld-&gt;Count == 0)        return NULL;    LLIST_NODE_HEADER* header = (LLIST_NODE_HEADER*)_Ld-&gt;FirstNode;    return Remove_LList(_Ld, header-&gt;ID);}void* Remove_Back_LList(const LLIST* _Ld){    if(_Ld-&gt;Count == 0)        return NULL;    LLIST_NODE_HEADER* header    = (LLIST_NODE_HEADER*)_Ld-&gt;LastNode;    return Remove_LList(_Ld, header-&gt;ID);}void* FindLList(const LLIST* _Ld, QWORD _ID){    for(LLIST_NODE_HEADER* iter = (LLIST_NODE_HEADER*) _Ld-&gt;FirstNode; iter!=NULL; iter = iter-&gt;NextNode)    {        if(iter-&gt;ID == _ID)            return iter;    }    return NULL;}일단 연결리스트 자체는 구현이 어렵지 않게 구현했다. 하지만 난관이 하나 있다. 바로 0SOS엔 Heap Allocator가 없단것. 즉, 동적 할당이 불가능하다. 이걸 해결하고, 효율적으로 메모리를 관리하기 위해서 TCB Pooling을 사용하기로 한다. (정적으로 특정 영역을 지정해두고, 이 부분을 케이크처럼 잘라서 할당해주는것.) 8MB 이후 영역부터 TCB Pool 그리고, TCB Pool 위에 TaskStackPool을 구성하도록 한다. 대충 그림으로 표현하자면.  OneNote로 그렸는데 흠… 괜찮나 아무튼 다음과 같은 구조를 가지게 된다. (8MB이후 영역 크기 계산이 귀찮아서 그냥 대충 저렇게 표현했다) 여기서 2MB영억부터  0x205C19까지는 64비트(IA-32e모드)커널 영역이다.  아, 그리고 책에선 ID부분을 32비트 32비트로 나눠서 앞의 32비트 영역이 0이 아니면 할당되었다 이런식으로 처리하길레 내 마음에 들게 고쳤다. 앞0비트부터 55비트까진 ID의 Index 뒤 56비트부터 63비트까진 Status를 나타내는 비트로 정의했다 그림으로 나타내면 다음과 같다.  그렇게 Task.h와 Task.c에 내용을 추가했다. 다음은 Tasking/Task.h 내용이다. #ifndef __TASK_H__#define __TASK_H__#include &lt;Types.h&gt;#include &lt;GDS/LinkedList.h&gt;//SS, RSP, RFLAGS, CS, RIP.. 등등 Context#define CONTEXT_REGISTER_COUNT     24#define CONTEXT_REGISTER_SIZE       8#define CONTEXT_OFFSET_GS           0#define CONTEXT_OFFSET_FS           1#define CONTEXT_OFFSET_ES           2#define CONTEXT_OFFSET_DS           3#define CONTEXT_OFFSET_R15          4#define CONTEXT_OFFSET_R14          5#define CONTEXT_OFFSET_R13          6#define CONTEXT_OFFSET_R12          7#define CONTEXT_OFFSET_R11          8#define CONTEXT_OFFSET_R10          9#define CONTEXT_OFFSET_R9           10#define CONTEXT_OFFSET_R8           11#define CONTEXT_OFFSET_RSI          12#define CONTEXT_OFFSET_RDI          13#define CONTEXT_OFFSET_RDX          14#define CONTEXT_OFFSET_RCX          15#define CONTEXT_OFFSET_RBX          16#define CONTEXT_OFFSET_RAX          17#define CONTEXT_OFFSET_RBP          18#define CONTEXT_OFFSET_RIP          19#define CONTEXT_OFFSET_CS           20#define CONTEXT_OFFSET_RFLAG        21#define CONTEXT_OFFSET_RSP          22#define CONTEXT_OFFSET_SS           23#define TASK_TCBPOOL_ADDRESS        0x800000#define TASK_TCBPOOL_COUNT          4096#define TASK_STACK_ADRESS           (TASK_TCBPOOL_ADDRESS + sizeof(TCB) * TASK_TCBPOOL_COUNT)#define TASK_STACK_SIZE             8192#define TASK_INVALID_ID             0xFFFFFFFFFFFFFFFF//----- TCB STATUS DEFINITION#define TASK_FREE                   0x0000000000000000#define TASK_ALLOCATED              0x0100000000000000#define TASK_STATE_MASK             0xFF00000000000000#define TASK_INDEX_MASK             0x00FFFFFFFFFFFFFF#pragma pack(push,1)typedef struct __CONTEXT_STRUCT{    //RegisterData    QWORD Registers[CONTEXT_REGISTER_COUNT];} CONTEXT;//Include Linked List Header.typedef struct __TCB_STRUCT{    LLIST_NODE_HEADER   list_header;    QWORD               Flags;    CONTEXT             Context;    void*               StackAddress;    QWORD               StackSize;} TCB;  //Management TCB Polltypedef struct __TCB_POOL_MANAGER{    TCB* StartAddress;    int MaxCount;    int Count;    int AllocatedCount;}TCB_POOL_MANAGER;typedef struct __SchedulerStruct{    TCB* Current_Runing_Task;    int CpuTime;        LLIST task_list;}SCHEDULER;#pragma pack(pop)/// TASK POOL &amp; TASK void InitTask(TCB* _Tcb, QWORD _Flags, QWORD _EntryPointAddress, void* _StackAddress, QWORD _StackSize);void InitializeTCBPool();TCB* AllocateTCB();void FreeTCB(QWORD _ID);TCB* CreateTask(QWORD _Flags, QWORD _EntryPointAddress);//Link Assembly Filevoid ContextSwitch(CONTEXT* _CurrentContext, CONTEXT* _NextContext);#endif /*__TASK_H__*/AllocateTCB,FreeTCB, InitializeTCB 등등의 함수와 TCB_POOL_MANAGER 등등의 구조체를 정의했다. 그리고 TCB ID를 위한 MASK. 다음은 c코드이다. #include \"Task.h\"#include &lt;Utility/Memory.h&gt;#include &lt;Descriptor/GDT.h&gt;#include &lt;Console/Console.h&gt;static TCB_POOL_MANAGER g_TcbPoolManager;void InitTask(TCB* _Tcb, QWORD _Flags, QWORD _EntryPointAddress, void* _StackAddress, QWORD _StackSize){    _MemSet(_Tcb-&gt;Context.Registers, 0, sizeof(_Tcb-&gt;Context.Registers));        //초기화 과정의 RSP, RBP 해당 Task의 Stack Pointer 기 떄문에 + Size     _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RSP] = (QWORD)_StackAddress + _StackSize;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RBP] = (QWORD)_StackAddress + _StackSize;        //Segment Register Setup in Context     _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_CS] = GDT_KERNEL_CODE_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_DS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_ES] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_FS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_GS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_SS] = GDT_KERNEL_DATA_SEGMENT;        //Next run instruction setup    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RIP] = _EntryPointAddress;    // 0 NT  IOPL  OF DF IF TF SF ZF 0  AF 0  PF 1  CF    // 0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RFLAG] |= 0x0200;       //Setup TCB Block    _Tcb-&gt;StackAddress  = _StackAddress;    _Tcb-&gt;StackSize     = _StackSize;    _Tcb-&gt;Flags         = _Flags; } void InitializeTCBPool() {     //8MB부터 시작되는 Task Pool 영역 초기화 및 Mananger 초기화    _MemSet(&amp;(g_TcbPoolManager), 0, sizeof(g_TcbPoolManager));    g_TcbPoolManager.StartAddress = (TCB*)TASK_TCBPOOL_ADDRESS;    _MemSet(TASK_TCBPOOL_ADDRESS,0,sizeof(TCB) * TASK_TCBPOOL_COUNT);    for(int i = 0; i &lt; TASK_TCBPOOL_COUNT; i++)        g_TcbPoolManager.StartAddress[i].list_header.ID = i;    g_TcbPoolManager.MaxCount = TASK_TCBPOOL_COUNT;    g_TcbPoolManager.AllocatedCount = 1;} //       STATE //63 ------------ 55 -------0 // 0 0 0 0 0 0 0 0 | address| TCB* AllocateTCB() {    TCB* EmptyTCB;    //TCBPool이 가득 찼다면 NULL을 반환      if(g_TcbPoolManager.Count == g_TcbPoolManager.MaxCount)        return NULL;    //Free 상태인 TCB를 TCBPool에서 선형탐색    for(int i = 0; i &lt; g_TcbPoolManager.MaxCount; i++)    {        if((g_TcbPoolManager.StartAddress[i].list_header.ID &amp; TASK_STATE_MASK) == TASK_FREE )        {            EmptyTCB = &amp;(g_TcbPoolManager.StartAddress[i]);            break;        }    }    //Allocate Count를 이용하여 ID값을 만듬 또한 TASK_ALLOCATED를 or 해서 ALOCATOED 상태로 전환함    QWORD id = (QWORD) (g_TcbPoolManager.AllocatedCount);    EmptyTCB-&gt;list_header.ID = (( id | TASK_ALLOCATED));    g_TcbPoolManager.Count++;    g_TcbPoolManager.AllocatedCount++;        if(g_TcbPoolManager.AllocatedCount ==0)        g_TcbPoolManager.AllocatedCount = 1;        return EmptyTCB;}void FreeTCB(QWORD _ID){    //_ID에서 Index 부분만 추출    QWORD index = _ID &amp; TASK_INDEX_MASK;    //TCB Context 초기화    _MemSet(&amp;(g_TcbPoolManager.StartAddress[index].Context), 0, sizeof(CONTEXT));    //할당 해제    g_TcbPoolManager.StartAddress[index].list_header.ID = index;    g_TcbPoolManager.Count--;}TCB* CreateTask(QWORD _Flags, QWORD _EntryPointAddress){    TCB* task = AllocateTCB();    if(task == NULL)        return NULL;    //스택 어드레스를 구함. TCBPool이 끝나는 주소가 시작주소 + STACKSIZE * INDEX    void* StackAddress = (void*)(TASK_STACK_ADRESS +         (TASK_STACK_SIZE * (task-&gt;list_header.ID &amp; TASK_INDEX_MASK)));        InitTask(task,  _Flags, _EntryPointAddress, StackAddress, TASK_STACK_SIZE);        //스케줄러에 등록    AddTaskToScheduler(task);    return task;} 구체적인 설명은 위에서 했기때문에, 생략하겠다. 이제 가장 핵심인 스케줄러 코드다. 뭐랄까, 생각보다 크게 특별한 내용은 없다. #ifndef __SCHEDULER_H__#define __SCHEDULER_H__#include &lt;Types.h&gt;#include &lt;Tasking/Task.h&gt;//Default CPU Time#define TASK_TIME                   5void InitializeScheduler();void SetCurrentRunningTask(TCB* _Tcb);TCB* GetCurrentRunningTask();TCB* GetNextTask();void AddTaskToScheduler(TCB* _Tcb);void Schedule();BOOL ScheduleInInterrupt();void DecreaseProcessorTime();BOOL IsProcessorTimeExpired();#endif /*__SCHEDULER_H__*/해더파일이다. 스케줄링을 위한 여러 함수와 초기화 함수, Round Robin Scheduling을 위한 최대 CPU 사용시간을 지정해준다. 그냥 코드에서 Schedule 함수가 호출됬을때랑 IRQ0 TimerInterrupt에서 호출됬을때 ContextSwitching 기법이 약간 다르다. 코드에서 Schedule 하는건 그냥 ContextSwitch 하면 되지만, Interrupt때는 IST에 있는 Context 변경해주면서 Context를 지정해주어야한다. 이걸 그림으로 그리려했으나 표현력이 딸려서… ( 젠장 ) 좀더 쉽게말하면 Interrupt 에 쓰이는 IST 영역에 Context가 저장되니까 그걸 변경하면 Interrupt 종료시 자동으로 Contxt Switch가 된다는 이야기. 소스코드로 보자. #include \"Scheduler.h\"#include &lt;Tasking/Task.h&gt;#include &lt;Interrupt/Interrupt.h&gt;#include &lt;Descriptor/IDT.h&gt;#include &lt;Utility/Memory.h&gt;#include &lt;Console/Console.h&gt;static SCHEDULER g_Scheduler;//TCBPool 초기화 및 TaskList초기화void InitializeScheduler(){    InitializeTCBPool();    InitializeLList(&amp;(g_Scheduler.task_list));    //Shell Task를 현제 Task로 지정함    g_Scheduler.Current_Runing_Task = AllocateTCB();}void SetCurrentRunningTask(TCB* _Tcb){    g_Scheduler.Current_Runing_Task = _Tcb;}TCB* GetCurrentRunningTask(){    return g_Scheduler.Current_Runing_Task;}TCB* GetNextTask(){    if(g_Scheduler.task_list.Count == 0)        return NULL;    return (TCB*) Remove_Front_LList(&amp;g_Scheduler.task_list);}void AddTaskToScheduler(TCB* _Tcb){    Push_Back_LList( &amp;(g_Scheduler.task_list), _Tcb);}   void Schedule(){    //스케줄링 리스트가 비어있다면 반환함    if(g_Scheduler.task_list.Count == 0)        return;    //인터럽트 비활성화    BOOL interrupt_status = SetInterruptFlag(FALSE);    TCB* task = GetNextTask();     //다음 Task가 NULL이라면    if(task == NULL)    {        //Interrupt를 복구하고 반환        SetInterruptFlag(interrupt_status);        return;    }    //현제 테스크를 스케줄링 리스트에 등록    TCB* pre_task = g_Scheduler.Current_Runing_Task;    AddTaskToScheduler(pre_task);           //현제 수행중인 Task 변경    g_Scheduler.Current_Runing_Task = task;    //Context Switch    ContextSwitch(&amp;(pre_task-&gt;Context), &amp;(task-&gt;Context));    //Cputime 초기화    g_Scheduler.CpuTime = TASK_TIME;    //인터럽트 복구    SetInterruptFlag(interrupt_status);}//인터럽트에 의해 호출됨BOOL ScheduleInInterrupt(){    //다음 테스크를 가져옴    TCB* task = GetNextTask();    if(task == NULL)    {        return FALSE;    }        //IST STACK에 저장된 CONTEXT ADDRESS    void* ContextAddress = IST_POINTER + IST_SIZE - sizeof(CONTEXT);        TCB* running_task = g_Scheduler.Current_Runing_Task;    //CONTEXT 저장    _MemCpy(&amp;(running_task-&gt;Context), ContextAddress, sizeof(CONTEXT));    g_Scheduler.Current_Runing_Task = task;    AddTaskToScheduler(running_task);    //Context 전환 후 복원    _MemCpy(ContextAddress, &amp;(task-&gt;Context),sizeof(CONTEXT));    g_Scheduler.CpuTime = TASK_TIME;    return TRUE;}void DecreaseProcessorTime(){    if(g_Scheduler.CpuTime &gt; 0)        g_Scheduler.CpuTime--;}BOOL IsProcessorTimeExpired(){    if(g_Scheduler.CpuTime  &lt;= 0)        return TRUE;    return FALSE;   }주석을 구체적으로 달아뒀다고 생각한다. 흠… 이제 Scheduling을 위한 준비는 끝났다. 이제 IRQ0 Timer Interrupt 와 이어서 시분할 멀티테스킹이 가능하게 해줬다. Interrupt/InterruptHandler.c에 다음 함수를 추가했다. void TimerInterruptHandler(int _Vector){    SendPIC_EOI(_Vector - PIC_IRQ_VECTOR);    DecreaseProcessorTime();    if(IsProcessorTimeExpired())    {        ScheduleInInterrupt();        }    }Interrupt/InterruptService.asm 에서 IRQ0인터럽트 ISRTimer:    SAVECONTEXT    mov rdi, 32    call TimerInterruptHandler    LOADCONTEXT    iretq이제 시분할을 위한 준비도 끝났으니, Shell 코드에 다음 내용을 추가했다. void TestTask1(){    BYTE data;    int i =  0, ix =0, iy = 0, iMargin;    CHARACTER_MEMORY* video = (CHARACTER_MEMORY*)CONSOLE_VIDEO_MEMORY;    TCB* task = GetCurrentRunningTask();    iMargin = (task-&gt;list_header.ID &amp; TASK_INDEX_MASK) %10;    while(1)    {        switch(i)        {            case 0:                ix++;                if(ix&gt;=(CONSOLE_WIDTH - iMargin))                    i = 1;                break;            case 1:                iy++;                if(iy&gt;=(CONSOLE_WIDTH - iMargin))                    i = 2;                break;                case 2:                ix--;                if(iy&lt;iMargin)                    i = 3;                break;            case 3:                iy--;                if(iy &lt; iMargin)                    i = 0;                break;        }           video[iy * CONSOLE_WIDTH + ix].bCharactor = data;        video[iy * CONSOLE_WIDTH + ix].bAttribute = data &amp; 0x0F;        data++;        Schedule();    }    }void TestTask2(){    int i =0, iOffset;        CHARACTER_MEMORY* video = (CHARACTER_MEMORY *)CONSOLE_VIDEO_MEMORY;    TCB* task = GetCurrentRunningTask();    char data[4] = {'-','\\\\','/','|'};    iOffset = (task-&gt;list_header.ID &amp; TASK_INDEX_MASK ) * 2;    iOffset = CONSOLE_WIDTH * CONSOLE_HEIGHT - (iOffset % (CONSOLE_WIDTH * CONSOLE_HEIGHT));    while(1)    {        video[iOffset].bCharactor = data[i %4];        video[iOffset].bAttribute = (iOffset % 15) + 1;        i++;        Schedule();    }}void Command_CreateTask(const char* _Parameter){    PARAMETERLIST parameter_list;    char type[30];    char count[30];    InitializeParameter(&amp;parameter_list, _Parameter);    GetNextParameter(&amp;parameter_list, type);    GetNextParameter(&amp;parameter_list, count);    long idx = 0;    long cnt = 0;    _atoi(type, &amp;idx,10);    _atoi(count, &amp;cnt,10);    int i = 0;     switch (idx)    {        case 1:            for( i =0; i&lt;cnt; i++)            {                if(CreateTask(0,(QWORD)TestTask1) == NULL)                    break;            }                  _Printf(\"Task 1 %d Created\\n\", i);            break;        case 2:            for( i =0; i&lt;cnt; i++)            {                if(CreateTask(0,(QWORD)TestTask2) == NULL)                    break;            }                  _Printf(\"Task 2 %d Created\\n\", i);            break;    }}대충 createtask (타입 1,2 중 하나) 개수 명령어로 task를 생성한다. 타입 2는 바람개비같은걸 만들고 타입 1은 빙글빙글 돌아다니는 글자 열? 같은거다. 바람개비는 테스크 하나당 하나를 담당한다. 아무튼, 위에는 깔끔하게 잘 동작하는 코드들일 뿐이다. 동작하게끔 하기까지 수많은 시련이 있었는데,  Exception7 이였다. 구체적인 내용은 x86 시스템에서 7코드인 “Device Not Available” 문제였다. 찾아보면 FPU관련된 문제라고들 하는데, 아직 내 OS는 FPU를 제공하지 않으니 왜그런걸까 고민해봤다. 잘 찾아보니까 이럴수가 Task.h 에서 범용 레지스터 개수는 24개인데 DEFINE에는 25개로 정의해버렸다. 고치고 난뒤, 이번엔 Exception 14 Page Falult가 뜬다. 찾아보고 메모리 뜯어보니까 연결리스트가 문제였다. 고치고 나니까, 멀정해졌다. 뭐, 디버깅 과정에서 메모리 맵 뜯고 난리 쳣지만 결론적으론, 함수호출 하나 잘못한거랑 링크드 리스트 문제가 있었다는거 말곤 없어서 구체적으로 쓰진 않겠다. 휴, 드디어 멀티테스킹이 동작한다. 이제 이 프로젝트는 잠깐 동결될 듯 하다. 소프트웨어 마에스트로 프로젝트를 진행해야해서 아마 내년 1월달에나 재개되지 않을까 싶은데, 소마에서 하는 프로젝트도 LinuxKernel 기반의 운영체제니 뭐… 시간 봐서 종종 일지 올리겠다. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Performance","Task","Scheduling","MultiCore","64bit"],
        "url": "https://devsdk.github.io/ko/development/2017/09/19/Scheduler.html"
      },{
        "title": "NaverWordBookExtractor 개발기",
        "excerpt":"엄청 오랬만에 블로그에 글을 쓰는 듯 하다. 일단 0SOS의 개발은 일시 중단되어있다. 나중에 글을 전부 영어로 작성하게 된다면 그때 다시 시작할까 한다. 그런 의미로 잘 쓰고있는 Naver 단어장에서의 퀴즈 기능의 부족함을 느껴 아는 사람의 추천으로 알게된 quizlet 이란 홈페이지를 이용하고자 했다. QuizLet quizlet을 사용해 본 사람은 알겠지만 데이터를 스프레드시트나 raw text로 단어-뜻 쌍을 집어넣게 되어있다. 하지만 네이버 단어장은 단어들을 파일이나 순수 텍스트로 추출할 수 있는 기능을 전혀 제공하고 있지 않았고  단어장에 저장되어 있는 많은 단어들을 일일히 손으로 옮기기엔 너무 시간이 낭비될 것 같았다. 따라서 간단하게 네이버 단어장 단어 추출 프로그램을 만들어서 사용하기로 했고 간단하면서도 Multiplatform 에 특화되어있는 Python을 이용해 개발하기로 했다. 일단 네이버 자체에서 단어장이나 단어사전쪽에선 손을 놓은건지, 준비중인건진 모르겠지만 API가 전혀 제공되지 않았다. 그렇기 때문에 직접 html 파싱을 통해 데이터를 추출해야 하는데 네이버 단어장은 계정 로그인이 되어있어야 그 계정의 단어장에 엑세스 할 수 있기 때문에 네이버에 로그인을 해야 한다는 문제와 마주치게 된다. 처음엔 selenium을 사용할까도 했으나 별도의 WebDriver 존제가 가볍게 사용하기엔 부적합 할 것 같다는 판단을 하게 되어 selenium 사용은 미루었다. 따라서 네이버 로그인 기능을 웹브라우져에서 처리하는 것 과 같이 해주어야 한다. 따라서 로그인 페이지 를 분석해 보기로 한다.  크롬 개발자 도구를 이용해 로그인 버튼이 눌렸을때의 동작을 살펴보면. &lt;form id=\"frmNIDLogin\" name=\"frmNIDLogin\" target=\"_top\" autocomplete=\"off\" action=\"https://nid.naver.com/nidlogin.login\" method=\"post\" onsubmit=\"return confirmSubmit();\"&gt;        &lt;input type=\"hidden\" name=\"enctp\" id=\"enctp\" value=\"1\"&gt;        &lt;input type=\"hidden\" name=\"encpw\" id=\"encpw\" value=\"\"&gt;        &lt;input type=\"hidden\" name=\"encnm\" id=\"encnm\" value=\"\"&gt;        &lt;input type=\"hidden\" name=\"svctype\" id=\"svctype\" value=\"0\"&gt;        &lt;input type=\"hidden\" name=\"svc\" id=\"svc\" value=\"\"&gt;        &lt;!-- 블라블라블라 기타 코드 생략 --&gt;        &lt;input type=\"submit\" title=\"로그인\" alt=\"로그인\" tabindex=\"12\" value=\"로그인\" class=\"btn_global\" onclick=\"nclks('log.login',this,event)\"&gt;        &lt;!-- 블라블라블라 기타 코드 생략 --&gt;&lt;/form&gt;보면 submit (로그인) 버튼이 눌렸을때 confirmSubmit 함수를 호출하게 되어있고 post로 enctp, encpw 등과같은 다양한 키로 데이터가 보내진다고 보인다. confirmSubmit 함수가 호출된다는 정보를 알았으니 이제 네이버에서 가져오는 js 파일들에서 해당 함수를 찾아보았다.  어렵지 않게 함수를 찾을 수 있었다. function confirmSubmit() {\tvar id = $(\"id\");\tvar pw = $(\"pw\");\tvar encpw = $(\"encpw\");\t\t//if(id.value == \"\" &amp;&amp; encpw.value == \"\") {\tif(id.value == \"\") {\t\tshow(\"err_empty_id\");\t\thide(\"err_empty_pw\");\t\thide(\"err_common\");\t\tid.focus();\t\treturn false;\t//} else if(pw.value == \"\" &amp;&amp; encpw.value == \"\") {\t} else if(pw.value == \"\") {\t\thide(\"err_empty_id\");\t\tshow(\"err_empty_pw\");\t\thide(\"err_common\");\t\tpw.focus();\t\treturn false;\t}\ttry{\t\t$(\"ls\").value = localStorage.getItem(\"nid_t\");\t}catch(e){}\treturn encryptIdPw();}해당 함수이다.보면 대충 아이디 비번 안치면 경고띄워주는 로직이 보인다. 그게 중요한게 아니라딱봐도 수상해보이는 함수가 보인다. encryptIdPw 함수를 호출한다는 단서를 얻었으니 해당 함수를 찾아서 때보면 function encryptIdPw() {\tvar id = $(\"id\");\tvar pw = $(\"pw\");\tvar encpw = $(\"encpw\");\tvar rsa = new RSAKey;\tif (keySplit(session_keys)) {\t\trsa.setPublic(evalue, nvalue);\t\ttry{\t\t\tencpw.value = rsa.encrypt(\t\t\t\tgetLenChar(sessionkey) + sessionkey +\t\t\t\tgetLenChar(id.value) + id.value +\t\t\t\tgetLenChar(pw.value) + pw.value);\t\t} catch(e) {\t\t\treturn false;\t\t}\t\t$('enctp').value = 1;\t\tid.value = \"\";\t\tpw.value = \"\";\t\treturn true;\t}\telse\t{\t\tgetKeyByRuntimeInclude();\t\treturn false;\t}이 함수를 보아 로그인 시 아이디와 비밀번호를 rsa 암호화로 암호화 한 다음 로그인 url (“https://nid.naver.com/nidlogin.login”)에다가 post 요청을 하며 encpw에다가 암호문을 실어 보내는 것 같다. 일단 저 일련의 과정을 처리하기 위해선 알아야 할 것이 session_keys와 keySplit 그리고 getLenChar 함수로 보인다. getLenChar 함수는 원형이 다음과 같다. function getLenChar(a) {    a = a + \"\";    return String.fromCharCode(a.length)}단순히 문자열의 길이를 ascii code로 변환해 주는 함수이다. 그리고 session_keys keySplit 함수를 찾아보면 session_keys는 결론부터 말하자면 “https://nid.naver.com/login/ext/keys.nhn” 에서 가져오는 공개키 생성용 값 (e,n)과 기타등등을 “,”를 구분자로 구분해 가져오게 된다. session_keys의 set 과정을 역 추적해보면 유저가 pw 텍스트박스에 텍스트를 입력했을때 getKeysv2함수를 호출하고 해당함수에서 ajax로 호출해서 설정하게 된다. 예시 (임의의 값이므로 이 값은 동작하지 않음, 보기좋게 개행을 추가했다.) gs0TbOWaCaYxTQ0,102042940,ad1ca063118c32asdd51a8c53119faa8bc9c8cb0f743d8f1b89db53cc8f4647784ab08b0f4704e2a49c85cdf44e1830c04ad3505cb977810768a3cwrrq8ce38d2956892722f45aecc6bfc23248e2fe453a4d20b51344968b8ffa848068d72d05e5aa679fbaef4351e099aea00fd6fccfff598426b0d12bdc660e601dd7a93bbd,010001이제 마지막 KeySplit 함수를 살펴보면 function keySplit(a) {\tkeys = a.split(\",\");\tif (!a || !keys[0] || !keys[1] || !keys[2] || !keys[3]) {\t\treturn false;\t}\tsessionkey = keys[0];\tkeyname = keys[1];\tevalue = keys[2];\tnvalue = keys[3];\t$(\"encnm\").value = keyname;\treturn true}간단한 함수이다. 이제 필요한 정보는 모두 얻었다. 다시한번 간단하게 말하자면 post로 보낼 encpw값에 getLenChar(sessionkey) + sessionkey +\tgetLenChar(id.value) + id.value + getLenChar(pw.value) + pw.value);이 문자열을 받아온 e와 n 값으로 RSA 공개키 암호화 하여 보내면 무엇인가 일어난다 인 것이다. 파이썬으로 간단하게 작성을 해보았다. from bs4 import BeautifulSoup import requestsimport rsafrom rsa import common, transform, coreimport reinfo = { \"id\" : \"\", \"pw\" : \"\" }session = requests.Session()session_key_string = \"\"session_keys = {}def split_keys(a):    keys = a.split(',')    if (a is None or keys[0] is None or keys[1] is None or keys[2] is None or keys[3] is None):        return False    session_keys[\"sessionkey\"] = keys[0]    session_keys[\"keyname\"] = keys[1]    session_keys[\"evalue\"] = keys[2]    session_keys[\"nvalue\"] = keys[3]    return Truedef getLenChar(a):    return chr(len(a))    def encrypt():    id = info['id']    pw = info['pw']    pub_key = rsa.PublicKey(e=int(session_keys[\"nvalue\"],16), n = int(session_keys[\"evalue\"],16))    source  = (getLenChar(session_keys[\"sessionkey\"]) + session_keys[\"sessionkey\"] + getLenChar(info[\"id\"]) + info[\"id\"]            + getLenChar(info[\"pw\"]) + info[\"pw\"])    return rsa.encrypt(source.encode('utf-8'), pub_key)def signin():    session_key_string = requests.get(\"https://nid.naver.com/login/ext/keys.nhn\").text    if(split_keys(session_key_string) is False):        print(\"Error\")        return False    encrypted_source = encrypt()    postdata = {    \"encpw\": encrypted_source.hex(),     \"enctp\": 1,    \"encnm\": session_keys[\"keyname\"],    }    response = session.post(\"https://nid.naver.com/nidlogin.login\", data=postdata)    if response.text.count('\\n') &gt; 50 :        print(\"sigin in error\")        return False            print(response.text)    return True    if signin() is False:    exit(0)여기서 고의인지 실수인진 모르겠으나 session_keys 에서 parsing 해오는 값인 evalue와 nvalue는 반대로 되어있다. 자꾸 Rsa Encrypt 쪽에서 앱이 죽어서 살펴보니 n과 e가 반대로 들어와있었다. 즉, javascript에 있는 evalue는 사실 n 이고 nvalue는 사실 e 다. 이럴수가. 내생각엔 네이버 개발자가 실수 한 것 같다. 아무튼 네이버 로그인 페이지에서 하는 동작과 동일하게 동작한다.만약 info 딕셔너리의 아이디와 비밀번호가 정확하다면 &lt;html&gt;&lt;script language=javascript&gt;location.replace(\"https://nid.naver.com/login/sso/finalize.nhn?url=http%3A%2F%2Fwww.naver.com&amp;sid=rbCj4sWaqQfCweR&amp;svctype=1\");&lt;/script&gt;&lt;/html&gt;이런식으로 리다이렉션 URL이 날아온다.저 URL을 (직접 생성한, 위 예시는 임의로 만든 URL이다.) 타고 가면 로그인이 완료되는데, 리다이렉션 3번을 거친다.이로써 로그인을 완료했다. 완전 깔끔하게 만들곤 싶었으나, 네이버에서 로그인 실패가 5번을 넘어가면 켑챠가 동작하여 로그인 기능이 먹통이 되는데, 여기에 딥러닝같은 걸 사용하기도 그렇고. 그럴땐 그냥 웹브라우져로 (크롬은 시크릿모드) 로그인을 시도해 캡챠를 통과해주면 되는 것 같다. 데이터를 불러와서 파일에 쓰는것 까지는 무난하게 beautifulsoup 4 를 이용해 파싱해 사용한다. 아래 링크는 현제까지 작성된 source code이며, 개선의 여지가 많이 보이나 시간을 많이 투자하진 않고 있다. SourceCode 밤새고 의식의 흐름대로 쓴 글이라 정리를 제대로 못한 느낌이 없잖아 있다. ","categories": ["development"],
        "tags": ["Naver","Web","Parsing","python"],
        "url": "https://devsdk.github.io/ko/development/2018/02/19/NaverWordBookExtractor.html"
      },{
        "title": "Chromium <select>에 대한 Custom ScrollBar 옵션 적용 구현",
        "excerpt":"Issue: http://crbug.com/1076508 Patches:   https://chromium-review.googlesource.com/c/chromium/src/+/2364316  https://chromium-review.googlesource.com/c/chromium/src/+/2418527  https://chromium-review.googlesource.com/c/chromium/src/+/2586293약 3개월 정도 전에 들어간 패치가 실제 라이브 크롬에서 동작한다. 뭔가 기분이 이상하기도 하고 뿌듯하기도 하다.    추가: 누군가는 이 기능을 기다려 왔다는 것을 알게 되었다. 이것 하나 보고서 아…. 크로미움 하길 잘했다…. 라는 생각이 들었다. 전 세계 사람들이 내가 기여한 내용을 눈으로 보고 쓸 것이라는 게 더 기분이 좋은 것 같다.  이것을 보면 이번에 크롬 버전이 업데이트되면서 라이브 크롬 버전에 내가 구현한 기능이 동작한다. 이 기능을 구현하기 전 같은 코드는 이렇게 동작했다.  이 문서에 따르면 크로미움 및 웹킷 기반 웹 브라우저에는 위와 같이 ::-webkit-scrollbar 옵션을 통해 스크롤바에 CSS 프로퍼티를 적용할 수 있다. 가장 첫 번째 gif 이미지를 동작시키는 스타일이다. ::-webkit-scrollbar {    width: 10px;\t\theight:10px;  }  ::-webkit-scrollbar-track {    background: orange;  }  ::-webkit-scrollbar-corner {    background: yellow;  }  ::-webkit-scrollbar-thumb {    background: gray;  }  ::-webkit-scrollbar-thumb:hover {    background: green;  }기여하기 이전에는 같은 코드로 다른 곳에서의 스크롤바(ex: 페이지의 스크롤바)는 아래와 같이 정상적으로 동작한다.  하지만 기존에는 두 번째 gif와 같이 \\&lt;select&gt;에 대하여 커스텀 스크롤 바가 적용되지 않았다. 이 문제를 해결하는 과정에 대해 이해하려면 \\&lt;select&gt;가 어떻게 동작하는지 알 필요가 있다. 우리가 \\&lt;select&gt;를 눌렀을 때 브라우져에서는 새로 웹 팝업을 띄운다. 이것을 Chromium에서 Internal Popup이라고 한다. 그러니까 우리가 \\&lt;select&gt;를 눌렀을 때 웹뷰를 하나 새로 만들고, 거기에 html코드를 넣고, 렌더링하는 것이 현재의 \\&lt;select&gt;가 구현되어 있는 방식이다. 여기서 스타일은 호스트에 정의되어있는 스타일을 Internal Popup에 복사하는 방식으로 구현되어 있다. 자세히 보고 싶으면 실제 코드를 참고하자. 하여튼, 기존의 코드는 element에 대해서 스타일을 적용해 줬지만, pseudo class 스타일인 :-webkit-scrollbar에 대한 스타일 적용기능이 구현되어 있지 않았고, 고려도 되어있지 않았다. ComputedStyle로 부터 문자열 CSS로 시리얼라이즈 한 뒤, Internal Popup에 스타일을 적용시키는 기능을 구현한 것이 이번 기여내용이다. 코드 베이스도 코드 베이스지만 테스트코드가 왕창 늘어났다. Added 태그가 붙은 게 내가 추가한 파일들이다.  1번 패치  2번(:hover) 패치 추가한 테스트 코드가 정말 많다. 그리고 Internal Popup은 다른 팝업이 생성된다는 특수한 케이스라 렌더링을 찍고, 그걸 미리 렌더링한 이미지를 대상으로 픽셀바이 픽셀로 비교하는 테스트인 픽셀테스트를 사용하여야 했다. 이는 플랫폼별로 약간씩 다르게 렌더링 됨을 의미한다. 그것에 대해서 다르지 않도록 불필요한 요소를 제거하는 작업도 주요 포인트였다. 어떤 부분을 수정해야 하고, 조사하는 과정에서의 개발 일지는 안 써놔서 완성된 상태의 코드를 설명하는 정도로 이 글을 끝낼 것이다. 아래부터는 코드레벨의 구현에 관한 이야기다. 시리얼라이즈를 위한 함수 몇 개를 정의했다. //Computed 스타일을 받고 id에 해당하는 스타일을 Serialize 해주는 함수const String SerializeComputedStyleForProperty(const ComputedStyle&amp; style,                                               CSSPropertyID id) {  const CSSProperty&amp; property = CSSProperty::Get(id);  const CSSValue* value =      property.CSSValueFromComputedStyle(style, nullptr, false);  return String::Format(\"%s : %s;\\n\", property.GetPropertyName(),                        value-&gt;CssText().Utf8().c_str());}//Target에 대하여 CSS 요소를 완성시켜주는 함수 (대충 target\\n { } \\n형식으로 css가 만들어진다void InternalPopupMenu::AppendOwnerElementPseudoStyles(    const String&amp; target,    SharedBuffer* data,    const ComputedStyle&amp; style) {  PagePopupClient::AddString(target + \"{ \\n\", data);  const CSSPropertyID serialize_targets[] = {      CSSPropertyID::kDisplay,    CSSPropertyID::kBackgroundColor,      CSSPropertyID::kWidth,      CSSPropertyID::kBorderBottom,      CSSPropertyID::kBorderLeft, CSSPropertyID::kBorderRight,      CSSPropertyID::kBorderTop,  CSSPropertyID::kBorderRadius,      CSSPropertyID::kBoxShadow};  for (CSSPropertyID id : serialize_targets) {    PagePopupClient::AddString(SerializeComputedStyleForProperty(style, id),                               data);  }  PagePopupClient::AddString(\"}\\n\", data);}이 함수들은 ComputedStyle로 부터 CSS 텍스트로 변환하고, CSS 스타일로 만들어 Internal Popup에 적용하는 함수들이다. 이것을 사용하여 복사를 하였을 때 스타일이 잘 적용되었다. 다만 :hover 와 같은 Pseudo style은 조금 복잡한 과정을 거쳐야 한다. :hover를 구현하기 위해 코드를 읽으면서 든 생각은 “렌더러쪽에선 :hover가 어떻게 처리되고 있는가?” (어떤 코드에 의해서 :hover 스타일이 적용되는가?) 였다. 그 가설을 바탕으로 조사했다. 아래는 그 조사를 기반으로 임시 스크롤바 객체 scroll을 이용하여 :hover 스타일을 가져오는 코드이다. scoped_refptr&lt;const ComputedStyle&gt; StyleForHoveredScrollbarPart(    HTMLSelectElement&amp; element,    const ComputedStyle* style,    Scrollbar* scrollbar,    PseudoId target_id) {  ScrollbarPart part = ScrollbarPartFromPseudoId(target_id);  if (part == kNoPart)    return nullptr;  scrollbar-&gt;SetHoveredPart(part);  scoped_refptr&lt;const ComputedStyle&gt; part_style = element.StyleForPseudoElement(      PseudoElementStyleRequest(target_id, To&lt;CustomScrollbar&gt;(scrollbar),                                part),      style);  return part_style;}최종적으로 각각의 스크롤바 스타일에 스타일을 적용하는 코드는 다음과 같다. LayoutObject* owner_layout = owner_element.GetLayoutObject();  std::pair&lt;PseudoId, const String&gt; targets[] = {      {kPseudoIdScrollbar, \"select::-webkit-scrollbar\"},      {kPseudoIdScrollbarThumb, \"select::-webkit-scrollbar-thumb\"},      {kPseudoIdScrollbarTrack, \"select::-webkit-scrollbar-track\"},      {kPseudoIdScrollbarTrackPiece, \"select::-webkit-scrollbar-track-piece\"},      {kPseudoIdScrollbarCorner, \"select::-webkit-scrollbar-corner\"}};  Scrollbar* temp_scrollbar = nullptr;  const LayoutBox* box = owner_element.InnerElement().GetLayoutBox();  if (box &amp;&amp; box-&gt;GetScrollableArea()) {    if (ScrollableArea* scrollable = box-&gt;GetScrollableArea()) {      temp_scrollbar = MakeGarbageCollected&lt;CustomScrollbar&gt;(          scrollable, kVerticalScrollbar, &amp;owner_element.InnerElement());    }  }  for (auto target : targets) {    if (const ComputedStyle* style =            owner_layout-&gt;GetCachedPseudoElementStyle(target.first)) {      AppendOwnerElementPseudoStyles(target.second, data, *style);    }    // For Pseudo-class styles, Style should be calculated via that status.    if (temp_scrollbar) {      scoped_refptr&lt;const ComputedStyle&gt; part_style =          StyleForHoveredScrollbarPart(owner_element,                                       owner_element.GetComputedStyle(),                                       temp_scrollbar, target.first);      if (part_style) {        AppendOwnerElementPseudoStyles(target.second + \":hover\", data,                                       *part_style);      }    }  }이 부분이 이번 기여의 스타일을 적용하는 부분이다. ComputedStyle로 부터 타겟 스타일을 serialize 하여 Internal Popup에 집어넣는다. ","categories": ["Chromium"],
        "tags": ["Chromium","C++","Web Engine","HTML/CSS"],
        "url": "https://devsdk.github.io/ko/chromium/2020/12/13/ChromiumCustomscrollbarForSelect.html"
      },{
        "title": "Chromium CSS에 무한과 NaN 개념 도입하기 - 1",
        "excerpt":"Issue: http://crbug.com/1076508 Patches:   https://chromium-review.googlesource.com/c/chromium/src/+/2465414현재 진행 중인 프로젝트에 대한 활동 기록을 이 블로그에 적고자 한다. 아무래도 기능 추가에 관련된 이야기다 보니 글이 몇 개로 나누어질 것 같다. 이 글은 이 기능을 구현하면서 고민하고, 조사했던 내용을 담았다. https://developer.mozilla.org/en-US/docs/Web/CSS/calc() CSS에는 calc라는 함수가 있다. 이 함수를 CSS에서 직접 사용하면 다음과 같다. div {\twidth: calc(10*2px);}위 결과는 20px값이 width에 반영된다. 앞으로 다룰 내용은 이 함수에 대한 기능 구현이다. Chromium monorail에서 할만한 이슈를 찾던 중, 이 이슈가 눈에 들어왔다. 간결하디간결한 이슈 본문을 보니 간단할 것이라고 생각했다. I'm told that per the spec, calc(1px/0) should compute to infinity and not be a parse error.Testcase:&lt;div style=\"width: calc(1px/0); height: 10px; background: green;\"&gt;&lt;/div&gt;http://plexode.com/eval3/#s=aekVQXANJVQMbAx1yAXgePQOCGwFEQk1ECRJRWRARChwBg50SEaWqi51IU0ZGTxyaHx0Qch8DXgA=요약하자면 1px/0을 했을때 무한을 내놔야 합니다. 라는 내용이다. 이것이 이번 프로젝트의 발단을 알린 첫 이슈의 제시문이였다. 이슈가 제시되었을 때, 부랴부랴 표준 문서를 읽어보았다. CSS3와 MDN을 기준으로 “0으로 나누기는 무시되어야 합니다” 라고 쓰여있었다. 그래서 이슈 제시자한테 표준에 따르면 나누기 0은 무시되어야 한다는데 출처 있니? 라고 물어보았고, 제시자는 “새로운 스팩 CSS Values and Units Module Level 4”를 참조로 알려주었다. 즉, 표준에 따르면 무한, NaN 개념을 calc 함수가 지원해야 했다.  그 답을 보자마자 이슈 owner를 박고 조사를 시작했다. 처음으로 한 것은, calc 함수가 어디서 계산이 되는가를 찾는 것이었다. 기본적인 생각은 다음과 같았다. calc 함수는 CSS 파서에 의해서 계산될 것 다음의 명령어를 치면 결과를 사람이 구별할 정도로 줄어든다. 그곳에서 parser 디렉토리 쪽 코드를 살펴보았다. 명령어를 좀 설명하자면 대소문자 상관없이 calc( 문자가 매칭되는 test.cc가 아닌 .cc 파일로 끝나는 파일을 검색하여 리스트로 나타내라 이다. grep 'calc(' -rni --include=*.cc --exclude=*test.cc 그중에서 눈에 띄는 주석이 있다. 이 글을 쓰면서 생각난 것이지만, k토큰 이름으로 도 검색할 수 있었다고 생각한다. (i.e. kCalc) 이는 크로미움에서 json5 파일을 통해 토큰 식별자를 자동생성하는 메커니즘 덕분에 떠올릴 수 있었다. 하여튼 저곳을 들어가면,  이런 코드를 볼 수 있는데, 이 말은 kCalc 함수에 대하여 참조하는 곳을 찾아서 수식이 계산되는 곳을 찾으면 된다는 것이다.  10개 남짓한 레퍼런스를 보며 소스코드를 보다 보면 third_party/blink/renderer/core/css/css_math_expression_node.cc 코드 안에 관련 코드가 있음을 찾을 수 있다. (대부분 코드는 이렇게 검색할 수 있다) 일단 calc 함수는 재귀적인 방식을 통해 괄호와 사칙연산을 계산한다. 꽤 재밌는 부분인데 좀 간략히 설명하자면, parse 함수 호출→ Additive 함수 호출 → Multiplicative 함수 호출 → parse 함수 호출(재귀) 방식으로 사칙연산의 우선순위를 제공하고 있다. 사실 이러한 구현은, 웹 표준에서 정의하고 있다. 아래는 표준 문서에서 나타낸 식의 계산이다.   이 내용을 깊이 따라가는 것도 꽤 재밌는 일이다. 이곳이 실제 소스코드를 따라가기 좋은 시작 포인트라고 생각된다. 관심 있으면 링크를 타고 가서 보길 바란다. 이제 시작점을 알았으니 값이 계산되는 부분을 찾고, 들어오는 문자열을 이용하여 infinity와 NaN을 구현하면 되는 것이다. 사실 첫 패치에선 NaN을 명시적으로 구현해야 함을 모르고 있었다. 따라서 코드리뷰를 통해 NaN 또한 추가되었다. 이번 포스팅에선 NaN을 다루는 이야기는 나오지 않을 것이다. 함수 콜을 잘 따라가다 보면 이러한 함수에 도달한다.  즉 실질적인 계산을 담당하는 함수다. 무한을 구현하는 것을 정말 간단하게 생각하자면, case CSSMathOperator::kDivide: 에서 right_value가 0이라면 std::numeric_limits&lt;double&gt;::infinity() 를 리턴하면 되는 것이라고 할 수 있다. 따라서 다음과 같이 추가하였다. 또한 토큰에 대하여  와 같이 infinity가 왔을 때 해당하는 형식으로 반환하게 하면 될 것이라고 생각했다. 테스트 작성 위 코드와 함께 test 코드를 작성했다. 테스트 코드를 작성하면서 문제가 되었던 점은 round 함수가 없어 wpt 테스트가 실패하는 것과 blink_unittests 결과가 계속 실패하여 찾아보니 유닛테스트에는 다른 모듈을 이용하여 calc를 계산하고 있음이었다. 블링크 유닛테스트에는 calc 함수에 대해 다른 파서인 sizes_math_function_parser를 이용하여 파싱을 한다. 따라서 그에 해당하는 테스트인 sizes_math_function_parser_test.cc에서 테스트를 진행한다.  이 테스트는 third_party/blink/renderer/core/css/parser/sizes_math_function_parser.cc 안에 있는 CalcToReversePolishNotation 함수를 통하여 파싱이되고 계산이 된다. 스택 기반으로 작성되어 있다. 따라서 이곳에 우리가 필요했던 코드를 넣어줘야 했다. 각각 무한을 스택에 집어넣는 AppendInfinity() 함수를 정의하여 사용하였다. 다음은 스택에서 토큰을 만났을 때 문자열을 비교하여 infinity일시 무한을 집어넣는 코드이다. case kIdentToken:        if (EqualIgnoringASCIICase(token.Value(), \"infinity\") ||            EqualIgnoringASCIICase(token.Value(), \"-infinity\")) {          AppendInfinity(token);          break;        }        return false;이를 통해 유닛테스트 부분은 해결할 수 있었다. 또한, blink_web_tests에 새로운 테스트 파일들을 추가하였다. 자바스크립트 기반의 테스트를 작성하였고, dumpAsText() (이 함수를 호출하면 -expected.txt 라는 파일의 렌더링 결과 텍스트와 비교한다. 간단히 말하면 화면에 나오는 텍스트를 덤프 뜨는 것)를 사용하였다. 아래는 새로 추가한 blink/web_tests/css3/calc/calc-infinity.html 파일이다. &lt;!DOCTYPE HTML&gt;&lt;div id=\"dummy\"&gt;&lt;/div&gt;&lt;div id=\"results\"&gt;Calc could handle an infinity value&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;script&gt;if (window.testRunner)    testRunner.dumpAsText();var tests = [    \"1px * infinity / infinity\",    \"1px * 0 * infinity\",    \"1px * (infinity + -infinity)\",    \"1px * (-infinity + infinity)\",    \"1px * (infinity - infinity)\",    \"1px * infinity\",    \"1px * -infinity\",    \"1px * (infinity + infinity)\",    \"1px * (-infinity + -infinity)\",    \"1px * 1/infinity\",    \"1px * infinity * infinity\",    \"1px * -infinity * -infinity\",];var results = document.getElementById(\"results\");var dummy = document.getElementById(\"dummy\");for (var i = 0; i &lt; tests.length; ++i) {    var expression = tests[i];    dummy.style.width = 'calc(' + expression + ')';    results.innerHTML += expression + \" =&gt; \" + dummy.style.width + \"&lt;br&gt;\";}&lt;/script&gt;위 결과는 blink/web_tests/css3/calc/calc-infinity-expected.txt 파일로 다음과 같이 저장되고 추후에 테스트에 사용된다. Calc could handle an infinity value1px * infinity / infinity =&gt;1px * 0 * infinity =&gt;1px * (infinity + -infinity) =&gt;1px * (-infinity + infinity) =&gt;1px * (infinity - infinity) =&gt;1px * infinity =&gt; calc(infpx)1px * -infinity =&gt; calc(-infpx)1px * (infinity + infinity) =&gt; calc(infpx)1px * (-infinity + -infinity) =&gt; calc(-infpx)1px * 1/infinity =&gt; calc(0px)1px * infinity * infinity =&gt; calc(infpx)1px * -infinity * -infinity =&gt; calc(infpx)패치 작성 테스트와 소스코드를 추가한 한 뒤, 이렇게 완성한 패치를 git cl format을 통해 포멧팅을 하고, 소스코드를 정리하는 등 적절히 정리하여 아래와 같은 커밋메시지와 함깨 패치를 올렸다.   여러 글로 나뉠 것 같았는데, 이번 글은 여기서 끊는 게 맞을 것 같다. 다음 글에는 이 패치에 대한 코드리뷰, 그리고 그것에 대한 반영 부분일 듯하다. ","categories": ["Chromium"],
        "tags": ["Chromium","C++","Web Engine","HTML/CSS","InfinityAndNaN","DevLog"],
        "url": "https://devsdk.github.io/ko/chromium/2020/12/24/ChromiumCSSInfinityAndNaN-1.html"
      },{
        "title": "html webpack plugin URL undefined 이슈",
        "excerpt":"짧은 포스팅 WebPack에는 html-webpack-plugin 이라는 플러그인이 있다. HTML을 불러와서 컴파일 한 녀석에 붙여주는 역할을 한다. 링커랑 비슷한 것 같기도 하다. DFD의 favicon을 추가하는 작업을 하다가 계속 이 에러메시지를 보았다. &lt;link rel=”icon” type=”image/x-icon” href=”static/favicon.ico” /&gt; 이 태그가 들어가면, 정확히는 href가 포함된 태그가 들어가면 아래와 같은 메시지를 내보내며 컴파일 에러를 띄운다. ERROR in   Error: /home/seokho/projects/DFD-WEB/public/index.html:147  var ___HTML_LOADER_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./static/favicon.ico */ \"./public/static/favicon.ico\"), __webpack_require__.b);                                   ^  ReferenceError: URL is not defined    - index.html:147     /home/seokho/projects/DFD-WEB/public/index.html:147:34    - index.html:153     /home/seokho/projects/DFD-WEB/public/index.html:153:3    - index.html:156     /home/seokho/projects/DFD-WEB/public/index.html:156:12    - index.js:136 HtmlWebpackPlugin.evaluateCompilationResult    [DFD-WEB]/[html-webpack-plugin]/index.js:136:28    - index.js:333     [DFD-WEB]/[html-webpack-plugin]/index.js:333:26    - async Promise.all    - async Promise.all왜 그런 것이지 하고 검색을 해도 방법이 잘 나오지 않았다. 의심한 건 가장 첫 번째로 노드 버전이다. 아니나 다를까 버전이 아주 낮았다. 업데이트해도 해결이 되지 않았다. 그래서 HtmlWebpackPlugin 이쪽 코드를 한번 보자고 깃헙에 들어가서 소스를 읽고 이슈리스트를 보았다. 아니나 다를까, 3일 전에 2.0으로 업데이트된 html-loader 라는 녀석에서 발생하는 이슈였다. https://github.com/jantimon/html-webpack-plugin/issues/1602 이슈가 해결되는 패치가 등장하기 전까진, html-loader 버전을 2.0에서 1.3.2 으로 다운그레이드 하는것으로 해결 ","categories": ["development"],
        "tags": ["Webpack","html","Web"],
        "url": "https://devsdk.github.io/ko/development/2021/02/18/Webpack-HtmlLoader-Issue.html"
      },{
        "title": "Chromium, Event Loop는 싱글 스레드",
        "excerpt":"이곳저곳 코딩테스트를 마치고, 면접준비를 하면서 Javascript의 Event Loop에 대하여 설명하세요 라는 질문이 자주 나온다는 사실을 알았다. 내가 기억하는 이벤트 루프는 싱글스레드라서  태스크들을 순서대로 처리한다는 것이었다. 자바스크립트를 자주 사용했고, 분명 언제 본 내용일 텐데 까먹어서 표준 문서와 브라우져 코드를 좀 보았다. 검색을 하니까 알기 쉽게 잘 나와 있는 글을 발견했다. https://meetup.toast.com/posts/89 이 글을 보고,  의문점이 좀 생겨 알아보기로 했다. 2. 이벤트루프의 정의 WHATWG의 HTML 표준에 따르면, To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops “이벤트, 유저 인터렉션, 스크립트, 렌더링, 네트워킹 등등과 같은 것들은 이벤트 루프를 반드시 사용해야 합니다.” 즉 무엇인가 “일” (화면을 그린다거나, HTML을 파싱한다거나)을 하는 모든 것들은 이벤트 루프를 사용해야 한다고 명시되어 있다. 실제로 표준에서는 구체적으로 어떤 일들이 이벤트 루프를 사용할지 적어두었다. 내가 이해한 바로는, 웹브라우저가 OS 라고 한다면, Event Loop라는 CPU에서 처리되어야 한다는 느낌을 받았다. 하지만, 위 구조라면 통신과 같은 작업이 동기적으로 실행되고 이는 HTTP 통신이 있다면 다른 태스크를 실행하지 못한다는 이야기가 된다. 우리가 웹 환경을 이용하면서 통신이 있을 때마다 클릭이 안 된다거나 그런 일은 있지 않았다. 어떻게 된 일일까? 3. 이벤트루프 MDN의 Concurrency model and the event loop 에 따르면, 현대 자바스크립트는 다음 그림으로 설명할 수 있다.  위 이미지에서 중요하게 봐야 할 것은 단일스택 이라는 점이다. 또한 중요하게 다루고 있는 개념이 있는데 “Run-to-completion”이다. 메시지가 처리되고 난 뒤 다음 메시지를 처리하는 것이다. (만약 무한루프와 같이 처리가 끝나지 않는다면 다음 이벤트는 영원히 처리되지 않게 된다. 물론 브라우져에서 이에 대한 alert을 제공한다.) 위에서 말한 것과 같이 Event Loop 혹은 Message Queue에는 다양한 작업이 들어간다. 이 다양한 작업 중 하나인 Javascript Execution의 끝은 무엇일까? 조금 단순히 말하자면, 스택이 비었다→ JS작업이 완료되었다고 볼 수 있다. 그렇다면 여러 콜백 함수, 비동기적인 실행은 어떻게 처리하는 것일까? 4. 이벤트루프의 내부 구조 이벤트루프에 등록된 일들은 태스크라는 단위로 변경되어 브라우져에서 처리된다. (사실 크롬에서는 EventLoop 라는 개념이 스팩과 조금 다르게 구현되어 있다.)       third_party/blink/renderer/platform/scheduler/public/event_loop.h       // The specification says an event loop has (non-micro) task queues. However,  // we process regular tasks in a different granularity; in our implementation,  // a frame has task queues. This is an intentional violation of the  // specification.      문서와 코드를 좀 보니까, 의외로 금방 찾았는데 MessagePump라는 곳에 있었다. Chromium에서의 스케줄링은 다양한 방식으로 진행한다. 그리고 그 스케쥴링의 결과가 아래 함수에서 실행된다. 아래 코드에서 Task는 이벤트랑은 조금 다른, 브라우져에서 관리하는 실행 컨텍스트이다. DoWork 내에서 우리가 알고있는 이벤트 루프의 행위가 벌어진다. [여기] 서 더 자세히 볼 수 있다.  연관된 코드가 너무 많아 다 설명하기 어려울 것 같지만 위 코드면 어느 정도 정리가 될 것 같다. 위 코드를 보면 무한루프 속에 태스크가 순차적으로 실행되고 있음을 알 수 있다. 태스크는 아마도 스케줄러에 의해 계속 변할 것이다. (Event Loop의 경우 microtask를 우선 실행하고, 원래 태스크를 실행하는 그런 일련의 작업) 메인 Task가 아니거나, 비동기적으로 실행될 수 있는 태스크의 경우 다른 곳에서 실행된다. setTimeout, xmlhttprequest와 같은 것은 내부 API를 사용하며, JS에서는 Non-Blocking으로 실행된다. 이들은 메시지 큐를 콜백 혹은 이벤트를 등록하는 데 사용한다. 만약 async 태스크가 완료되었다면 아까 등록한 이벤트나 콜백을 이벤트루프에 던져서 실행하는 형식이다. 그렇다면 그때 또 다른 실행 context가 생길 것(스택이 쌓이고 등등..)이고, 그 태스크가 끝나면 다음 이벤트를 처리할 것이다. 따라서 이벤트루프, 자바스크립트의 동작은 싱글스레드 지만, 내부적인 동작이나, API(DOM API 등) 들은 다른 Thread를 활용할 수도 있다. 하지만 이러한 요청과 결과는 이벤트 루프에 의해 순차적으로 처리된다. 부족한 내용이나, 틀린 내용이 있으면 언제든지 댓글을 … ","categories": ["development"],
        "tags": ["Chromium","Javascript","Web Sepc"],
        "url": "https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html"
      },{
        "title": "Chromium 첫번째 패치부터 지금까지 돌아보기",
        "excerpt":"Chromium에서 활동한 지 반년 정도 되어가는 것 같고, 11개의 패치를 머지시켰다. 라인수로는 정확하지는 않지만 1600라인 넘게 수정한 것 같다.  그중의 하나인 첫 패치는 deprecated 된 매크로 함수를 지우는 오타 수정과 비슷한 패치 trivial 패치여서 제외하면 10개에 도달한 것이다. 이 말은 커미터가 되기 위한 조건 중 첫 번째를 달성했다는 것이다. 10-20 non-trivial patches in the Chromium src Git repository 2~3개월 내로 커미터를 달 수 있을 것이라고 기대하고 있는데, 언제 노미네이션 될지는 잘 모르겠다. 크로미움 이메일 주소 가지고 싶다…. 웹브라우져를 만들자 사실 Chromium 건들기 시작하게 된 계기는 반년 전이 아니라 1년 전이다. 친한 형하고 놀면서 (프론트엔드 개발자) 이야기하다가 웹브라우져를 이해하기 위해 웹브라우져를 만드는 프로젝트를 해보고 싶다는 대화가 오고 갔다. 그렇게 웹브라우져의 코드를 분석하고 공유하는 팀인 team_seoksoo (친한 형 이름이 ‘영수’라 내 이름의 석과 형 이름의 수를 붙여 만들었다.)를 만들게 되었다. 시작부터 수월하지는 않았다. 상대는 3000만 라인이 넘는 거대한 오픈소스 프로젝트 Chromium과 하나부터 알아가야 했던 WebKit이였기 때문이다. 첫번째로 직면했던 문제 중 하나는 레포 덩치가 어마어마하다는 것이다. 여기서 볼 수 있는 Chromium의 권장 빌드 스팩은 다음과 같다.   A 64-bit Intel machine with at least 8GB of RAM. More than 16GB is highly recommended.  At least 100GB of free disk space.  You must have Git and Python v2 installed already.실제로 내 컴퓨터에서는 150GB (…) 정도를 크로미움이 먹고 있다. 빌드하는데는 3시간 정도 걸린다. (XPS 9560 최고급모델, i7 7700HQ, 32GB) ) 이 글을 쓰기 한참 전부터 빌드를 돌려놨는데 아직도 끝나지 않았다.. 우여곡절 끝에 코드를 받고 빌드해서 실행까지 해내는 데 성공했고, 그 시기에 Blink Renderer의 정수가 담긴 문서 “Life of Pixels“를 보게 되었다. “웹브라우져가 구체적으로 어떻게 동작하는구나~” 라는 것을 배울 수 있던 시기였다. idl에 대해 배우고, 콘솔에 로그 찍어보고, 여타 다른 것들 분석하듯이 분석하다가,  자연스럽게 다른 task들의 비중이 높아지고, 팀의 의욕이 줄어들어서 (서로 본업과, 학업 및 기타 등등) 멈춘 것 같다. 그렇게 2학년 1학기가 흘러갔다. 본격적인 시작 Chromium 활동에 불이 다시 붙은 건 2학년 여름방학이었다. 컨트리뷰톤이라는 활동에서  Chromium 팀에 선정되었다. 대단한 멘토 분들 (hyunjune.kim&amp;samsung.com,jh718.park&amp;gmail.com) 이 컨트리뷰션 프로세스에 대해 잘 알려주고 간단한 trivial issue를 지정해줘서 전체적인 컨트리뷰션 프로세스를 경험할 수 있었다. 그리고 GoodFirstBug 라는 태그를 이용해 초심자가 해결하기 좋은 이슈를 찾아다녔다. (그렇게 나는 속았다.) 사실 GoodFirstBog로 분류된 이슈 중에서는 사실 GoodFirstBug가 아닌 경우도 꽤 많고, 까고 보니까 규모가 커지는 경우도 많은 것 같다. 컨트리뷰톤 내내 잡고 있던 이슈는 select의 스크롤바 이슈를 해결하는 것, 이 내용에 대해서는 이 글에 나와 있다. 놀랍게도 GoodFirstBug였다. 이 패치 말고도 html form의 validation message를 수정하는 등의 패치를 이어나갔다. 그렇게 패치를 이어나가고, 3~4패치가 머지 되었을 때 멘토님이 커미터 분들한테 프로젝트 맴버 권한을 요청해주셨다. 그렇게 받은 권한들.  tryjob-access: testfarm에 테스트를 실행하고 코드 리뷰를 받고 내 패치를 머지시킬 수 있는 권한 edit-bug-access: https://crbug.com/ 에 올라온 모든 이슈를 직접 수정할 수 있는 권한. (이 권한이 있어야만 볼 수 있는 이슈도 있음). 이 권한들이 있고 없고의 차이가 꽤 크다고 생각한다. 권한을 받고 활동을 하면서 욕심이 생겼다. 원동력이 된 것들은 다음과 같다.   영어를 계속 사용할(사용해야만) 환경  디버깅 능력을 입증할 기회  모두가 쓰는 SW를 개발한다는 것에 대한 자부심  코드를 읽고 수정하는 능력 향상 및 증명  전 세계의 훌륭한 개발자들과의 협업  맡은 것에 대한 책임감  프로젝트 맴버로써 받은 권한에 대한 자부심  탐나는 ssh&amp;chromium.org 커미터 이메일 (중요한 동기부여라고 생각한다.)  취업에 도움이 될 것  좋은 코드를 유지하는 방법에 대해 코드 리뷰를 받으며 성장 기회  그리고…. 재미있다.계속 커밋을 하고 리뷰를 받으며 점점 “내가 Owner로 마크한 이슈들을 해결하는 것”에 책임감을 가지고 조금 더 나은 방향과 좋은 구조를 항상 고민할 수 있게 되었다. 디버깅 관련 지식이 많이 늘어났다. chrome://tracing 에서 트레이싱할 수 있는 것들이 정확히 어느 시점에서 (브라우져 내부에서) 기록이 되고 있는지를 그리고 -show-paint-rects와 같은 실제로 draw가 일어나는 영역에 대한 디버깅 관련한 지식을 3D Preserve 관련 패치를 하면서 살펴볼 수 있었다.  Chromium 개발은 꾸준히 진행 중! 그러다가 현재에 와서, Chromium에 정식 기능 추가 절차를 밟으며 CSS에 기능을 추가하는 “프로젝트”를 진행하게 되었다. 처음에는 작은 이슈에 대한 간단한 패치였지만, 이 내용이 커지고 CSS 전반적으로 영향을 미치게 되면서 프로젝트가 되었다. Chromium에 feature 도입 상태에 대해 볼 수 있는 곳 Chromium Feature Status에 정식으로 등록되어 었다. 이 프로젝트를 진행하며 Design Docs를 쓰게 되었는데, 논의가 필요한 부분이 있어서 구글 본사 Chrome 팀 직원분과 Google Meet을 통해 화상통화를 하며 프로젝트에 대해 논의하는 어찌 보면 꿈과 같은 경험을 하게 되었다.   화상회의 한 번으로 프로젝트의 진행 방향을 어느 정도 정리할 수 있었다. (여러 패치로 나누는 것, W3C의 스팩이 부족한 점이 있어서 논의가 필요한 부분이 있다는 것, 이 값에 대한 “animation” 에서의 “보간”에 대해 추후에 논의가 필요할 것 같다 등등) 이 프로젝트는 현재 진행형이다. 3개의 패치가 이 프로젝트에 대한 패치이다. 어떤 기능을 함께 만들어나간다는 기쁨을 온몸으로 즐기고 있다. 느낀것 혹은 얻은 것은 다음과 같다.   Full Test driven의 이점과 3000만 라인의 거대한 프로젝트가 높은 퀄리티로 유지되는 방법  웹 표준의 중요성. Browser 간의 interoperability를 생각하는 능력  개발자를 위한 좋은 인프라가 생산성에 어떤 이점을 주는지 (Chromium Source Search)  Code-review의 순기능  Blink-dev에 새로 나오는 기능을 살펴보는 습관  웹으로 무엇이든 할 수 있게 될 것이라는 생각  매우 높은 수준의 개발자들과의 협업  스택오버플로우 없이 문제 해결하기 (내부적인 이슈들은 소스코드를 보고 내가 해결해야 한다.)  생각보다 웹브라우져에는 버그가 많다 (특히 scroll 쪽 이슈들 )혹시 이 글을 보고 Chromium에 흥미가 생겼다면, 오픈소스 개발자의 문은 언제나 열려있다! 누구든 같이 Chromium을 개발하면 좋겠다. 취준생이 돼서 개인프로젝트도 진행하며 바빠지고, 불안함이 많아졌지만, 시간 날 때마다 책임감을 가지고 활동을 이어나가고 있다. ","categories": ["development"],
        "tags": ["Chromium","Open Source"],
        "url": "https://devsdk.github.io/ko/development/2021/03/02/FirstStoryWithChromiumContributing.html"
      },{
        "title": "Flux 아키텍처",
        "excerpt":"이번 글에서는 면접 질문으로 들어왔던 Redux 써봤냐 → 그럼 flux 구조를 아느냐 에 대한 답변을 내 개인적으로 시원하게 하지 못해 아쉬움에 내용을 정리해 보도록 한다. Q: Flux 구조에 대해서 알고 계신 게 있나요? “사실 Flux는 들어만 보았고, 정확하게 어떤 것을 의미하는지는 기억하지 못합니다. 저는 이 구조가 글로벌 상태 관리를 하는 패턴이라고 알고 있습니다. 이 구조를 활용한 Redux를 사용하여 어플리케이션을 개발했는데~”. 이번 기회에 Flux 구조에 대해 다시 한 번 공부해보도록 한다. 3줄 요약부터 해보도록 한다.   FLUX는 MVC패턴과 같은 패턴의 한 일종이다.  단방향으로 데이터가 흐른다.  Redux와 같은 녀석들은 이러한 구조를 편하게 쓸 수 있게 해주는 것들이다.사실 위 3줄 요약보다 더 간단한 이미지가 있다.  화살표는 데이터의 흐름을 의미한다. 이미지에서 볼 수 있듯이 단방향으로 흐른다. 그렇다면 만약 사용자가 인터렉션을 취해서 상태를 변경한다면 어떻게 될까?  다시 dispatcher를 통해 데이터를 action을 이용해 보내게 된다. Dispatcher Dispatcher는 Flux 아키텍처에서 모든 데이터의 흐름을 관리한다.  액션을 분배하고 store에 콜백을 등록하는 등 간단한 메커니즘으로 동작한다. Action Creator가 새로운 action이 있다고 dispatch를 호출하면 어플리케이션의 모든 store는 action을 등록한 callback으로 전달받는다. 아래는 dispatcher의 실제 구조이다. dispatch(payload: TPayload): void {    invariant(      !this._isDispatching,      'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.'    );    this._startDispatching(payload);    try {      for (var id in this._callbacks) {        if (this._isPending[id]) {          continue;        }        this._invokeCallback(id);      }    } finally {      this._stopDispatching();    }  }https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/Dispatcher.js#L180 위 설명대로 모든 callback을 invoke한다. (_invokeCallback함수에서 payload를 전달해준다.) Store 스토어는 어플리케이션의 상태와 로직을 가지고 있다. Store라는 이름답게 상태를 저장하고 있다고 생각해도 좋을 것 같다. store는 개별적인 도메인에서 상태를 관리해주는데 이는 스토어별로 dispatcher token을 별도로 할당하기 때문이다. 이걸 조금 더 풀어쓰기 위해 flux 공식 문서에 따르면 “페이스북의 되돌아보기 비디오 편집기”는 트랙의 플레이 백 포지션 같은 정보를 TimeStore에 관리(트레킹) 하고 “이미지”는 ImageStore에서 관리하는 것을 말할 수 있다. Action Dispatcher는 action을 호출해 데이터를 불러오고 store로 전달할 수 있게 해주는 메서드를 제공한다. 변경할 데이터가 담겨진 객체라고 이해해도 괜찮을 것 같다. 이런식으로 생겼다. {      actionType: 'city-update',      selectedCity: 'paris' }View와 Controller-View store로부터 이벤트를 받으면 데이터를 비교하여 setState()  또는 forceUpdate() 매서드를 호출하게 되어 화면이 갱신된다. 컨트롤러 뷰는 자식에게도 데이터를 흘려보낸다고 한다. https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/container/FluxContainer.js#L187 여기서 그 역할을 하는 것 같다. Redux? Redux는 Reducer + Flux 라는 뜻을 가지고 Flux에서 간소화시키고 간단한 사용을 주제로 개발되었다고 한다. Flux 개발자인 Jing Chen이나 Bill Fisher의 찬사를 받았다고 한다. 아래는 차이점이다.   리덕스는 스토어가 하나이고, 디스페쳐가 없으며, immutable state(Reducer가 순수함수여서 copy 해서 replace 하는 방식으로 변경)이라고 한다. 나중에 기회가 된다면 redux 내부 코드도 한번 훑어보고 싶다. ","categories": ["development"],
        "tags": ["React","Web","Flux"],
        "url": "https://devsdk.github.io/ko/development/2021/03/03/FluxArchitecture.html"
      },{
        "title": "SCL Notion Checklist generator 개발",
        "excerpt":"아침 일찍 일어나서 취업준비를 위해 Chromium 커밋 리스트를 다시한번 훑어보는데 아뿔싸… 머지한 커밋중에 Commit Message와 코드가 다른 것을 보았다. 아래는 커밋 메시지 중 일부분.  아래는 실제 코드  아무래도 패치셋이 진행되면서 이름을 바꾸게 되었는데, CR+2받고 그냥 머지시킨 것 같다. 앞으로도 이런 실수를 안 하리라는 보장이 없기 때문에 scl이라는 간단한 프로젝트를 진행했다. 아이디어는 다음과 같았다. “Commit Checklist를 패치별로 notion에 저장하면 편하지 않을까?” notion은 api를 아직 정식으로 제공하지 않는다. Private test 중이라고 하는데, 언제 열릴지 모르기 때문에 그걸 기다리기는 건 어려울 것 같다는 결론을 냈다. 처음에는 golang으로 짜인 라이브러리가 보이길래, go언어로 짜다가 block(노션의 컨텐츠)를 생성하는 것이 없어 다른 방법을 찾아보았다. 그렇게 API를 따서 python 라이브러리로 만든 notion-py을 발견했는데, notion 대부분의 기능을 사용할 수 있어서 python으로 갈아타기로 했다. 개발환경이 워낙 CLI와 가깝다 보니 CLI 기반으로 작성하였다. 레포지토리 https://github.com/DevSDK/scl ","categories": ["development"],
        "tags": ["Python","Notion","CLI","Productivity"],
        "url": "https://devsdk.github.io/ko/development/2021/03/06/IntroduceSCL.html"
      },{
        "title": "Chrome Inspector로 화면이 왜 느린지 찾아보기",
        "excerpt":"DFD를 구현하고 항상 들던 의문이 있었다. 화면을 구성하고 어느 순간부터 main 화면에서 로딩이 늦는것 다루는 데이터가 그렇게 많은 편이 아닌데도 chart나 render 부분이 느린 것 같다는 생각이 종종 들었다. 물론 사용하는 데 전혀 지장은 없지만 UX 적으로 조금 개선할 방향을 찾아보고 싶었다. 가장 먼저 해본 것은, React Profiler를 사용해 확인하는 것이었다.  하지만 프로파일러에서는 계속 LOLGameElement 가 느린 것 같아!! 라고 이야기하고 있었다. 사실 살펴보면 시간 단위가 문제가 될 만큼 느리지 않았다. 즉 다른 곳이 느리거나, 놓치고 있는 게 있다는 것일 것이라는 가설을 세우게 되었다. 가장 느린 구간이 70ms라니, 이는 화면에 보이는 것보다 느린 것이 아니다. 또한 얻는 정보가 한정되어있다는 생각이 많이 들었다. (이는 내 react profiler 사용이 서툴러서 그런 것 일수도 있다.) 다른 방법을 취해보기로 했다. chrome://tracing에 들어가서 전체 렌더 시간에 일어나는 일들을 Web Developer Mode로 트레이싱 하였다. 웹 개발자 모드로 한 이유는 그 정보로도 충분할 가능성이 높기 때문이다. 만약 필요해서 더 깊이 들어가야 한다면 Chromium flag를 enable 한 뒤 빌드하여 전체모드 트레이싱 하면 skia 렌더 커멘드 (네모 그리기가 매우 많다.) 단위까지 조사할 수 있다 트레이싱 도구를 사용한 이유는 다음과 같다.   어떤 렌더스테이지 에서 시간을 쓰고 있는지 (ex, composition, layout, javascript execution, style compute recursion … )  디버깅에는 가능성을 최대한 열어두고 소거하는 것을 좋아한다.  단계적인 접근 방법  만약 필요하면 C++ 네이티브 코드를 바로 볼 수 있게 제공받는다. 일단 한눈에 들어온 정보는 v8이 가져가는 시간이 정말 많다는 점이었다. 이 말은  javascript execution 쪽에서 느려짐을 의미한다. 여기서 다른 렌더 스테이지에서 느려지지 않는 것을 확인할 수 있었다. 이제 javascript execution을 추적하기 위해 insepcator를 이용하여 Performance 체크를 해보기로 했다.  가장 느려지는 구간은 3가지 정도인 것 같고, 공통점을 찾아낼 수 있었다.  apexchart 쪽에서 이러한 이벤트들이 모이고 모여 엄청 긴 시간을 가져가게 된 것이다. 여기서 잠정적인 결론을 내릴 수 있었다. Apexchart를 제거하거나 optimize 하면 이 느려지는 것이 해결 될 것 최적화를 위해 관련 정보를 찾아보고 문서를 봐봤지만, Apexchart의 고질적인 문제인 것 같다는 생각이 든다. 일단 꽤 자주 퍼포먼스이야기가 (i.e. github issue) 보였다. 또한 내가 apexchart를 잘못 사용한 것인가? 라는 의문을 가지고 공식 홈페이지의 live demo에 가서 퍼포먼스 체크를 진행했다.  공식 홈페이지의 Demo에서 데이터가 그리 많지 않음에도 꽤 많은 시간을 apexchart가 가져간다. 아마도 고질적인 문제가 아닐까 조심스럽게 추측하면서, apexchart를 대체할 방법을 생각해 보면 좋을 것 같다는 생각이 들었다. ","categories": ["development"],
        "tags": ["Chrome","Web","Javascript","Optimization","Debugging"],
        "url": "https://devsdk.github.io/ko/development/2021/03/06/ChromeInspectorPerformnace.html"
      },{
        "title": "React 파헤치기, 리액트가 동작하는 방법 (overview)",
        "excerpt":"Motivation Chromium에서 활동하면서 웹브라우져가 어떻게 동작하는지는 어느 정도 (완벽할 순 없다고 생각한다.. 너무 거대하다.)알고 있다. 그리고 리액트를 사용하는 방법을 알고 있다. 그러나 React-DOM과 내부 사항들에 대해서는 너무 추상적으로 알고있거나 모른다고 생각한다. 그래서 리액트와 브라우져 사이의 블랙박스가 너무 궁금하여 몇몇 가지의 문서와 react 소스코드를 뒤졌던 결과 어느정도 오버뷰가 나올 것 같아서 블로그에 정리하도록 한다. 하지만 아직 완전히 모든 소스코드를 본 것은 아니며, 생략되거나, 틀릴 수도 있는 내용이다. 언제든지 피드백을 받는다면 반영하도록 하겠다.  이 글을 쓰기 시작한 큰 이유다. 중간에 블랙박스가 너무 많아 실제로 어떻게 동작하는지 그리고 내가 더 생각해 볼 수 있는 다른 방향은 없는지 알기가 어려웠다. 덧붙이자면 말 그대로 마법상자 가 있어서 이를 화면에 그려주고 상태를 변경시키는 작업을 하는 느낌을 받았다. 지금부터 그 마법상자를 열어보도록 한다. Overview  글 내용이 뒤죽박죽이라, 아래의 내용을 바탕으로 위의 이미지를 정리하면 다음과 같다. 콜백에 의해 fiber 스케쥴러가 업데이트되고, 그 스케쥴러는 fiber들의 테스크를 실행하여 산출물인 업데이트 트리(WorkInProgress or Finished)를 Commit을 통해 dom에 반영한다. Detail React는 다음과 같은 JSX 문법을 통해 “선언적” 인 구현을 권장한다. (리엑트 공식 문서) 리액트를 처음 썼을때 가장 놀랐던 부분이기도 하다. &lt;MyButton color=\"blue\" shadowSize={2}&gt;  Click Me&lt;/MyButton&gt;공식문서에서도 설명하듯이, 이는 컴파일러에 의해 (babel-loader?) 다음과 같이 코드로 변경된다. React.createElement(  MyButton,  {color: 'blue', shadowSize: 2},  'Click Me')이 함수를 거치면서 아래의 계층을 가진 object 형식으로 반환이 된다. DOM과 유사하게 children이 있고 여러 가지 정보들을 담고 있다. (위 소스코드와 아래의 결과와는 다르다. 위는 공식문서에서 가져왔다.)  이제 우리는 위 내용을 ReactDOM.render를 통해 react-dom에 전달한다. react-dom은 위 정보를 fiber 라는 형태로 관리한다. Fiber는 react의 element는 1대1로 대응되면서 여러 내부 정보를 가지고 있는 구조이며 react의 작업의 단위가 되기도 하고, 자체적인 스택프레임을 가지는 일의 주체라고 한다. reconciliation 작업에 사용된다. (fiber는 react-reconciler 패키지에서 관리한다.) 내부적인 reconciliation 알고리즘은 O(n)의 휴리스틱 한 알고리즘이라고 한다. 공식문서에서는 개발자가 key를 줌으로써 알고리즘에 힌트를 줄 수 있다는 중요한 내용이 담겨있다. 그렇다면 fiber는 어떤 역할을 할까? 너무 필드가 많아서 봤던 article의 내용 중 일부를 빌리자면 이렇게 생겼다. {    stateNode: new App,    type: App,    alternate: null,    chiled:null,    key: null,    updateQueue: null,    memoizedState: {},    pendingProps: {},    memoizedProps: {},    tag: 0,    effectTag: 0,    nextEffect: null     ...}Tree 형태로 내용을 기반으로 순회하면서 WorkInProgress 트리를 만들게 된다. 그리고 WorkInProgress는 이후 화면으로 반영될 트리를 의미한다. 여기서 자주 보던 녀석들이 있는데 React.memo에 의해 property를 기록할 때 실제로 반영되는 필드인 memoizedProps와, 공식문서에서도 설명하던 key 필드이다. 이 필드는 reconciliation 작업에서 휴리스틱한 탐색에 주요 factor로 사용된다. 또한, 자체적인 스택프레임을 가지고 있다는 부분이 정말 재밌는데, 이벤트루프의 동작 방식 에 따르면 js execution이 길어지면 다음 태스크가 계속 기다려야 하므로 사용자경험이 안 좋아(애니메이션이 끊긴다거나, 터치가 씹힌다거나 등) 질 수 있는 것을 방지하기 위해 도입된 방식이다. fiber한테는 자체적인 실행 스택(work queue로 관리되는 듯해 보인다)을 가지고 자체적인 priority 기반 scheduler를 이용하여 태스크를 쪼개서 관리하면서 Message Queue가 다른 이벤트를 처리할 수 있도록 하여 Message Queue가 다른 task를 실행할 수 있도록 해주는 것 같다. 여기서 스케쥴러는 requestIdleCallback (requestAnimationframe?) API에 의해 호출된다. 이제 react-dom의 마지막 산출 단계에서는 render 페이즈와 commit 페이즈로 나뉘게 된다. 렌더페이즈는 위에서 서술했듯이 current 트리에서 WorkInPregress를 생성하는 (변경사항들을 찾아서 렌더링할 재료를 만드는) 단계라면 commit 페이즈는 말 그대로 화면에 그리도록 제출하는 단계이다. 여기서 didComponentMount 와 같은 lifecycle 함수들이 호출된다. (렌더 페이즈에서 호출되든 lifecycle 함수들은 UNSAFE_ 태그를 달고 있다고 한다.) 실제로 react 소스코드에서 commitUpdate, commitPlacement 등등을 통해 dom에 반영하는 것을 찾아볼 수 있다. 내부적으론 insertBefore 와 같은 함수를 호출하는 것으로 보인다. 위 내용은 글 초반에 말했듯이, 소스코드레벨에서 완전한 이해를 바탕으로 쓴 글이 아니다. 몇몇 가지의 글을 보고, 소스를 뒤적이다가 오버뷰를 만들면 좋을 것 같다는 생각에 작성했다. refs https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react https://github.com/acdlite/react-fiber-architecture http://bit.ly/lifeofapixel ","categories": ["development"],
        "tags": ["React","Web","React-DOM"],
        "url": "https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview.html"
      },{
        "title": "Reflow, Repaint Chromium 입장에서 살펴보기 (왜 transform은 빠를까?)",
        "excerpt":"Overview Reflow와 Repaint에 대해서 면접 단골 질문이라고 해서 조금 깊이 살펴보도록 한다.최적화와 관련된 이야기며, Message Queue (event loop)에 대한 이해가 필요하다. 그 내용은 여기서 볼 수 있다. 요약하자면, 만약 js 태스크와 같은 작업이 message queue에서 선점되어 animation frame이 늦어지는 경우 사용자에게 애니메이션이 끊기는 등의 경험을 줄 수 있다. 이런 것을 피하고 최적화할 수 있는 방법에 대해 알아본다. Table of contents   Reflow, Repaint, Layout, Paint, Composite  CSS Animation  왜 transform을 이용하면 빠를까?  tracing으로 알아보는 실제 layout, paint1. Reflow, Repaint, Layout, Paint, Composite 이 글에서 Reflow와 Repaint는 Layout과 Paint와 대응된다. Reflow와 Repaint는 firefox의 “Gecko” 진영에서 주로 사용하고, layout과 paint는 safari의 webkit과 chromium의 blink 진영에서 사용한다. 혼동을 피하고자 layout과 paint로 설명하도록 한다. Layout은 무엇일까? 웹브라우져에는 사실 DOM Tree 말고 렌더 스테이지에서 중요한 역할을 하는 트리가 하나 더 있다. 화면에 실제로 그리기 위해 박스모델과 좌표 계산이 끝난 상태인 Layout Tree라는 것을 관리한다. 이는 DOM Tree와 대응되지 않으며, display : none인 경우에는 아예 Layout Tree에 제외되기도 한다. 이러한 내용이 궁금하다면 여기를 살펴보면 좋을 것 같다. layout 단계 혹은 reflow는 이 트리를 전체 혹은 일부를 새로 구성하는 것을 의미한다. layout이 발생한다는 경우에 대해서는 이곳에서 리스트업을 하지만 브라우져 레벨에서 “항상” layout이 발생하는 것은 아니다. 예로 CSS Animation을 들 수 있다. Paint는 무엇일까? 위에서 만든 LayoutTree를 순회하며 Paint Command를 만들고 SKIA 레스터라이저한테 전달하는 단계이다.  이를  추상화하고 줄여서 설명하면 Layout Tree를 화면에 그리는 단계라고 이해해도 좋을 것 같다. 여기서 layout 트리에 대응되는 computed style에서 color와 같은 값을 가져와서 화면을 그리게 된다. 이 단계 또한 매우 방대하며, 관심 있다면 이 문서를 보도록 하자. Composite? Composite은 각각의 분리 가능한 레이어를 분리해서 처리한 뒤 합성하는 것이다. 거시적인 관점에서 Composite는 Main Thread (Message Queue)에서 벗어나서 다른 Thread Flow를 가지고 화면을 업데이트 할 수 있다. 즉 비동기적으로 실행된 후 기존 레이어에 합성된다. 주로 animation과 scroll 등등에서 활용되며, 다른 Thread Flow를 가지기 때문에 main thread에서 block이 일어나도 composite만 사용하는 애니메이션은 계속 재생될 수 있다. Composition에 대해서는 이곳에 정리를 해두었다. Composition example from Life of Pixels 2. CSS Animation CSS Animation은 공짜가 아니며 브라우져의 리소스를 사용한다. https://csstriggers.com/ 위 사이트는 CSS Animation이 렌더 스테이지에서 어떤 단계를 trigger 하는지 보여준다. 여기서 Layout &gt; Paint &gt; Composite 순으로 cost가 높으며 composite만 있다면 Message Queue와 무관하게 동작하므로 매우 좋은 애니메이션 타겟이 될 수 있다.   width의 cost는 Layout, Paint, Composite를 전부 사용한다. 따라서 꽤 높은 비용이라고 할 수 있다.  background-color는 paint, composite를 사용한다. 3. 왜 transform을 이용하면 빠를까?  우리는 같은 역할을 하는 두 가지의 코드를 만들 수 있다. &lt;style&gt;    .b { height: 50px; width: 50px; background-color: blue;}&lt;/style&gt;&lt;div class=\"b\" style=\"transform: translateX(200px)\"&gt;&lt;/div&gt;&lt;div class=\"b\" style=\"position:relative;left:200px\"&gt;&lt;/div&gt; 위 코드는 완전히 화면에 동일한 결과를 내놓는다. 하지만 내부적으로 다르게 동작한다. 컴퓨터는 그래픽을  matrix의 곱으로 표현한다. (OpenGL examples) 이는 OpenGL, DirectX 등에 반드시 사용되며 GPU는 이런 연산을 빠르게 하기 위해 설계되었다. transform을 사용한 예시중 첫번째 div는 최종 composite에서 transformation matrix를 통해 렌더링 되기 전 composite thread에서 GPU의 도움을 받아 계산된다.  아주 빠른 연산이 비동기적으로 일어나 매우 빠른 속도를 보여준다.  어떤 연산이 일어나는지는 표준을 참고하자. 심지어 Main Thread가 다른 태스크에 의해 block 되어도 재생된다. left를 사용한 아래 예시는 layout→composite.assign-&gt;paint의 절차를 모두 밟게 된다. 즉 애니메이션으로 사용되기엔 꽤 비싼 cost를 가지고 있다는 소리다.(Paint → Composite 는 현재 Chromium의 주요 프로젝트중 하나이다. CAP (Composition After Paiting)이라고 불린다.)  여기서 즐거운 결론을 낼 수 있다. animation에서 만약 같은 결과를 내는 코드라면 composite만 사용하는 애니메이션 (i.e.transform)을 애용하자. 4. Tracing으로 알아보는 실제 layout, paint 아래부터의 내용은 chromium/chrome의 동작 구조를 직접 살펴보며 위에서 이야기한 내용을 눈으로 봐볼 것이다. 아래는 width를 이용한 animation을 tracing 한 것이다.  CrRendererMain에 바코드처럼 빼곡하게 있는 것들이 바로 layout→paint 그리고 composite를 트리거 하는 단계이다. 저 바코드의 줄 하나를 확대하면 다음과 같다.  트레이스가 기록된 저 상자는 c++ 구현과 1대1로 대응되며, 필요하다면 소스코드를 볼 수 있다. 이 내용을 보면 LocalFrameView::UpdateStyleAndLayoutIfNeededRecursive()이 호출됨으로써 layout과 paint가 끊임없이 일어난다는 것을 알 수 있다. 만약 DOM Tree의 깊이가 깊어진다면 그만큼의 recursion 호출이 발생한다. 그렇다면 반대로 transform을 사용한 경우는 어떤 트레이싱을 볼 수 있을까?  앞에 빼곡하게 있는 것은 마우스 때문에 발생한 animation이고 실제로 trigger 돼서 화면에 보인 것은 갑자기 빈 공간이 생기는 부분부터 이다. 여기서 compositor는 전달받은 역할을 비동기적으로 실행하는 것을 볼 수 있다. 이런 이유 때문에 composite만 사용하는 애니메이션은 alert와 같이 main thread가 block 된 상황에서도 정상적으로 렌더 수행이 진행된다. 오타/질문/틀린 내용이 있다면 언제든지 피드백 바란다. :) ","categories": ["development"],
        "tags": ["Web","HTML","CSS","Optimization"],
        "url": "https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint.html"
      },{
        "title": "Chrome 90 beta is coming, 어떤 기능이 들어올까?",
        "excerpt":"Blink Dev-Group에 있으면서, 새로운 Chrome 버전 M90의 beta가 3월 11일에 나온다고 한다. Chromium의 어떤 새로운 기능들이 Chrome 에 도입될 수 있을지 알아보도록 한다. 이 내용은 What’s Shipping 시트를 참고하였다. 각각 기능은 한 줄에서 두 줄 정도로 이해한 만큼 쓰도록 한다. 몇 가지는 생략할 수도 있다. 특히 인상 깊은 건 우선순위 기반 스케쥴러의 도입이 아닐까 싶다.       Seeking past the end of a file in the File System Access API     파일의 끝을 지나서 write를 할 때 reject 대신, 파일을  0x00(NUL)값과 함께 확장한다.         StaticRange constructor     Highlight API Explained를 위한 feature라는데, 아직 잘 모르겠다 WHATWG 스팩에도 constructor만 명시되어 있다.         Subresource loading with Web Bundles     다수의 리소스를(e.g. Web Bundles) 번들로 묶을 수 있는 포멧을 사용하여 많은 수의 리소스들을 효율적으로 로드할 수 있는 방향을 제공한다.         Support specifying width/height on &lt;source&gt; elements for &lt;picture&gt;     &lt;picture&gt;에 대하여 &lt;source&gt;를 이용해 width와 height를 제공함으로써 image의 화면 비율을 계산할 수 있게 해준다.       &lt;picture&gt;      &lt;source srcset=\"image.jpg\" width=\"640\" height=\"480\"&gt;      &lt;img style=\"width: 100%; height: auto;\"&gt;   &lt;/picture&gt;            URL protocol setter: New restrictions for file URLs     파일에 혹은 파일로 부터 URL이 변경될 때 발생하는 edge case를 바로잡음.         Use :focus-visible in the default UA style sheet     Chromium의 기본 UA스타일을 포커스 인디케이터를 위해 :focus pseudo-class를 사용하는 것 대신 :focus-visible를 사용함         WebAssembly Exception Handling     웹 어셈블리의 exception handling 도입.         WebAudio: OscillatorOptions.periodicWave is not nullable     더이상 periodicWave의 맴버 OscillatorOptions을 null로 설정할 수 없음         WebXR AR Lighting Estimation     사이트가 WebXr 세션 내에서 environmental lighting의 근사치를 쿼리할 수 있다.         WebXR Depth API     WebXRDevice의 Deapth Buffer로 접근할 수 있게 해준다.         getCurrentBrowsingContextMedia()     navigator.mediaDevices.getCurrentBrowsingContextMedia() 이 api를 통해 현재 탭에서의 MedaiStream을 캡처할 수 있다.         Main thread Scheduling APIs: Prioritized scheduler.postTask     개발자가 브라우져의 네이티브 스케쥴러를 통해 3개의 우선순위(user-blocking, user-visible, and background)를 가지는 테스크(javscript callbak)를 스케줄 할 수있게 해준다. (성능과 관련 있음)         MediaStreamTrack Insertable Streams (a.k.a. Breakout Box)     카메라의 출력, 마이크, 화면 캡처 또는 코덱의 디코더 부분과 코덱의 디코더 입력과 같은 MeadiaStreamTracks에서 전달하는 raw 미디어를 조작하기 위한 API         Protect application/x-protobuffer via Cross-Origin-Read-Blocking     speculative execution 공격으로부터 ‘application/x-protobuffer’을 지킨다.         Read Chrome device attributes     Device Web API의 일부분인 Device attribute를 query 할 수 있게 한다.         Relative indexing method for Array, String, and TypedArrays     at() 함수 추가.       let arr = [1,2,3,4];  arr.at(-1); // Returns 4            AbstractRange superclass     StaticRange와 Range를 추상화 함         Add support for CSS properties “overflow: clip” and “overflow-clip-margin”     https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#values         AV1 Encoder     Chrome desktop을 위한 AV1 인코더 도입     Clipboard: read-only files support  CORS-RFC1918: CORS restrictions on internet-to-intranet connections.      CSS aspect-ratio interpolation     비율에 대한 보간 내용인 것 같다.         Custom state pseudo class     Custom Element의 state를  :state() psuedo class에서 접근 할 수 있다.   ","categories": ["development"],
        "tags": ["Chromium","Chrome"],
        "url": "https://devsdk.github.io/ko/development/2021/03/08/chrome90.html"
      },{
        "title": "CSS @counter-style",
        "excerpt":"오늘 아침 Blink-Dev Group에서 I2S를 보고 재밌는 CSS Feature가 Ship되는걸 보아서 간단히 메모한다.  꾸준히 내가 진행중인 CSS Feature를 리뷰해주고 계신 Xiaocheng이 ship 한 기능이다. Firefox에서는 2014년부터 이미 지원되는 기능이였던 것 같다. https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style 표준에 따르면 아주다양한 방식으로 사용될 수 있을 것 같다. @counter-style footnote {  system: symbolic;  symbols: '*' ⁑ † ‡;  suffix: \" \";}It will then produce lists that look like:*   One⁑   Two†   Three‡   Four**  Five⁑⁑  Six 근 시일내 당장 쓸 수는 없고, M91버전부터 사용할 수 있을 것 같다. ","categories": ["development"],
        "tags": ["Chromium","Chrome","CSS"],
        "url": "https://devsdk.github.io/ko/development/2021/03/11/CSSCounterStyle.html"
      },{
        "title": "Chromium 새로 개발되는 DOM API Seamless Transitions",
        "excerpt":"오랜만에 patch들을 pull 받고 빌드하는 시간 동안 Chromium에서 SPA(Single Page App)를 위한 API가 어떤 것들이 있을까 라는 생각으로 feature들을 살펴보던 도중 흥미로운 기능이 현재 막 개발되고 있어서 글을 쓴다. 2021.03.11 기준으로 아직 한창 개발되고 있는 feature이다. Android Webview와 깊은 연관이 있는 만큼 나중에 완성되면 Google IO 같은 데서 한번 말하지 않을까 라는 생각이 든다. (아닐 수도 있다. ㅎㅎ..) 아직은 비표준인 것 같다. 아마 표준이 되지 않을까 생각된다. WICS Proposal runtime flag 에 따르면 프로토타입은 나온것 같으니 한번 사용해보도록 한다.  TL;TR function changeBodyBackground() {  document.body.style = \"background: blue\";}function handleTransition() {  document.documentTransition.prepare({    rootTransition: \"reveal-left\",    duration: 300  }).then(() =&gt; {    changeBodyBackground();    document.documentTransition.start().then(() =&gt; console.log(\"transition finished\"));  });}트렌지션을 시도하기 전 그 화면을 texure로 렌더링해놓는다. 이 작업을 prepare라고 한다. 이 작업은 비동기적으로 실행되며 GPU 자원을 사용할 수 있다. 그런 뒤 Transition을 하면 렌더링해놓은 텍스쳐 뒤로/앞으로 DOM을 렌더링한다. 그런 뒤 요청한 방식대로 그 이미지를 제거한다. (like reveal-right) 문서의 motivation쪽을 보니 transition에 부족한점이 많아서 SPA를 혹은 MPA를 위해 시작했다고 한다. Example 개발하고 계신 분의 example을 실행해본다. 실행조건은 pull 받은 시점의 HEAD에서 빌드한 content_shell이다. 실행 커멘드는 ./content_shell --enable-features=DocumentTransition test.html 이다. 아무래도 Under Construction이라서 직접 실행해 보니 빌드 환경이 동일하지 않은 것 인지 크레시가 난다.  explode와 implode는 그래도 잘 동작한다.  이걸 만들고 계신 분이 데모로 올리셨던 영상을 따왔다.  디테일은 아래 문서 및 모노레일에서 볼 수 있다. 다시 한 번 말하지만, 아직 개발이 진행 중인 기능이다. https://crbug.com/1150461 https://github.com/vmpstr/shared-element-transitions https://docs.google.com/document/d/1UmAL_w5oeoFxrMWiw75ScJDQqYd_a20bOEWfbKhhPi8 ","categories": ["development"],
        "tags": ["Chromium","Chrome","CSS"],
        "url": "https://devsdk.github.io/ko/development/2021/03/11/ChromiumSeamlessTransitions.html"
      },{
        "title": "double 형의 \"계산 가능한 범위\" 그리고 chromium의 maximum angle",
        "excerpt":"Chromium, CSS Math Function 에 &lt;angle&gt;의 무한 값을 도입하면서 삽질한 기록이다. 삽질을 하게 된 계기는 표현한 최댓값이 “계산 가능한” 값인 줄 알았던 것이다. 또한 현재 코드리뷰는 진행중이기 때문에 값은 얼마든지 변할 수 있다. 하지만 매커니즘이 변하진 않을 것 같다. Review: https://chromium-review.googlesource.com/c/chromium/src/+/2774851 2867080569122160은 -방향으로 오차를 줄이는 방식으로 다시 계산된 값이다.  3월 24일 오전, 2개의 LGTM을 받아 머지시켰다. &lt;angle&gt;은 각도를 나타내는 CSS 값 타입이다. 새로운 CSS-Values-4 표준에 의하면 &lt;angle&gt;의 최댓값은 표현가능한 범위에서 360값의 배수여야 한다. 360의 배수이면서 특정한 값보다 작으면서 가장 가까운 값을 구하는 방법이 무엇일까? 바로 다음과 같은 식을 이용하면 된다. \\[result = target - target \\ mod \\  360\\]하지만 double의 최댓값에선 다음과 같은 문제가 발생한다.  이 결과는 우리가 예상한 동작과는 거리가 있어보인다. 실제로, 1.79769e+308 === 1.79769e+308 - 100 은 true 를 내놓는다. 왜 이런 걸까? 컴퓨터 공학 학부, 혹은 컴퓨터를 처음 입문하게 되면 컴퓨터가 값을 표현하는 자료형의 범위를 배우게 된다. 그중에서 배정밀도 double은 8바이트로써, 범위는 다음과 같다. ±1.7 ×10^-307 이상 ± 3.4 × 10^308 이하 IEEE 754에 따르면 배정밀도는 다음과 같은 비트열을 가지게 된다. 위 값은 exponent를 포함한 아래 비트열의 모든 비트를 사용했을 때 나올 수 있는 최댓값이다.  하지만 실제로 계산할 수 있는 범위는 훨씬 작아지는데, 그 이유는 부동소수점에서 exponent 값을 넘어가게 되면 2의 배수로 증가하기 때문이다. 즉, 일반적으로 우리가 기대하는 연산(사칙연산, 삼각함수 등)이 불가능하다. Double-precision floating-point format 의 Precision limitations on integer values 에 따르면, 정수에 대응될 수 있는 숫자의 표현 범위는 2^53 ~ -2^53인, 9007199254740992 ~ -9007199254740992이다. 이 아래부터는 chromium에 대한 이야기다. chromium에서 &lt;angle&gt;의 무한 값은 2867080569122160 로 정하게 되었는데 그 이유는 다음과 같다. Chromium에서 “각”은 결국 라디안 이라는 단위로 계산이 된다. 이는 rotation matrix에서 삼각함수를 사용할 때 활용된다. 이와 반대로 CSS Math Function은 항상 degree로 반환한다. 즉, degree 값을 radian으로 변환시켜야 transform matrix로 사용할 수 있다는 이야기가 된다. 이 것은 deg2rad function 함수를 통해 degree를 radian으로 변환하게 되는데 이 식은 다음과 같다. \\[rad = \\frac{degree *\\pi}{180}\\]여기서 문제는 저 최댓값인 9007199254740992에 원주율을 곱하게 되면 우리가 예상하지 못한 동작을 하게 된다는것 이다. 따라서 다음과 같은 식으로 PI를 곱했을 때 표현 가능한 범위를 넘어가지 않도록 해주었다. \\[base = \\frac{9007199254740992}{\\pi}\\]\\[degree = base - base \\ mod \\ 360\\]여기서 sin함수를 dgree에 사용했을 때 0.01의 오차를 가지게 되었다. 하지만 이는 충분하지 않다고 생각하여 다음과 같은 스크립트로 0.00001의 오차를 가진 값을 찾아냈다. //To find nearest value using trigonometric functionswhile((Math.abs(Math.sin(degree * Math.PI / 180))) &gt; 0.00001 ||        !(Math.sin(degree * Math.PI / 180) &gt;= 0 &amp;&amp; Math.cos(degree * Math.PI / 180) &gt; 0 )) {    degree -=1;}console.log(degree)이렇게 해서 나온 결과가 2867080569122160 이다. 따라서 값(-2867080569122160 ~ 2867080569122160)을 &lt;angle&gt;의 clamp값으로 선정하였다. ","categories": ["development"],
        "tags": ["Chromium","Chrome","ieee 754"],
        "url": "https://devsdk.github.io/ko/development/2021/03/22/double-calcable.html"
      },{
        "title": "\\[CSS-Values-4] 삼각함수 구현 준비",
        "excerpt":"Chromium에 CSS에 대하여 Infinity 와 NaN을 구현하는 프로젝트가 거의 끝나가고 있다. 몇 가지의 이슈를 해결하면 아마 ship 할 수 있을 것 같다. 이 기능을 구현하며 스팩을 자주 보게 되었는데, 익숙해 진 것도 있고, 눈에 띄는 기능이 보여서 다음 구현 목표를 css-values-4 스팩에서 찾게 되었다. 새로운 w3c/csswg의 표준인 CSS-values-4를 보면, 삼각함수에 대한 내용이 담겨있다.  더 빠르고, 안정적으로 CSS에서 삼각함수를 사용할 수 있게 될 것이라고 기대하고 있다. 아마도, hue 컬러 공간 및 삼각함수 관련된 스타일이 필요한 부분에서 유용하게 쓰일 수 있을 것 이라고 생각한다. 첫번째로 type=feature로 크로미움 이슈 모노레일 crbug.com 에 올려두었다.  아마 이 기능도 무한과 NaN 기능을 구현할 때와 마찬가지로 Intent to Prototype과 Design Docs, Chromium Platform Status 등에 등록이 필요할 것 같다. 구글 크롬팀과 이야기하면서 알게 되었는데 구글 내부적으로는 이 기능을 2분기 계획으로 잡으려고 한다고 했다. 다만 요즘 이래저래 바빠서 2분기까지 완전히 완성하긴 어려울 것 같고, 프로토타이핑 및 문서화 정도까진 가능할 것 같다고 이야기하긴 했는데 얼른 바쁜 게 끝나면 좋겠다. Feature 구현을 시작하기 전에 간단하게 블로그에 정리해 보았다. ","categories": ["development"],
        "tags": ["Chromium","Chrome","CSS","Feature","css-values-4"],
        "url": "https://devsdk.github.io/ko/development/2021/03/29/css-trig-func-begin.html"
      },{
        "title": "Chromium Composition과 Layer",
        "excerpt":"웹 브라우져의 화면은 다양한 스테이지를 거쳐 화면에 나오게 된다. 다음은 chromium의 렌더링 과정을 도식화한 것이다.  이번 글에서 다루고자 하는 내용은 빨간색으로 네모 친 Composition(합성)이다. 저번에 Reflow와 Repaint라는 내용을 다루면서 짧게 이야기를 한 적 있다. 이번 글에는 조금 더 구체적으로 이야기해 보고자 한다. Compositing? 한국어로 합성이라고 한다. 실제로 브라우져는 렌더링을 최대한 최적화 하기 위한 많은 노력을 하고 있는데 여기에 Composition이 포함된다. 설명하기 이전에 용어를 조금 정리한다. 화면에 보이는 공간을 Viewport라고 부른다. 그리고 특정한 정보를 화면의 픽셀로 만드는 과정을 레스터라이즈 라고 한다. 만약 Compositing이 없었다면 렌더링은 어땠을까? 아래는 composite 없이 single layer로 렌더링이 되었을 때 벌어질 수 있는 것을 그림으로 나타낸 것이다.  이 이미지는 Chromium의 가장 첫 번째 버전에서 동작하는 방식이었다. 스크롤과 같은 행위로 뷰포트를 넘어가는 경우 빈 공간을 다시 레스터라이즈 하는 과정이 있었다. 여기서 문제는 다른 요소가 변경(위치, 색상 등등)된다면 그 해당하는 공간을 다시 계산해야 한다는 점이었다. 현대의 브라우져는 이러한 문제를 세련되게 해결하고 있다. 다음 그림은 layered composition을 설명하는 그림이다.  Composition은 분리 가능한 레이어를 분리하고 미리 레스터라이즈를 한 뒤, 그 레이어를 움직이거나 Viewport를 움직이는 방식이다. 특정한 레이어의 레스터가 변경되고, 위치가 변경된다고 해서 다른 레이어의 요소에 영향을 끼치진 않는다. 실제로 분리된 레이어를 살펴보자. 다음은 토이프로젝트로 만들었던 DFD의 layer이다. React-Virtualized에 의하여 실시간으로 리스트가 갱신되는 것을 볼 수 있다.  다음은 github의 layer이다. 스크롤에 의해 floating이 되는 부분이 새로운 레이어로 만들어짐을 잘 살펴보자.  이처럼 실제로 composition은 웹에서 최적화를 담당하는 큰 축중 하나로 사용되고 있다. How? 그렇다면 Layer은 어떻게 분리가 될까?  렌더러는 DOMTree에서 만들어진 LayoutTree를 이용하여 Compositing Trigger를 가진 녀석들을 layer로 분리시킬 후보로 만든다. 여기서 말하는 트리거는 다양한 이유가 될 수 있는데 대표적으로 transform 요소가 될 수 있다.  기존에는 LayerTree를 사용했던 것 같은데, v2부터는 Layer List를 사용하는 것 같다. 또한 Scrollable Area에 대해서는 아래와 같이 layer를 나뉘게 된다.  이렇게 만들어진 레이어들은 Compositing Assignment라는 단계에서 그래픽 레이어로 변환된다.  각각에 레이어에 대해 다양한 파라미터를 줄 수 있는데 이것을 property tree라고 부른다. 현재까지의 Chromium의 구현체 (Composite After Paint 이전)에는 이 프로퍼티 트리를 레이어가 가지고 있게 된다. 아마 CAP에서는 이를 분리시킬것 이라고 한다. 이렇게 만들어진 Layer과 Property Tree는 메인쓰래드에서 별도의 compositor thread로 넘기게 된다.  그 후 draw콜에 의하여 레이어가 화면에 그려지도록 렌더 커멘드를 생성하며 다음 스테이지로 넘기게 된다. refs https://developers.google.com/web/updates/2018/09/inside-browser-part3#what_is_compositing http://bit.ly/lifeofapixel https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/ ","categories": ["development"],
        "tags": ["Chromium","Chrome","Blink","Renderer"],
        "url": "https://devsdk.github.io/ko/development/2021/03/29/blink-render-composition.html"
      },]
