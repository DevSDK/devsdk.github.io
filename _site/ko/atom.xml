<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="3.9.1">Jekyll</generator><link href="https://devsdk.github.io/ko/atom.xml" rel="self" type="application/atom+xml" /><link href="https://devsdk.github.io/ko/" rel="alternate" type="text/html" hreflang="ko" /><updated>2022-12-20T13:34:36+09:00</updated><id>https://devsdk.github.io/ko/</id><title type="html">Seokho’s blog</title><subtitle>Development and Tech blog</subtitle><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><entry><title type="html">CSS 삼각 함수를 배포했다</title><link href="https://devsdk.github.io/ko/development/2022/12/20/css-trigonometric-functions.html" rel="alternate" type="text/html" title="CSS 삼각 함수를 배포했다" /><published>2022-12-20T09:00:01+09:00</published><updated>2022-12-20T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2022/12/20/css-trigonometric-functions</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2022/12/20/css-trigonometric-functions.html">&lt;p&gt;CSS 삼각 함수를 배포했다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;402&quot; alt=&quot;Screenshot 2022-12-20 at 9 08 24 AM&quot; src=&quot;https://user-images.githubusercontent.com/18409763/208580491-09ba5854-aa6a-4149-b305-b9b5b271cfae.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Feature Entry: https://chromestatus.com/feature/5165381072191488&lt;/p&gt;

&lt;p&gt;7월쯤 시작한 Chromium에 CSS에 삼각함수를 구현하는 프로젝트 “CSSTrigonometricFunctions”를 마무리했다.&lt;/p&gt;

&lt;p&gt;취미개발로 주로 일요일과 출근시간 전, 퇴근 후 작업했다.&lt;/p&gt;

&lt;p&gt;CSS 삼각함수는 다음의 함수를 구현하는 프로젝트다.&lt;/p&gt;

&lt;p&gt;MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions#trigonometric_functions&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/sin&quot;&gt;sin()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/cos&quot;&gt;cos()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/tan&quot;&gt;tan()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/asin&quot;&gt;asin()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/acos&quot;&gt;acos()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/atan&quot;&gt;atan()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수들은 &lt;a href=&quot;https://www.w3.org/TR/css-values-4/#trig-funcs&quot;&gt;css-values-4&lt;/a&gt; 스팩에 정의되어 있다.&lt;/p&gt;

&lt;p&gt;2018년에 W3C 스팩 초안이 만들어졌고, 2020년에 기능을 정의하는 삼각함수 챕터 ”11.4. Trigonometric Functions: sin(), cos(), tan(), asin(), acos(), atan(), and atan2()” 가 등장했다.&lt;/p&gt;

&lt;p&gt;올해 초 구현을 계획하다 리팩토링이 겹쳐 다른 작업들 위주로 개발하다 7월부터 실제 구현을 시작한 프로젝트로, &lt;a href=&quot;https://www.chromium.org/blink/launching-features/#implementations-of-already-defined-consensus-based-standards&quot;&gt;Chromium 정식 기능개발 과정&lt;/a&gt;인 &lt;a href=&quot;https://groups.google.com/a/chromium.org/g/blink-dev/c/-c9p-Sq_gWg/m/C9eOR3oGAgAJ&quot;&gt;Intent to prototype&lt;/a&gt;과 &lt;a href=&quot;https://groups.google.com/a/chromium.org/g/blink-dev/c/UiUVU722BbU/m/vQJy-qdpDAAJ&quot;&gt;Intent to Ship&lt;/a&gt; 그리고 3명의 커미터의 approved를 받아 stable로 전환하는 배포 CL이 머지되어 배포되었고, Chrome은 111 버전에 이 커밋이 포함되어 배포가 된다.&lt;/p&gt;

&lt;p&gt;Chrome  111 버전은 2월 9일부터 16일까지 beta를 거쳐 3월 1일부터 일반 사용자들에게 업데이트 된다.&lt;/p&gt;

&lt;p&gt;구현시 주요 내용은 삼각함수를 평가/처리하는 함수를 생성하고, 그 함수 내에서 각 함수별 처리를 추가하는 작업이 진행되었다. 삼각함수 하나당 하나의 CL(like PR)로 다뤄졌고, 관련한 WPT 테스트케이스들을 추가하게 되었다.&lt;/p&gt;

&lt;p&gt;atan2의 경우 현재 releative-length를 처리하는 것에 기술적인 이슈(특히, 파싱 타임에서 평가가 불가능해지는 점이)들이 존재해 relative 단위를 평가/처리 하지 않고, 그냥 자신의 값을 반환하게 구현했다.&lt;/p&gt;

&lt;p&gt;이는 주요 브라우저 엔진들인 webkit, gecko 도 동일하며, 관련한 이슈 이야기가 W3C/CSSWG 에서 논의되고 있다.&lt;/p&gt;

&lt;p&gt;이슈들 모아보기:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Crbug: &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=1392594&quot;&gt;https://crbug.com/1392594&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Webkit Bugzilla: &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=248513&quot;&gt;https://bugs.webkit.org/show_bug.cgi?id=248513&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Gecko Bugzilla: &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1802744&quot;&gt;https://bugzilla.mozilla.org/show_bug.cgi?id=1802744&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;W3C/CSSWG: &lt;a href=&quot;https://github.com/w3c/csswg-drafts/issues/8169&quot;&gt;https://github.com/w3c/csswg-drafts/issues/8169&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="CSS" /><category term="Feature" /><category term="css-values-4" /><summary type="html">CSS 삼각 함수를 배포했다.</summary></entry><entry><title type="html">BlinkOn15-Day1</title><link href="https://devsdk.github.io/ko/development/2021/11/20/blinkon15-day1.html" rel="alternate" type="text/html" title="BlinkOn15-Day1" /><published>2021-11-20T09:00:01+09:00</published><updated>2021-11-20T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/11/20/blinkon15-day1</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/11/20/blinkon15-day1.html">&lt;h1 id=&quot;blinkon-15-day1&quot;&gt;BlinkOn 15 Day1&lt;/h1&gt;

&lt;p&gt;블링크온 이라는 크로미움 렌더링 엔진에 대한 컨퍼런스가 이번주 목요일 금요일 새벽 한시부터 4시까지 진행이 되었었다.&lt;/p&gt;

&lt;p&gt;이번 글에서는 각 세션에 대해 간력히 나열하고 정리해보는 글 일것 같다.&lt;/p&gt;

&lt;h3 id=&quot;networking&quot;&gt;Networking&lt;/h3&gt;
&lt;p&gt;네트워킹 세션은 상당히 흥미로웠다. 네트워킹 세션 페이지에서 조인 버튼을 누르면 실제 블링크온에 참여한 사람을 렌덤하게 매치시켜준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/142717937-e37866f6-63a8-40f7-abe9-4b21a630e794.png&quot; alt=&quot;Screen Shot 2021-11-17 at 1 15 45 AM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;총 2분의 사람을 만났다.&lt;/p&gt;

&lt;p&gt;이런저런 이야기를 하며 시간을 보냈다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Lorenzo&lt;/p&gt;

    &lt;p&gt;igalia 해드쿼터에서 일하고 있는 엔지니어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Nina&lt;/p&gt;

    &lt;p&gt;구글에서 크롬 개발자로 일하고 있는 엔지니어&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대체로 individual contributor에 대해 관심이 많았던 것 같다. 개인 컨트리뷰터에 대해 항상 감사하다고 생각한다고 그들이 오픈소스 컨트리뷰터들을 어떻게 생각하는지 어떤 태도로 대하고 있는지 엿볼 수 있었다.&lt;/p&gt;

&lt;p&gt;인상적이였던 이야기중 하나는 코딩 시간은 어느정도로 잡냐고 물어보니 하루를 3단계로 나눠서 1페이즈 스팩작성 및 스팩관련 작업 2페이즈 코딩 3페이즈 코드리뷰 및 문서작성을 한다고 했다. 다만 항상 그런건 아니고 때에 따라 개발만 하거나 문서만 쓰거나 한다고…&lt;/p&gt;

&lt;p&gt;케나다 여행 가고 싶다고 하니까 나중에 놀러오라고, 학생이면 구글의 학생 인턴쉽 프로그램도 있다고 그거 통해서 와보라고 소개해줬다. ㅋㅋ&lt;/p&gt;

&lt;h2 id=&quot;day1&quot;&gt;Day1&lt;/h2&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/-P_WMKaIhfA&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;h3 id=&quot;keynote&quot;&gt;Keynote&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;블링크온 하이브리드&lt;/li&gt;
  &lt;li&gt;기여자 오버뷰
    &lt;ul&gt;
      &lt;li&gt;기업들과 그 기업들의 어떤 피쳐를 만들었는지&lt;/li&gt;
      &lt;li&gt;27%의 개인 기여자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;개발중&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Shared Element transitions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ship(배포)된 피쳐들 소개&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;accent-color&lt;/li&gt;
  &lt;li&gt;COLRv1 fonts&lt;/li&gt;
  &lt;li&gt;Composite After Paint (CAP)&lt;/li&gt;
  &lt;li&gt;Canvas Updates
    &lt;ul&gt;
      &lt;li&gt;Context Lost/Restored Events&lt;/li&gt;
      &lt;li&gt;Will Read Frequently&lt;/li&gt;
      &lt;li&gt;New Text Modifiers&lt;/li&gt;
      &lt;li&gt;Reset&lt;/li&gt;
      &lt;li&gt;RoundRect&lt;/li&gt;
      &lt;li&gt;Conic Gradient&lt;/li&gt;
      &lt;li&gt;Filters (WIP)&lt;/li&gt;
      &lt;li&gt;Performance Improe&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;WebCodecs&lt;/li&gt;
  &lt;li&gt;Developer Tools
    &lt;ul&gt;
      &lt;li&gt;Container Queries&lt;/li&gt;
      &lt;li&gt;User Flows&lt;/li&gt;
      &lt;li&gt;WebAssembly Debugging&lt;/li&gt;
      &lt;li&gt;WebSocket Throttling&lt;/li&gt;
      &lt;li&gt;Privacy Sandbox&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;BFCache Desktop&lt;/li&gt;
  &lt;li&gt;WebTransport&lt;/li&gt;
  &lt;li&gt;Web Permission Prediction&lt;/li&gt;
  &lt;li&gt;RenderingNG&lt;/li&gt;
  &lt;li&gt;V8 Optimization
    &lt;ul&gt;
      &lt;li&gt;Sparkplug&lt;/li&gt;
      &lt;li&gt;Concurrent lnlining&lt;/li&gt;
      &lt;li&gt;Fast API&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Idle detection API&lt;/li&gt;
  &lt;li&gt;AppHistory API&lt;/li&gt;
  &lt;li&gt;Reporting API&lt;/li&gt;
  &lt;li&gt;Prioritized task scheduling API&lt;/li&gt;
  &lt;li&gt;Secure Payment Configration&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lighting-talks&quot;&gt;Lighting Talks&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ozone News (18:48)
    &lt;ul&gt;
      &lt;li&gt;데스크탑에서의 추상화 레이어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Storage Partitioning the File System API (21:30)&lt;/li&gt;
  &lt;li&gt;Referrers and Redirects (24:37)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.w3.org/TR/referrer-policy/&quot;&gt;https://www.w3.org/TR/referrer-policy/&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The initial empty document (28: 04)&lt;/li&gt;
  &lt;li&gt;&amp;lt;popup&amp;gt;, &amp;lt;selectmenu&amp;gt;, Anchor Positioning
    &lt;ul&gt;
      &lt;li&gt;커스텀 가능한 select와 팝업에 대한 이야기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Secure Payment Confirmation (34:50)&lt;/li&gt;
  &lt;li&gt;Web Authentication API (37:52)&lt;/li&gt;
  &lt;li&gt;Security key Sign-In data Management (40:30)&lt;/li&gt;
  &lt;li&gt;Accessible name calculation (43:53)&lt;/li&gt;
  &lt;li&gt;Federated Credentials Management (46:58)&lt;/li&gt;
  &lt;li&gt;Animation Smoothness Metric (49:54)&lt;/li&gt;
  &lt;li&gt;Intro to Tracing (52:47)&lt;/li&gt;
  &lt;li&gt;Chrome 100 (55:30) - UA에 Chrome/100.0.0 이 된다면?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sessions&quot;&gt;Sessions&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;COLRv1 Color Vector Fonts by Dominic Rottsches
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/BmqYm5Wwz8M&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

    &lt;p&gt;컬러폰트는 이모지, 타이포 등등에서 다양한곳에서 사용됨&lt;/p&gt;

    &lt;p&gt;COLRv1 문자는 페인트 연산의 방향이 있는 비순환 그래프다&lt;/p&gt;

    &lt;p&gt;COLRv1 문자를 그리는 것은 위 그래프를 순회하면서 그리는것&lt;/p&gt;

    &lt;p&gt;SVG와 COLRv1 연관&lt;/p&gt;

    &lt;p&gt;svg → flattened SVG → COLRv1 Font Glyph&lt;/p&gt;

    &lt;p&gt;폰트 사이즈가 비트맵보다 메모리를 4~5배정도 적게 먹는다. 심지어 벡터 타입이라 스케일도 좋다.&lt;/p&gt;

    &lt;p&gt;크롬 카네리 (아마 97+ 버전 이상?)에서 #colr-v1-fonts 로 enable 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;:has() prototyping status by Byungwoo Lee
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/bEcNxI0MYzk&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

    &lt;p&gt;pseudo 클레스는 css의 중요한 로지컬 셀렉터다&lt;/p&gt;

    &lt;p&gt;has() 를 통해 선택자로 선택할 수 있는 엘리먼트를 로지컬하게 정할 수 있다&lt;/p&gt;

    &lt;p&gt;.a: has (.b) 와 같이 subject 엘리먼트를 터미널 엘리먼트가 아닌 엘리먼트를 선택할 수 있다.&lt;/p&gt;

    &lt;p&gt;.a:has(.b:hover) 와 같이도 사용할 수도 있다. 유용할 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MathML by Frederic&lt;/p&gt;

    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/H-7kG2lEKQ8&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

    &lt;p&gt;수식 렌더링에 대한 이야기인듯, DOM처럼 다룰 수 있고 스타일이 가능해지지 않을까..?&lt;/p&gt;

    &lt;p&gt;아직 잘 모르겠다..&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Armv9 Security Update
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/0nxzSYz99pk&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

    &lt;p&gt;로우레벨 보안관련 업데이트가 많이 있던것 같은데 나중에 한번 보면 좋을 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Rendering 2022 Plans
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/NGRr_2afWnU&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

    &lt;p&gt;렌더러 엎고 하위호환 유지하면서 새로운 렌더러로 점진적으로 개선하는데 6~7년 소비했다. (CAP, LayoutNG 등)&lt;/p&gt;

    &lt;p&gt;Rendering NG 프로젝트들&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Composition After Paint&lt;/li&gt;
      &lt;li&gt;Next Generation Layout (Layout NG)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;렌더링 스테이지는 함수형이여야 한다고 한다. (인상적임)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;defined inputs&lt;/li&gt;
      &lt;li&gt;defined outputs&lt;/li&gt;
      &lt;li&gt;deterministic behavior&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;렌더 스테이지 아웃풋은 immutable 해야한다.&lt;/p&gt;

    &lt;p&gt;50%의 성능향상! == 베터리 소비량 적어짐&lt;/p&gt;

    &lt;p&gt;근시일내에 할 것들은 컴포지션 관련된 것들일것이라고 한다. 컴포지션 gif elzhemfkejsrk…&lt;/p&gt;

    &lt;p&gt;Threaded text shaping, Non-Blocking Commit, Off Main Thread Compositing&lt;/p&gt;

    &lt;p&gt;이야기만 들어도 속도가 많이 향상될 프로젝트들 인듯하다.&lt;/p&gt;

    &lt;p&gt;장기적으로는&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Off Main Thread Paint&lt;/li&gt;
      &lt;li&gt;Off Main Thread Pre-Paint&lt;/li&gt;
      &lt;li&gt;Hit Testing the Fragment Tree&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Measuring Dropped Frames and Animation Smoothness by Michal&lt;/p&gt;

    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/jaE1PoSNwZo&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

    &lt;ul&gt;
      &lt;li&gt;Animation Smoothness 오버뷰&lt;/li&gt;
      &lt;li&gt;Visual Completeness vs Smoothness vs Latency&lt;/li&gt;
      &lt;li&gt;어느정도 했는지&lt;/li&gt;
      &lt;li&gt;어떻게 할 수 있는지&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Animation Smoothness 의 목표&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;애니메이션중에 Visual Completeness 프레임에 라벨링을 하는것&lt;/li&gt;
      &lt;li&gt;어떤 애니메이션 프레임이 사용자에게 영향이 갔는지 구분하는 것&lt;/li&gt;
      &lt;li&gt;페이지의 전체 라이프사이클을 측정하는 것&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;https://web.dev/smoothness/&quot;&gt;https://web.dev/smoothness/&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;기존 메트릭과 다른점은 visual smoothness를 실행중인 애니메이션에서 캡쳐하는 것과 모든 애니메이션에 대한 것 등이 있다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Visual Completness
        &lt;ul&gt;
          &lt;li&gt;렌더 프레임이 될 수 있는 기회를 가진 것&lt;/li&gt;
          &lt;li&gt;애니메이션 프레임으로 4개의 상태를 가질 수 있다
            &lt;ol&gt;
              &lt;li&gt;No Update Desired&lt;/li&gt;
              &lt;li&gt;Fully Presented&lt;/li&gt;
              &lt;li&gt;Partially Presented : 메인스래드 없이 컴포지터 업데이트&lt;/li&gt;
              &lt;li&gt;Dropped&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Animation Smoothness
        &lt;ul&gt;
          &lt;li&gt;Frame sequences는 애니메이션 도중 매우 중요하다&lt;/li&gt;
          &lt;li&gt;몇몇의 애니메이션은 Partially Presented다&lt;/li&gt;
          &lt;li&gt;몇몇의 애니메이션은 다른 애니메이션을 마스킹 할 수 있다 (i.e. 스크롤링)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;#show-performance-metrices-hud
        &lt;ul&gt;
          &lt;li&gt;퍼포먼스 메트릭을 실시간으로 볼 수 있는 HUD다&lt;/li&gt;
          &lt;li&gt;드랍된 프레임들의 확률을 볼 수 있다.&lt;/li&gt;
          &lt;li&gt;레이아웃 시프트도 측정해주는듯..?&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 Day1이 끝났다.&lt;/p&gt;

&lt;p&gt;css의 작은 피쳐를 개발하다가 더 넓은 세상을 보게 된 것 같다는 생각이 든다.&lt;/p&gt;

&lt;p&gt;웹 피쳐가 생각보다 더 다양하고 많다는 느낌도 받았고, 개발자 도구가 점점 강력해지고 있다는 생각이 든다.&lt;/p&gt;

&lt;p&gt;아마도, IE만 버릴 수 있다면 이런 피쳐들을 직접 회사에서 활용하는 날이 오지 않을까 기대 해본다.&lt;/p&gt;

&lt;p&gt;물론 interoperability가 보장된 피쳐들을 쓸 수 있지 않을까 생각된다..&lt;/p&gt;

&lt;p&gt;아마도 블링크에 소개되고 쉽 된 기능중 다른 브라우져에서도 지원 될것을 기대하면 한 1~2년 정도 전의 웹 브라우져의 최전선 이였던 피쳐들을 활용할 수 있지 않을까 싶다.&lt;/p&gt;

&lt;p&gt;Day2는 다음에 정리해보고자 한다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="Feature" /><category term="blink" /><category term="conference" /><summary type="html">BlinkOn 15 Day1</summary></entry><entry><title type="html">Chromium Composition과 Layer</title><link href="https://devsdk.github.io/ko/development/2021/03/29/blink-render-composition.html" rel="alternate" type="text/html" title="Chromium Composition과 Layer" /><published>2021-03-29T09:00:11+09:00</published><updated>2021-03-29T09:00:11+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/29/blink-render-composition</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/29/blink-render-composition.html">&lt;p&gt;웹 브라우져의 화면은 다양한 스테이지를 거쳐 화면에 나오게 된다.&lt;/p&gt;

&lt;p&gt;다음은 chromium의 렌더링 과정을 도식화한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112830711-dd464f00-90cd-11eb-8750-3ec8b70fa093.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번 글에서 다루고자 하는 내용은 빨간색으로 네모 친 Composition(합성)이다.&lt;/p&gt;

&lt;p&gt;저번에 &lt;a href=&quot;https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint.html&quot;&gt;Reflow와 Repaint&lt;/a&gt;라는 내용을 다루면서 짧게 이야기를 한 적 있다.&lt;/p&gt;

&lt;p&gt;이번 글에는 조금 더 구체적으로 이야기해 보고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;compositing&quot;&gt;Compositing?&lt;/h3&gt;

&lt;p&gt;한국어로 합성이라고 한다.&lt;/p&gt;

&lt;p&gt;실제로 브라우져는 렌더링을 최대한 최적화 하기 위한 많은 노력을 하고 있는데 여기에 Composition이 포함된다.&lt;/p&gt;

&lt;p&gt;설명하기 이전에 용어를 조금 정리한다.&lt;/p&gt;

&lt;p&gt;화면에 보이는 공간을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Viewport&quot;&gt;Viewport&lt;/a&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;그리고 특정한 정보를 화면의 픽셀로 만드는 과정을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rasterisation&quot;&gt;레스터라이즈&lt;/a&gt; 라고 한다.&lt;/p&gt;

&lt;p&gt;만약 Compositing이 없었다면 렌더링은 어땠을까?&lt;/p&gt;

&lt;p&gt;아래는 composite 없이 single layer로 렌더링이 되었을 때 벌어질 수 있는 것을 그림으로 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112830531-a07a5800-90cd-11eb-8a8c-3de432ac0a8b.gif&quot; alt=&quot;ezgif-6-f0af620c7a69&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 이미지는 Chromium의 가장 첫 번째 버전에서 동작하는 방식이었다.&lt;/p&gt;

&lt;p&gt;스크롤과 같은 행위로 뷰포트를 넘어가는 경우 빈 공간을 다시 레스터라이즈 하는 과정이 있었다.&lt;/p&gt;

&lt;p&gt;여기서 문제는 다른 요소가 변경(위치, 색상 등등)된다면 그 해당하는 공간을 다시 계산해야 한다는 점이었다.&lt;/p&gt;

&lt;p&gt;현대의 브라우져는 이러한 문제를 세련되게 해결하고 있다.&lt;/p&gt;

&lt;p&gt;다음 그림은 layered composition을 설명하는 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112830733-e7684d80-90cd-11eb-8bfb-02cef19c7124.gif&quot; alt=&quot;ezgif-6-d9bdba71caac&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Composition은 분리 가능한 레이어를 분리하고 미리 레스터라이즈를 한 뒤, 그 레이어를 움직이거나 Viewport를 움직이는 방식이다.&lt;/p&gt;

&lt;p&gt;특정한 레이어의 레스터가 변경되고, 위치가 변경된다고 해서 다른 레이어의 요소에 영향을 끼치진 않는다.&lt;/p&gt;

&lt;p&gt;실제로 분리된 레이어를 살펴보자.&lt;/p&gt;

&lt;p&gt;다음은 토이프로젝트로 만들었던 &lt;a href=&quot;https://github.com/DevSDK/DFD&quot;&gt;DFD&lt;/a&gt;의 layer이다.&lt;/p&gt;

&lt;p&gt;React-Virtualized에 의하여 실시간으로 리스트가 갱신되는 것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112830772-f51dd300-90cd-11eb-9f3c-f4a749a82ae9.gif&quot; alt=&quot;Peek_2021-03-29_14-48&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음은 github의 layer이다.&lt;/p&gt;

&lt;p&gt;스크롤에 의해 floating이 되는 부분이 새로운 레이어로 만들어짐을 잘 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112830808-01099500-90ce-11eb-9bff-a802957b2ff5.gif&quot; alt=&quot;Peek_2021-03-29_14-53&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 실제로 composition은 웹에서 최적화를 담당하는 큰 축중 하나로 사용되고 있다.&lt;/p&gt;

&lt;h3 id=&quot;how&quot;&gt;How?&lt;/h3&gt;

&lt;p&gt;그렇다면 Layer은 어떻게 분리가 될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112830907-27c7cb80-90ce-11eb-9c56-b98824525a47.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;렌더러는 DOMTree에서 만들어진 LayoutTree를 이용하여 Compositing Trigger를 가진 녀석들을 layer로 분리시킬 후보로 만든다. 여기서 말하는 트리거는 다양한 이유가 될 수 있는데 대표적으로 transform 요소가 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112830912-29918f00-90ce-11eb-94f0-337026cb0326.png&quot; alt=&quot;Untitled 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기존에는 LayerTree를 사용했던 것 같은데, v2부터는 Layer List를 사용하는 것 같다.&lt;/p&gt;

&lt;p&gt;또한 Scrollable Area에 대해서는 아래와 같이 layer를 나뉘게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112831024-4e860200-90ce-11eb-86f6-7a46e2de1f99.png&quot; alt=&quot;Untitled 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 만들어진 레이어들은 Compositing Assignment라는 단계에서 그래픽 레이어로 변환된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112831051-59409700-90ce-11eb-9746-d18617675748.png&quot; alt=&quot;Untitled 4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각각에 레이어에 대해 다양한 파라미터를 줄 수 있는데 이것을 &lt;strong&gt;property tree&lt;/strong&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112831071-5f367800-90ce-11eb-9219-736535770b5a.png&quot; alt=&quot;Untitled 5&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112831085-63629580-90ce-11eb-996c-26286c59d5fd.png&quot; alt=&quot;Untitled 6&quot; /&gt;
현재까지의 Chromium의 구현체 (Composite After Paint 이전)에는 이 프로퍼티 트리를 레이어가 가지고 있게 된다. 아마 CAP에서는 이를 분리시킬것 이라고 한다.&lt;/p&gt;

&lt;p&gt;이렇게 만들어진 Layer과 Property Tree는 메인쓰래드에서 별도의 compositor thread로 넘기게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112831088-6493c280-90ce-11eb-88d0-04ff9ac4e242.png&quot; alt=&quot;Untitled 7&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112831091-652c5900-90ce-11eb-8c0a-6a0b9093d1e7.png&quot; alt=&quot;Untitled 8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그 후 draw콜에 의하여 레이어가 화면에 그려지도록 렌더 커멘드를 생성하며 다음 스테이지로 넘기게 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;refs&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2018/09/inside-browser-part3#what_is_compositing&quot;&gt;https://developers.google.com/web/updates/2018/09/inside-browser-part3#what_is_compositing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/lifeofapixel&quot;&gt;http://bit.ly/lifeofapixel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/&quot;&gt;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/&lt;/a&gt;&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="Blink" /><category term="Renderer" /><summary type="html">웹 브라우져의 화면은 다양한 스테이지를 거쳐 화면에 나오게 된다.</summary></entry><entry><title type="html">\[CSS-Values-4] 삼각함수 구현 준비</title><link href="https://devsdk.github.io/ko/development/2021/03/29/css-trig-func-begin.html" rel="alternate" type="text/html" title="\[CSS-Values-4] 삼각함수 구현 준비" /><published>2021-03-29T09:00:01+09:00</published><updated>2021-03-29T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/29/css-trig-func-begin</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/29/css-trig-func-begin.html">&lt;p&gt;Chromium에 CSS에 대하여 Infinity 와 NaN을 구현하는 프로젝트가 거의 끝나가고 있다. 몇 가지의 이슈를 해결하면 아마 ship 할 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;이 기능을 구현하며 스팩을 자주 보게 되었는데, 익숙해 진 것도 있고, 눈에 띄는 기능이 보여서 다음 구현 목표를 css-values-4 스팩에서 찾게 되었다.&lt;/p&gt;

&lt;p&gt;새로운 w3c/csswg의 표준인 CSS-values-4를 보면, &lt;a href=&quot;https://drafts.csswg.org/css-values/#trig-funcs&quot;&gt;삼각함수에 대한 내용&lt;/a&gt;이 담겨있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112796569-203ffc80-90a5-11eb-90b0-911861731219.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;더 빠르고, 안정적으로 CSS에서 삼각함수를 사용할 수 있게 될 것이라고 기대하고 있다.&lt;/p&gt;

&lt;p&gt;아마도, hue 컬러 공간 및 삼각함수 관련된 스타일이 필요한 부분에서 유용하게 쓰일 수 있을 것 이라고 생각한다.&lt;/p&gt;

&lt;p&gt;첫번째로 type=feature로 크로미움 이슈 모노레일 &lt;a href=&quot;http://crbug.com&quot;&gt;crbug.com&lt;/a&gt; 에 올려두었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112796587-26ce7400-90a5-11eb-982e-6c34cbf9c7e1.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아마 이 기능도 무한과 NaN 기능을 구현할 때와 마찬가지로 Intent to Prototype과 Design Docs, Chromium Platform Status 등에 등록이 필요할 것 같다.&lt;/p&gt;

&lt;p&gt;구글 크롬팀과 이야기하면서 알게 되었는데 구글 내부적으로는 이 기능을 2분기 계획으로 잡으려고 한다고 했다.&lt;/p&gt;

&lt;p&gt;다만 요즘 이래저래 바빠서 2분기까지 완전히 완성하긴 어려울 것 같고, 프로토타이핑 및 문서화 정도까진 가능할 것 같다고 이야기하긴 했는데 얼른 바쁜 게 끝나면 좋겠다.&lt;/p&gt;

&lt;p&gt;Feature 구현을 시작하기 전에 간단하게 블로그에 정리해 보았다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="CSS" /><category term="Feature" /><category term="css-values-4" /><summary type="html">Chromium에 CSS에 대하여 Infinity 와 NaN을 구현하는 프로젝트가 거의 끝나가고 있다. 몇 가지의 이슈를 해결하면 아마 ship 할 수 있을 것 같다.</summary></entry><entry><title type="html">double 형의 “계산 가능한 범위” 그리고 chromium의 maximum angle</title><link href="https://devsdk.github.io/ko/development/2021/03/22/double-calcable.html" rel="alternate" type="text/html" title="double 형의 &quot;계산 가능한 범위&quot; 그리고 chromium의 maximum angle" /><published>2021-03-22T09:00:01+09:00</published><updated>2021-03-22T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/22/double-calcable</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/22/double-calcable.html">&lt;p&gt;Chromium, CSS Math Function 에 &amp;lt;angle&amp;gt;의 무한 값을 도입하면서 삽질한 기록이다.&lt;/p&gt;

&lt;p&gt;삽질을 하게 된 계기는 표현한 최댓값이 “계산 가능한” 값인 줄 알았던 것이다.&lt;/p&gt;

&lt;p&gt;또한 현재 코드리뷰는 진행중이기 때문에 값은 얼마든지 변할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 매커니즘이 변하진 않을 것 같다.&lt;/p&gt;

&lt;p&gt;Review: &lt;a href=&quot;https://chromium-review.googlesource.com/c/chromium/src/+/2774851&quot;&gt;https://chromium-review.googlesource.com/c/chromium/src/+/2774851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2867080569122160은 -방향으로 오차를 줄이는 방식으로 다시 계산된 값이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112242530-648b6100-8c8f-11eb-8021-41c1247058b6.png&quot; alt=&quot;Screenshot from 2021-03-24 10-54-26&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3월 24일 오전, 2개의 LGTM을 받아 머지시켰다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/angle&quot;&gt;&amp;lt;angle&amp;gt;&lt;/a&gt;은 각도를 나타내는 CSS 값 타입이다.&lt;/p&gt;

&lt;p&gt;새로운 &lt;a href=&quot;https://drafts.csswg.org/css-values/#numeric-types&quot;&gt;CSS-Values-4&lt;/a&gt; 표준에 의하면 &amp;lt;angle&amp;gt;의 최댓값은 표현가능한 범위에서 360값의 배수여야 한다.&lt;/p&gt;

&lt;p&gt;360의 배수이면서 특정한 값보다 작으면서 가장 가까운 값을 구하는 방법이 무엇일까?&lt;/p&gt;

&lt;p&gt;바로 다음과 같은 식을 이용하면 된다.&lt;/p&gt;

\[result = target - target \ mod \  360\]

&lt;p&gt;하지만 double의 최댓값에선 다음과 같은 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/111940095-44359800-8b11-11eb-9471-8ba0282e9f62.png&quot; alt=&quot;Screenshot_from_2021-03-21_13-30-22&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 결과는 우리가 예상한 동작과는 거리가 있어보인다. 실제로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1.79769e+308 === 1.79769e+308 - 100&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 를 내놓는다.&lt;/p&gt;

&lt;p&gt;왜 이런 걸까?&lt;/p&gt;

&lt;p&gt;컴퓨터 공학 학부, 혹은 컴퓨터를 처음 입문하게 되면 컴퓨터가 값을 표현하는 자료형의 범위를 배우게 된다.&lt;/p&gt;

&lt;p&gt;그중에서 배정밀도 double은 8바이트로써, 범위는 다음과 같다.&lt;/p&gt;

&lt;p&gt;±1.7 ×10^-307 이상 ± 3.4 × 10^308 이하&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt;에 따르면 배정밀도는 다음과 같은 비트열을 가지게 된다.&lt;/p&gt;

&lt;p&gt;위 값은 exponent를 포함한 아래 비트열의 모든 비트를 사용했을 때 나올 수 있는 최댓값이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/111940123-4f88c380-8b11-11eb-85ad-6d1e37a46068.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 실제로 계산할 수 있는 범위는 훨씬 작아지는데, 그 이유는 부동소수점에서 exponent 값을 넘어가게 되면 2의 배수로 증가하기 때문이다. 즉, 일반적으로 우리가 기대하는 연산(사칙연산, 삼각함수 등)이 불가능하다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Double-precision floating-point format&lt;/a&gt; 의 &lt;strong&gt;Precision limitations on integer values&lt;/strong&gt; 에 따르면, 정수에 대응될 수 있는 숫자의 표현 범위는 2^53 ~ -2^53인, 9007199254740992 ~ -9007199254740992이다.&lt;/p&gt;

&lt;p&gt;이 아래부터는 chromium에 대한 이야기다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;chromium에서 &amp;lt;angle&amp;gt;의 무한 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2867080569122160&lt;/code&gt; 로 정하게 되었는데 그 이유는 다음과 같다.&lt;/p&gt;

&lt;p&gt;Chromium에서 “각”은 결국 &lt;strong&gt;라디안&lt;/strong&gt; 이라는 단위로 계산이 된다. 이는 rotation matrix에서 삼각함수를 사용할 때 활용된다. 이와 반대로 CSS Math Function은 항상 &lt;strong&gt;degree&lt;/strong&gt;로 반환한다. 즉, degree 값을 radian으로 변환시켜야 transform matrix로 사용할 수 있다는 이야기가 된다. 이 것은 &lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/wtf/math_extras.h&quot;&gt;deg2rad function&lt;/a&gt; 함수를 통해 degree를 radian으로 변환하게 되는데 이 식은 다음과 같다.&lt;/p&gt;

\[rad = \frac{degree *\pi}{180}\]

&lt;p&gt;여기서 문제는 저 최댓값인 9007199254740992에 원주율을 곱하게 되면 우리가 예상하지 못한 동작을 하게 된다는것 이다. 따라서 다음과 같은 식으로 PI를 곱했을 때 표현 가능한 범위를 넘어가지 않도록 해주었다.&lt;/p&gt;

\[base = \frac{9007199254740992}{\pi}\]

\[degree = base - base \ mod \ 360\]

&lt;p&gt;여기서 sin함수를 dgree에 사용했을 때 0.01의 오차를 가지게 되었다. 하지만 이는 충분하지 않다고 생각하여 다음과 같은 스크립트로 0.00001의 오차를 가진 값을 찾아냈다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//To find nearest value using trigonometric functions&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.00001&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
       &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 해서 나온 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2867080569122160&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;따라서 값(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-2867080569122160&lt;/code&gt; ~ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2867080569122160&lt;/code&gt;)을 &amp;lt;angle&amp;gt;의 clamp값으로 선정하였다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="ieee 754" /><summary type="html">Chromium, CSS Math Function 에 &amp;lt;angle&amp;gt;의 무한 값을 도입하면서 삽질한 기록이다.</summary></entry><entry><title type="html">Chromium 새로 개발되는 DOM API Seamless Transitions</title><link href="https://devsdk.github.io/ko/development/2021/03/11/ChromiumSeamlessTransitions.html" rel="alternate" type="text/html" title="Chromium 새로 개발되는 DOM API Seamless Transitions" /><published>2021-03-11T09:00:02+09:00</published><updated>2021-03-11T09:00:02+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/11/ChromiumSeamlessTransitions</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/11/ChromiumSeamlessTransitions.html">&lt;p&gt;오랜만에 patch들을 pull 받고 빌드하는 시간 동안 Chromium에서 SPA(Single Page App)를 위한 API가 어떤 것들이 있을까 라는 생각으로 feature들을 살펴보던 도중 흥미로운 기능이 현재 막 개발되고 있어서 글을 쓴다.&lt;/p&gt;

&lt;p&gt;2021.03.11 기준으로 아직 한창 개발되고 있는 feature이다. Android Webview와 깊은 연관이 있는 만큼 나중에 완성되면 Google IO 같은 데서 한번 말하지 않을까 라는 생각이 든다. (아닐 수도 있다. ㅎㅎ..)&lt;/p&gt;

&lt;p&gt;아직은 비표준인 것 같다. 아마 표준이 되지 않을까 생각된다. &lt;a href=&quot;https://github.com/WICG/proposals/issues/12&quot;&gt;WICS Proposal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/runtime_enabled_features.json5&quot;&gt;runtime flag&lt;/a&gt; 에 따르면 프로토타입은 나온것 같으니 한번 사용해보도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110785255-1436fb00-82ae-11eb-8fe2-5cdad35393b8.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;tltr&quot;&gt;TL;TR&lt;/h1&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;changeBodyBackground&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;background: blue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handleTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prepare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;rootTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;reveal-left&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;changeBodyBackground&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;transition finished&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;트렌지션을 시도하기 전 그 화면을 texure로 렌더링해놓는다. 이 작업을 prepare라고 한다. 이 작업은 비동기적으로 실행되며 GPU 자원을 사용할 수 있다. 그런 뒤 Transition을 하면 렌더링해놓은 텍스쳐 뒤로/앞으로 DOM을 렌더링한다. 그런 뒤 요청한 방식대로 그 이미지를 제거한다. (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reveal-right&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;문서의 motivation쪽을 보니 transition에 부족한점이 많아서 SPA를 혹은 MPA를 위해 시작했다고 한다.&lt;/p&gt;

&lt;h1 id=&quot;example&quot;&gt;Example&lt;/h1&gt;

&lt;p&gt;개발하고 계신 분의 &lt;a href=&quot;https://github.com/vmpstr/shared-element-transitions/blob/main/sample-code/page_transition_spa.html&quot;&gt;example&lt;/a&gt;을 실행해본다. 실행조건은 pull 받은 시점의 &lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git/+/d6485e20161bf3590e295575e320ef7feca7e665&quot;&gt;HEAD&lt;/a&gt;에서 빌드한 content_shell이다. 실행 커멘드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./content_shell --enable-features=DocumentTransition test.html&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;아무래도 Under Construction이라서 직접 실행해 보니 빌드 환경이 동일하지 않은 것 인지 크레시가 난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110784763-6deaf580-82ad-11eb-9b92-17c0ef91beaf.gif&quot; alt=&quot;Peek 2021-03-11 21-03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;explode와 implode는 그래도 잘 동작한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110785324-2f096f80-82ae-11eb-8d00-760efae46532.gif&quot; alt=&quot;Peek 2021-03-11 21-02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이걸 만들고 계신 분이 데모로 올리셨던 영상을 따왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110786952-1dc16280-82b0-11eb-96ac-b28a7f7aa14f.gif&quot; alt=&quot;Peek 2021-03-11 21-23&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디테일은 아래 문서 및 모노레일에서 볼 수 있다. 다시 한 번 말하지만, 아직 개발이 진행 중인 기능이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://crbug.com/1150461&quot;&gt;https://crbug.com/1150461&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/vmpstr/shared-element-transitions&quot;&gt;https://github.com/vmpstr/shared-element-transitions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.google.com/document/d/1UmAL_w5oeoFxrMWiw75ScJDQqYd_a20bOEWfbKhhPi8&quot;&gt;https://docs.google.com/document/d/1UmAL_w5oeoFxrMWiw75ScJDQqYd_a20bOEWfbKhhPi8&lt;/a&gt;&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="CSS" /><summary type="html">오랜만에 patch들을 pull 받고 빌드하는 시간 동안 Chromium에서 SPA(Single Page App)를 위한 API가 어떤 것들이 있을까 라는 생각으로 feature들을 살펴보던 도중 흥미로운 기능이 현재 막 개발되고 있어서 글을 쓴다.</summary></entry><entry><title type="html">CSS @counter-style</title><link href="https://devsdk.github.io/ko/development/2021/03/11/CSSCounterStyle.html" rel="alternate" type="text/html" title="CSS @counter-style" /><published>2021-03-11T09:00:01+09:00</published><updated>2021-03-11T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/11/CSSCounterStyle</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/11/CSSCounterStyle.html">&lt;p&gt;오늘 아침 Blink-Dev Group에서 I2S를 보고 재밌는 CSS Feature가 Ship되는걸 보아서 간단히 메모한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110739167-fea4df80-8273-11eb-8cf5-0cae939349db.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;꾸준히 내가 진행중인 CSS Feature를 리뷰해주고 계신 Xiaocheng이 ship 한 기능이다.&lt;/p&gt;

&lt;p&gt;Firefox에서는 2014년부터 이미 지원되는 기능이였던 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://drafts.csswg.org/css-counter-styles-3/#the-counter-style-rule&quot;&gt;표준에 따르면&lt;/a&gt; 아주다양한 방식으로 사용될 수 있을 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@counter-style&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;footnote&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbolic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;'*'&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⁑&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;†&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;‡&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;suffix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;It&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;produce&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;lists&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;look&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;like&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   &lt;span class=&quot;nt&quot;&gt;One&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;⁑&lt;/span&gt;   &lt;span class=&quot;nt&quot;&gt;Two&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;†&lt;/span&gt;   &lt;span class=&quot;nt&quot;&gt;Three&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;‡&lt;/span&gt;   &lt;span class=&quot;nt&quot;&gt;Four&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;Five&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;⁑⁑&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;Six&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110739184-082e4780-8274-11eb-8719-9f41aec52665.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;근 시일내 당장 쓸 수는 없고, M91버전부터 사용할 수 있을 것 같다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="CSS" /><summary type="html">오늘 아침 Blink-Dev Group에서 I2S를 보고 재밌는 CSS Feature가 Ship되는걸 보아서 간단히 메모한다.</summary></entry><entry><title type="html">Chrome 90 beta is coming, 어떤 기능이 들어올까?</title><link href="https://devsdk.github.io/ko/development/2021/03/08/chrome90.html" rel="alternate" type="text/html" title="Chrome 90 beta is coming, 어떤 기능이 들어올까?" /><published>2021-03-08T09:00:01+09:00</published><updated>2021-03-08T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/08/chrome90</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/08/chrome90.html">&lt;p&gt;Blink Dev-Group에 있으면서, 새로운 Chrome 버전 M90의 beta가 3월 11일에 나온다고 한다. Chromium의 어떤 새로운 기능들이 Chrome 에 도입될 수 있을지 알아보도록 한다.&lt;/p&gt;

&lt;p&gt;이 내용은 &lt;a href=&quot;https://docs.google.com/spreadsheets/d/155euqrhdqVhtbAID7ydaUPjBstLIYZ4PJkpFmqJ6j-o/edit#gid=215381875&quot;&gt;What’s Shipping&lt;/a&gt; 시트를 참고하였다.&lt;/p&gt;

&lt;p&gt;각각 기능은 한 줄에서 두 줄 정도로 이해한 만큼 쓰도록 한다. &lt;em&gt;몇 가지는 생략할 수도 있다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;특히 인상 깊은 건 우선순위 기반 스케쥴러의 도입이 아닐까 싶다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6556060494069760&quot;&gt;Seeking past the end of a file in the File System Access API&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;파일의 끝을 지나서 write를 할 때 reject 대신, 파일을  0x00(NUL)값과 함께 확장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5676695065460736&quot;&gt;StaticRange constructor&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Highlight API Explained를 위한 feature라는데, 아직 잘 모르겠다 WHATWG 스팩에도 &lt;a href=&quot;https://dom.spec.whatwg.org/#interface-staticrange&quot;&gt;constructor만 명시되어 있다.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5710618575241216&quot;&gt;Subresource loading with Web Bundles&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다수의 리소스를(e.g. Web Bundles) 번들로 묶을 수 있는 포멧을 사용하여 많은 수의 리소스들을 효율적으로 로드할 수 있는 방향을 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5737185317748736&quot;&gt;Support specifying width/height on &amp;lt;source&amp;gt; elements for &amp;lt;picture&amp;gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&amp;lt;picture&amp;gt;에 대하여 &amp;lt;source&amp;gt;를 이용해 width와 height를 제공함으로써 image의 화면 비율을 계산할 수 있게 해준다.&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;picture&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;source&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;srcset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image.jpg&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;640&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;480&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width: 100%; height: auto;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/picture&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5370811722498048&quot;&gt;URL protocol setter: New restrictions for file URLs&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;파일에 혹은 파일로 부터 URL이 변경될 때 발생하는 edge case를 바로잡음.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5658873031557120&quot;&gt;Use :focus-visible in the default UA style sheet&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Chromium의 기본 UA스타일을 포커스 인디케이터를 위해 :focus pseudo-class를 사용하는 것 대신 :focus-visible를 사용함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/4756734233018368&quot;&gt;WebAssembly Exception Handling&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;웹 어셈블리의 exception handling 도입.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5086267630944256&quot;&gt;WebAudio: OscillatorOptions.periodicWave is not nullable&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;더이상 periodicWave의 맴버 OscillatorOptions을 null로 설정할 수 없음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5704707957850112&quot;&gt;WebXR AR Lighting Estimation&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;사이트가 WebXr 세션 내에서 environmental lighting의 근사치를 쿼리할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5742647199137792&quot;&gt;WebXR Depth API&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;WebXRDevice의 Deapth Buffer로 접근할 수 있게 해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/5045313003847680&quot;&gt;getCurrentBrowsingContextMedia()&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;navigator.mediaDevices.getCurrentBrowsingContextMedia() 이 api를 통해 현재 탭에서의 MedaiStream을 캡처할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6031161734201344&quot;&gt;Main thread Scheduling APIs: Prioritized scheduler.postTask&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;개발자가 브라우져의 네이티브 스케쥴러를 통해 3개의 우선순위(user-blocking, user-visible, and background)를 가지는 테스크(javscript callbak)를 스케줄 할 수있게 해준다. (성능과 관련 있음)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/5499415634640896&quot;&gt;MediaStreamTrack Insertable Streams (a.k.a. Breakout Box)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;카메라의 출력, 마이크, 화면 캡처 또는 코덱의 디코더 부분과 코덱의 디코더 입력과 같은 MeadiaStreamTracks에서 전달하는 raw 미디어를 조작하기 위한 API&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5670287242690560&quot;&gt;Protect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-protobuffer&lt;/code&gt; via Cross-Origin-Read-Blocking&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;speculative execution 공격으로부터 ‘application/x-protobuffer’을 지킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://chromestatus.com/features/5694001745231872&quot;&gt;Read Chrome device attributes&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Device Web API의 일부분인 Device attribute를 query 할 수 있게 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6123640410079232&quot;&gt;Relative indexing method for Array, String, and TypedArrays&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;at() 함수 추가.&lt;/p&gt;

    &lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Returns 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5633112799182848&quot;&gt;AbstractRange superclass&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;StaticRange와 Range를 추상화 함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5638444178997248&quot;&gt;Add support for CSS properties “overflow: clip” and “overflow-clip-margin”&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#values&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#values&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/6206321818861568&quot;&gt;AV1 Encoder&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Chrome desktop을 위한 AV1 인코더 도입&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5671807392677888&quot;&gt;Clipboard: read-only files support&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5733828735795200&quot;&gt;CORS-RFC1918: CORS restrictions on internet-to-intranet connections.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5682100885782528&quot;&gt;CSS aspect-ratio interpolation&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;비율에 대한 보간 내용인 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6537562418053120&quot;&gt;Custom state pseudo class&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Custom Element의 state를  :state() psuedo class에서 접근 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><summary type="html">Blink Dev-Group에 있으면서, 새로운 Chrome 버전 M90의 beta가 3월 11일에 나온다고 한다. Chromium의 어떤 새로운 기능들이 Chrome 에 도입될 수 있을지 알아보도록 한다.</summary></entry><entry><title type="html">Reflow, Repaint Chromium 입장에서 살펴보기 (왜 transform은 빠를까?)</title><link href="https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint.html" rel="alternate" type="text/html" title="Reflow, Repaint Chromium 입장에서 살펴보기 (왜 transform은 빠를까?)" /><published>2021-03-08T09:00:00+09:00</published><updated>2021-03-08T09:00:00+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint.html">&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;Reflow와 Repaint에 대해서 면접 단골 질문이라고 해서 조금 깊이 살펴보도록 한다.&lt;br /&gt;
최적화와 관련된 이야기며, Message Queue (event loop)에 대한 이해가 필요하다. 그 내용은 &lt;a href=&quot;https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html&quot;&gt;여기서&lt;/a&gt; 볼 수 있다. 요약하자면, 만약 js 태스크와 같은 작업이 message queue에서 선점되어 animation frame이 늦어지는 경우 사용자에게 애니메이션이 끊기는 등의 경험을 줄 수 있다. 이런 것을 피하고 최적화할 수 있는 방법에 대해 알아본다.&lt;/p&gt;
&lt;h3 id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Reflow, Repaint, Layout, Paint, Composite&lt;/li&gt;
  &lt;li&gt;CSS Animation&lt;/li&gt;
  &lt;li&gt;왜 transform을 이용하면 빠를까?&lt;/li&gt;
  &lt;li&gt;tracing으로 알아보는 실제 layout, paint&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;1-reflow-repaint-layout-paint-composite&quot;&gt;1. Reflow, Repaint, Layout, Paint, Composite&lt;/h1&gt;

&lt;p&gt;이 글에서 Reflow와 Repaint는 Layout과 Paint와 대응된다. Reflow와 Repaint는 firefox의 “Gecko” 진영에서 주로 사용하고, layout과 paint는 safari의 webkit과 chromium의 blink 진영에서 사용한다. 혼동을 피하고자 layout과 paint로 설명하도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;layout은-무엇일까&quot;&gt;Layout은 무엇일까?&lt;/h3&gt;

&lt;p&gt;웹브라우져에는 사실 DOM Tree 말고 렌더 스테이지에서 중요한 역할을 하는 트리가 하나 더 있다. 화면에 실제로 그리기 위해 박스모델과 좌표 계산이 끝난 상태인 Layout Tree라는 것을 관리한다. 이는 DOM Tree와 대응되지 않으며, display : none인 경우에는 아예 Layout Tree에 제외되기도 한다. 이러한 내용이 궁금하다면 &lt;a href=&quot;https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_528&quot;&gt;여기&lt;/a&gt;를 살펴보면 좋을 것 같다. layout 단계 혹은 reflow는 &lt;strong&gt;이 트리를 전체 혹은 일부를 새로 구성하는 것&lt;/strong&gt;을 의미한다. layout이 발생한다는 경우에 대해서는 &lt;a href=&quot;https://sites.google.com/site/getsnippet/javascript/dom/repaints-and-reflows-manipulating-the-dom-responsibly&quot;&gt;이곳에서&lt;/a&gt; 리스트업을 하지만 브라우져 레벨에서 &lt;strong&gt;“항상” layout이 발생하는 것은 아니다.&lt;/strong&gt; 예로 CSS Animation을 들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;paint는-무엇일까&quot;&gt;Paint는 무엇일까?&lt;/h3&gt;

&lt;p&gt;위에서 만든 LayoutTree를 순회하며 Paint Command를 만들고 &lt;a href=&quot;https://skia.org/&quot;&gt;SKIA&lt;/a&gt; 레스터라이저한테 전달하는 단계이다.  이를  추상화하고 줄여서 설명하면 &lt;strong&gt;Layout Tree를 화면에 그리는 단계&lt;/strong&gt;라고 이해해도 좋을 것 같다. 여기서 layout 트리에 대응되는 computed style에서 color와 같은 값을 가져와서 화면을 그리게 된다.
 이 단계 또한 매우 방대하며, 관심 있다면 &lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/paint/README.md#Current-compositing-algorithm-CompositeBeforePaint&quot;&gt;이 문서&lt;/a&gt;를 보도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;composite&quot;&gt;Composite?&lt;/h3&gt;

&lt;p&gt;Composite은 각각의 분리 가능한 레이어를 분리해서 처리한 뒤 합성하는 것이다. 거시적인 관점에서 &lt;strong&gt;Composite는 Main Thread (Message Queue)에서 벗어나서 다른 Thread Flow를 가지고 화면을 업데이트&lt;/strong&gt; 할 수 있다. 즉 비동기적으로 실행된 후 기존 레이어에 합성된다. 주로 animation과 scroll 등등에서 활용되며, 다른 Thread Flow를 가지기 때문에 main thread에서 block이 일어나도 composite만 사용하는 애니메이션은 계속 재생될 수 있다.&lt;/p&gt;

&lt;p&gt;Composition에 대해서는 &lt;a href=&quot;https://devsdk.github.io/ko/development/2021/03/29/blink-render-composition.html&quot;&gt;이곳에&lt;/a&gt; 정리를 해두었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110417527-1dbb3a00-80d9-11eb-9724-e26417c8324d.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;Composition example from &lt;a href=&quot;https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_1213&quot;&gt;Life of Pixels&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-css-animation&quot;&gt;2. CSS Animation&lt;/h1&gt;

&lt;p&gt;CSS Animation은 공짜가 아니며 브라우져의 리소스를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://csstriggers.com/&quot;&gt;https://csstriggers.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 사이트는 CSS Animation이 렌더 스테이지에서 어떤 단계를 trigger 하는지 보여준다.&lt;/p&gt;

&lt;p&gt;여기서 Layout &amp;gt; Paint &amp;gt; Composite 순으로 cost가 높으며 composite만 있다면 Message Queue와 무관하게 동작하므로 매우 좋은 애니메이션 타겟이 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276915-8641e280-8017-11eb-8f9d-777e61cde490.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276931-8f32b400-8017-11eb-8b37-f3a5209dd077.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;width의 cost는 Layout, Paint, Composite를 전부 사용한다. 따라서 꽤 높은 비용이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276946-98bc1c00-8017-11eb-9929-2508783b42b0.png&quot; alt=&quot;Untitled 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;background-color는 paint, composite를 사용한다.&lt;/p&gt;

&lt;h1 id=&quot;3-왜-transform을-이용하면-빠를까&quot;&gt;3. 왜 transform을 이용하면 빠를까?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276963-a2458400-8017-11eb-8c3e-029f7f5c0b3c.png&quot; alt=&quot;Untitled 4&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276965-a376b100-8017-11eb-962b-e7945a3dd8c2.png&quot; alt=&quot;Untitled 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우리는 같은 역할을 하는 두 가지의 코드를 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    .b &lt;span class=&quot;si&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transform: translateX(200px)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;position:relative;left:200px&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276977-ad001900-8017-11eb-9022-42350b5a8555.png&quot; alt=&quot;Untitled 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 코드는 완전히 화면에 동일한 결과를 내놓는다. 하지만 내부적으로 다르게 동작한다.&lt;/p&gt;

&lt;p&gt;컴퓨터는 그래픽을  matrix의 곱으로 표현한다. (&lt;a href=&quot;http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/&quot;&gt;OpenGL examples&lt;/a&gt;) 이는 OpenGL, DirectX 등에 반드시 사용되며 GPU는 이런 연산을 빠르게 하기 위해 설계되었다.&lt;/p&gt;

&lt;p&gt;transform을 사용한 예시중 첫번째 div는 최종 composite에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Transformation_matrix&quot;&gt;transformation matrix&lt;/a&gt;를 통해 렌더링 되기 전 composite thread에서 GPU의 도움을 받아 계산된다.  아주 빠른 연산이 비동기적으로 일어나 매우 빠른 속도를 보여준다.  어떤 연산이 일어나는지는 &lt;a href=&quot;https://drafts.csswg.org/css-transforms/#mathematical-description&quot;&gt;표준을&lt;/a&gt; 참고하자. 심지어 Main Thread가 다른 태스크에 의해 block 되어도 재생된다.&lt;/p&gt;

&lt;p&gt;left를 사용한 아래 예시는 layout→composite.assign-&amp;gt;paint의 절차를 모두 밟게 된다. 즉 애니메이션으로 사용되기엔 꽤 비싼 cost를 가지고 있다는 소리다.
(Paint → Composite 는 현재 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=471333&quot;&gt;Chromium의 주요 프로젝트중&lt;/a&gt; 하나이다. CAP (Composition After Paiting)이라고 불린다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110435489-6c2b0180-80f6-11eb-9c35-82824d8ad351.gif&quot; alt=&quot;Peek 2021-03-09 16-40&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 즐거운 결론을 낼 수 있다. animation에서 만약 같은 결과를 내는 코드라면 &lt;strong&gt;composite만 사용하는 애니메이션 (i.e.transform)&lt;/strong&gt;을 애용하자.&lt;/p&gt;

&lt;h1 id=&quot;4-tracing으로-알아보는-실제-layout-paint&quot;&gt;4. Tracing으로 알아보는 실제 layout, paint&lt;/h1&gt;

&lt;p&gt;아래부터의 내용은 chromium/chrome의 동작 구조를 직접 살펴보며 위에서 이야기한 내용을 눈으로 봐볼 것이다.&lt;/p&gt;

&lt;p&gt;아래는 width를 이용한 animation을 tracing 한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277005-c0ab7f80-8017-11eb-9b93-6fa9b7769b5e.png&quot; alt=&quot;Screenshot_from_2021-03-08_11-45-14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CrRendererMain에 바코드처럼 빼곡하게 있는 것들이 바로 layout→paint 그리고 composite를 트리거 하는 단계이다.&lt;/p&gt;

&lt;p&gt;저 바코드의 줄 하나를 확대하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277012-c608ca00-8017-11eb-999d-aa8f220241a2.png&quot; alt=&quot;Screenshot_from_2021-03-08_13-45-51&quot; /&gt;&lt;/p&gt;

&lt;p&gt;트레이스가 기록된 저 상자는 c++ 구현과 1대1로 대응되며, 필요하다면 소스코드를 볼 수 있다. 이 내용을 보면 &lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/frame/local_frame_view.cc;l=3312;drc=3c992b98c58db034eb5af6bc51aac6fb1939d571&quot;&gt;LocalFrameView::UpdateStyleAndLayoutIfNeededRecursive()&lt;/a&gt;이 호출됨으로써 layout과 paint가 끊임없이 일어난다는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;만약 DOM Tree의 깊이가 깊어진다면 그만큼의 recursion 호출이 발생한다.&lt;/p&gt;

&lt;p&gt;그렇다면 반대로 transform을 사용한 경우는 어떤 트레이싱을 볼 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277028-cdc86e80-8017-11eb-87dc-550b7e53f85a.png&quot; alt=&quot;Untitled 6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞에 빼곡하게 있는 것은 마우스 때문에 발생한 animation이고 실제로 trigger 돼서 화면에 보인 것은 갑자기 빈 공간이 생기는 부분부터 이다. 여기서 compositor는 전달받은 역할을 &lt;strong&gt;비동기적&lt;/strong&gt;으로 실행하는 것을 볼 수 있다. 이런 이유 때문에 composite만 사용하는 애니메이션은 alert와 같이 main thread가 block 된 상황에서도 정상적으로 렌더 수행이 진행된다.&lt;/p&gt;

&lt;p&gt;오타/질문/틀린 내용이 있다면 언제든지 피드백 바란다. :)&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Web" /><category term="HTML" /><category term="CSS" /><category term="Optimization" /><summary type="html">Overview</summary></entry><entry><title type="html">React 파헤치기, 리액트가 동작하는 방법 (overview)</title><link href="https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview.html" rel="alternate" type="text/html" title="React 파헤치기, 리액트가 동작하는 방법 (overview)" /><published>2021-03-07T09:00:00+09:00</published><updated>2021-03-07T09:00:00+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview.html">&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;Chromium에서 활동하면서 웹브라우져가 어떻게 동작하는지는 어느 정도 (완벽할 순 없다고 생각한다.. 너무 거대하다.)알고 있다.&lt;/p&gt;

&lt;p&gt;그리고 리액트를 사용하는 방법을 알고 있다.&lt;/p&gt;

&lt;p&gt;그러나 React-DOM과 내부 사항들에 대해서는 너무 추상적으로 알고있거나 모른다고 생각한다.&lt;/p&gt;

&lt;p&gt;그래서 리액트와 브라우져 사이의 블랙박스가 너무 궁금하여 몇몇 가지의 문서와 react 소스코드를 뒤졌던 결과 어느정도 오버뷰가 나올 것 같아서 블로그에 정리하도록 한다.&lt;/p&gt;

&lt;p&gt;하지만 아직 완전히 모든 소스코드를 본 것은 아니며, 생략되거나, 틀릴 수도 있는 내용이다.&lt;/p&gt;

&lt;p&gt;언제든지 피드백을 받는다면 반영하도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232600-03128500-7f62-11eb-8f38-c3e5015e0303.png&quot; alt=&quot;Untitled (2)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글을 쓰기 시작한 큰 이유다.&lt;/p&gt;

&lt;p&gt;중간에 블랙박스가 너무 많아 실제로 어떻게 동작하는지 그리고 내가 더 생각해 볼 수 있는 다른 방향은 없는지 알기가 어려웠다. 덧붙이자면 말 그대로 &lt;strong&gt;마법상자&lt;/strong&gt; 가 있어서 이를 화면에 그려주고 상태를 변경시키는 작업을 하는 느낌을 받았다.&lt;/p&gt;

&lt;p&gt;지금부터 그 마법상자를 열어보도록 한다.&lt;/p&gt;

&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232607-09a0fc80-7f62-11eb-9780-6bd6e032638c.png&quot; alt=&quot;Untitled (3)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;글 내용이 뒤죽박죽이라, 아래의 내용을 바탕으로 위의 이미지를 정리하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;콜백에 의해 fiber 스케쥴러가 업데이트되고, 그 스케쥴러는 fiber들의 테스크를 실행하여 산출물인 업데이트 트리(WorkInProgress or Finished)를 Commit을 통해 dom에 반영한다.&lt;/p&gt;

&lt;h1 id=&quot;detail&quot;&gt;Detail&lt;/h1&gt;

&lt;p&gt;React는 다음과 같은 JSX 문법을 통해 “선언적” 인 구현을 권장한다. (&lt;a href=&quot;https://reactjs.org/docs/jsx-in-depth.html&quot;&gt;리엑트 공식 문서&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;리액트를 처음 썼을때 가장 놀랐던 부분이기도 하다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MyButton&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;blue&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;shadowSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  Click Me
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MyButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공식문서에서도 설명하듯이, 이는 컴파일러에 의해 (babel-loader?) 다음과 같이 코드로 변경된다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;MyButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;shadowSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Click Me&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 함수를 거치면서 아래의 계층을 가진 object 형식으로 반환이 된다.&lt;/p&gt;

&lt;p&gt;DOM과 유사하게 children이 있고 여러 가지 정보들을 담고 있다.&lt;/p&gt;

&lt;p&gt;(위 소스코드와 아래의 결과와는 다르다. 위는 공식문서에서 가져왔다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232637-3d7c2200-7f62-11eb-930c-b90f62771320.png&quot; alt=&quot;Untitled (4)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 우리는 위 내용을 ReactDOM.render를 통해 react-dom에 전달한다. react-dom은 위 정보를 fiber 라는 형태로 관리한다.&lt;/p&gt;

&lt;p&gt;Fiber는 react의 element는 1대1로 대응되면서 여러 내부 정보를 가지고 있는 구조이며 react의 작업의 단위가 되기도 하고, 자체적인 스택프레임을 가지는 일의 주체라고 한다.&lt;/p&gt;

&lt;p&gt;reconciliation 작업에 사용된다. (fiber는 &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-reconciler/src&quot;&gt;react-reconciler&lt;/a&gt; 패키지에서 관리한다.) 내부적인 reconciliation 알고리즘은 O(n)의 휴리스틱 한 알고리즘이라고 한다. 공식문서에서는 개발자가 key를 줌으로써 알고리즘에 힌트를 줄 수 있다는 중요한 내용이 담겨있다.&lt;/p&gt;

&lt;p&gt;그렇다면 fiber는 어떤 역할을 할까?&lt;/p&gt;

&lt;p&gt;너무 &lt;a href=&quot;https://github.com/facebook/react/blob/7df65725ba7826508e0f3c0f1c6f088efdbecfca/packages/react-reconciler/src/ReactFiber.new.js#L111&quot;&gt;필드가 많아서&lt;/a&gt; 봤던 article의 내용 중 일부를 빌리자면 이렇게 생겼다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;stateNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;alternate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;chiled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;updateQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;memoizedState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;pendingProps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;memoizedProps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;effectTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;nextEffect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tree 형태로 내용을 기반으로 순회하면서 WorkInProgress 트리를 만들게 된다. 그리고 WorkInProgress는 이후 화면으로 반영될 트리를 의미한다. 여기서 자주 보던 녀석들이 있는데 React.memo에 의해 property를 기록할 때 실제로 반영되는 필드인 memoizedProps와, 공식문서에서도 설명하던 key 필드이다. 이 필드는 reconciliation 작업에서 휴리스틱한 탐색에 주요 factor로 사용된다.&lt;/p&gt;

&lt;p&gt;또한, 자체적인 스택프레임을 가지고 있다는 부분이 정말 재밌는데, &lt;a href=&quot;https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html&quot;&gt;이벤트루프의 동작 방식&lt;/a&gt; 에 따르면 js execution이 길어지면 다음 태스크가 계속 기다려야 하므로 사용자경험이 안 좋아(애니메이션이 끊긴다거나, 터치가 씹힌다거나 등) 질 수 있는 것을 방지하기 위해 도입된 방식이다.&lt;/p&gt;

&lt;p&gt;fiber한테는 자체적인 실행 스택(work queue로 관리되는 듯해 보인다)을 가지고 자체적인 priority 기반 scheduler를 이용하여 태스크를 쪼개서 관리하면서 Message Queue가 다른 이벤트를 처리할 수 있도록 하여 Message Queue가 다른 task를 실행할 수 있도록 해주는 것 같다. 여기서 스케쥴러는 requestIdleCallback (requestAnimationframe?) API에 의해 호출된다.&lt;/p&gt;

&lt;p&gt;이제 react-dom의 마지막 산출 단계에서는 render 페이즈와 commit 페이즈로 나뉘게 된다.&lt;/p&gt;

&lt;p&gt;렌더페이즈는 위에서 서술했듯이 current 트리에서 WorkInPregress를 생성하는 (변경사항들을 찾아서 렌더링할 재료를 만드는) 단계라면 commit 페이즈는 말 그대로 화면에 그리도록 제출하는 단계이다. 여기서 didComponentMount 와 같은 lifecycle 함수들이 호출된다. (렌더 페이즈에서 호출되든 lifecycle 함수들은 UNSAFE_ 태그를 달고 있다고 한다.)&lt;/p&gt;

&lt;p&gt;실제로 react 소스코드에서 &lt;a href=&quot;https://github.com/facebook/react/blob/c7b4497988e81606f1c7686434f55a49342c9efc/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1350&quot;&gt;commitUpdate&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/react/blob/c7b4497988e81606f1c7686434f55a49342c9efc/packages/react-dom/src/client/ReactDOMHostConfig.js#L451&quot;&gt;commitPlacement&lt;/a&gt; 등등을 통해 dom에 반영하는 것을 찾아볼 수 있다. 내부적으론 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore&quot;&gt;insertBefore&lt;/a&gt; 와 같은 함수를 호출하는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;위 내용은 글 초반에 말했듯이, 소스코드레벨에서 완전한 이해를 바탕으로 쓴 글이 아니다.&lt;/p&gt;

&lt;p&gt;몇몇 가지의 글을 보고, 소스를 뒤적이다가 오버뷰를 만들면 좋을 것 같다는 생각에 작성했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;refs&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react&quot;&gt;https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;https://github.com/acdlite/react-fiber-architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/lifeofapixel&quot;&gt;http://bit.ly/lifeofapixel&lt;/a&gt;&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="React" /><category term="Web" /><category term="React-DOM" /><summary type="html">Motivation</summary></entry></feed>