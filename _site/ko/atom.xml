<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://devsdk.github.io/ko/atom.xml" rel="self" type="application/atom+xml" /><link href="https://devsdk.github.io/ko/" rel="alternate" type="text/html" hreflang="ko" /><updated>2021-03-29T15:43:46+09:00</updated><id>https://devsdk.github.io/ko/</id><title type="html">Seokho’s blog</title><subtitle>Development and Tech blog</subtitle><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><entry><title type="html">\[CSS-Values-4] 삼각함수 구현 준비</title><link href="https://devsdk.github.io/ko/development/2021/03/29/css-trig-func-begin.html" rel="alternate" type="text/html" title="\[CSS-Values-4] 삼각함수 구현 준비" /><published>2021-03-29T09:00:01+09:00</published><updated>2021-03-29T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/29/css-trig-func-begin</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/29/css-trig-func-begin.html">&lt;p&gt;Chromium에 CSS에 대하여 Infinity 와 NaN을 구현하는 프로젝트가 거의 끝나가고 있다. 몇 가지의 이슈를 해결하면 아마 ship 할 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;이 기능을 구현하며 스팩을 자주 보게 되었는데, 익숙해 진 것도 있고, 눈에 띄는 기능이 보여서 다음 구현 목표를 css-values-4 스팩에서 찾게 되었다.&lt;/p&gt;

&lt;p&gt;새로운 w3c/csswg의 표준인 CSS-values-4를 보면, &lt;a href=&quot;https://drafts.csswg.org/css-values/#trig-funcs&quot;&gt;삼각함수에 대한 내용&lt;/a&gt;이 담겨있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112796569-203ffc80-90a5-11eb-90b0-911861731219.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;더 빠르고, 안정적으로 CSS에서 삼각함수를 사용할 수 있게 될 것이라고 기대하고 있다.&lt;/p&gt;

&lt;p&gt;아마도, hue 컬러 공간 및 삼각함수 관련된 스타일이 필요한 부분에서 유용하게 쓰일 수 있을 것 이라고 생각한다.&lt;/p&gt;

&lt;p&gt;첫번째로 type=feature로 크로미움 이슈 모노레일 &lt;a href=&quot;http://crbug.com&quot;&gt;crbug.com&lt;/a&gt; 에 올려두었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112796587-26ce7400-90a5-11eb-982e-6c34cbf9c7e1.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아마 이 기능도 무한과 NaN 기능을 구현할 때와 마찬가지로 Intent to Prototype과 Design Docs, Chromium Platform Status 등에 등록이 필요할 것 같다.&lt;/p&gt;

&lt;p&gt;구글 크롬팀과 이야기하면서 알게 되었는데 구글 내부적으로는 이 기능을 2분기 계획으로 잡으려고 한다고 했다.&lt;/p&gt;

&lt;p&gt;다만 요즘 이래저래 바빠서 2분기까지 완전히 완성하긴 어려울 것 같고, 프로토타이핑 및 문서화 정도까진 가능할 것 같다고 이야기하긴 했는데 얼른 바쁜 게 끝나면 좋겠다.&lt;/p&gt;

&lt;p&gt;Feature 구현을 시작하기 전에 간단하게 블로그에 정리해 보았다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="CSS" /><category term="Feature" /><category term="css-values-4" /><summary type="html">Chromium에 CSS에 대하여 Infinity 와 NaN을 구현하는 프로젝트가 거의 끝나가고 있다. 몇 가지의 이슈를 해결하면 아마 ship 할 수 있을 것 같다.</summary></entry><entry><title type="html">double 형의 “계산 가능한 범위” 그리고 chromium의 maximum angle</title><link href="https://devsdk.github.io/ko/development/2021/03/22/double-calcable.html" rel="alternate" type="text/html" title="double 형의 &quot;계산 가능한 범위&quot; 그리고 chromium의 maximum angle" /><published>2021-03-22T09:00:01+09:00</published><updated>2021-03-22T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/22/double-calcable</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/22/double-calcable.html">&lt;p&gt;Chromium, CSS Math Function 에 &amp;lt;angle&amp;gt;의 무한 값을 도입하면서 삽질한 기록이다.&lt;/p&gt;

&lt;p&gt;삽질을 하게 된 계기는 표현한 최댓값이 “계산 가능한” 값인 줄 알았던 것이다.&lt;/p&gt;

&lt;p&gt;또한 현재 코드리뷰는 진행중이기 때문에 값은 얼마든지 변할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 매커니즘이 변하진 않을 것 같다.&lt;/p&gt;

&lt;p&gt;Review: &lt;a href=&quot;https://chromium-review.googlesource.com/c/chromium/src/+/2774851&quot;&gt;https://chromium-review.googlesource.com/c/chromium/src/+/2774851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2867080569122160은 -방향으로 오차를 줄이는 방식으로 다시 계산된 값이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/112242530-648b6100-8c8f-11eb-8021-41c1247058b6.png&quot; alt=&quot;Screenshot from 2021-03-24 10-54-26&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3월 24일 오전, 2개의 LGTM을 받아 머지시켰다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/angle&quot;&gt;&amp;lt;angle&amp;gt;&lt;/a&gt;은 각도를 나타내는 CSS 값 타입이다.&lt;/p&gt;

&lt;p&gt;새로운 &lt;a href=&quot;https://drafts.csswg.org/css-values/#numeric-types&quot;&gt;CSS-Values-4&lt;/a&gt; 표준에 의하면 &amp;lt;angle&amp;gt;의 최댓값은 표현가능한 범위에서 360값의 배수여야 한다.&lt;/p&gt;

&lt;p&gt;360의 배수이면서 특정한 값보다 작으면서 가장 가까운 값을 구하는 방법이 무엇일까?&lt;/p&gt;

&lt;p&gt;바로 다음과 같은 식을 이용하면 된다.&lt;/p&gt;

\[result = target - target \ mod \  360\]

&lt;p&gt;하지만 double의 최댓값에선 다음과 같은 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/111940095-44359800-8b11-11eb-9471-8ba0282e9f62.png&quot; alt=&quot;Screenshot_from_2021-03-21_13-30-22&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 결과는 우리가 예상한 동작과는 거리가 있어보인다. 실제로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1.79769e+308 === 1.79769e+308 - 100&lt;/code&gt; 은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt; 를 내놓는다.&lt;/p&gt;

&lt;p&gt;왜 이런 걸까?&lt;/p&gt;

&lt;p&gt;컴퓨터 공학 학부, 혹은 컴퓨터를 처음 입문하게 되면 컴퓨터가 값을 표현하는 자료형의 범위를 배우게 된다.&lt;/p&gt;

&lt;p&gt;그중에서 배정밀도 double은 8바이트로써, 범위는 다음과 같다.&lt;/p&gt;

&lt;p&gt;±1.7 ×10^-307 이상 ± 3.4 × 10^308 이하&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt;에 따르면 배정밀도는 다음과 같은 비트열을 가지게 된다.&lt;/p&gt;

&lt;p&gt;위 값은 exponent를 포함한 아래 비트열의 모든 비트를 사용했을 때 나올 수 있는 최댓값이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/111940123-4f88c380-8b11-11eb-85ad-6d1e37a46068.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 실제로 계산할 수 있는 범위는 훨씬 작아지는데, 그 이유는 부동소수점에서 exponent 값을 넘어가게 되면 2의 배수로 증가하기 때문이다. 즉, 일반적으로 우리가 기대하는 연산(사칙연산, 삼각함수 등)이 불가능하다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Double-precision floating-point format&lt;/a&gt; 의 &lt;strong&gt;Precision limitations on integer values&lt;/strong&gt; 에 따르면, 정수에 대응될 수 있는 숫자의 표현 범위는 2^53 ~ -2^53인, 9007199254740992 ~ -9007199254740992이다.&lt;/p&gt;

&lt;p&gt;이 아래부터는 chromium에 대한 이야기다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;chromium에서 &amp;lt;angle&amp;gt;의 무한 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2867080569122160&lt;/code&gt; 로 정하게 되었는데 그 이유는 다음과 같다.&lt;/p&gt;

&lt;p&gt;Chromium에서 “각”은 결국 &lt;strong&gt;라디안&lt;/strong&gt; 이라는 단위로 계산이 된다. 이는 rotation matrix에서 삼각함수를 사용할 때 활용된다. 이와 반대로 CSS Math Function은 항상 &lt;strong&gt;degree&lt;/strong&gt;로 반환한다. 즉, degree 값을 radian으로 변환시켜야 transform matrix로 사용할 수 있다는 이야기가 된다. 이 것은 &lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/wtf/math_extras.h&quot;&gt;deg2rad function&lt;/a&gt; 함수를 통해 degree를 radian으로 변환하게 되는데 이 식은 다음과 같다.&lt;/p&gt;

\[rad = \frac{degree *\pi}{180}\]

&lt;p&gt;여기서 문제는 저 최댓값인 9007199254740992에 원주율을 곱하게 되면 우리가 예상하지 못한 동작을 하게 된다는것 이다. 따라서 다음과 같은 식으로 PI를 곱했을 때 표현 가능한 범위를 넘어가지 않도록 해주었다.&lt;/p&gt;

\[base = \frac{9007199254740992}{\pi}\]

\[degree = base - base \ mod \ 360\]

&lt;p&gt;여기서 sin함수를 dgree에 사용했을 때 0.01의 오차를 가지게 되었다. 하지만 이는 충분하지 않다고 생각하여 다음과 같은 스크립트로 0.00001의 오차를 가진 값을 찾아냈다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//To find nearest value using trigonometric functions&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.00001&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
       &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;PI&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;degree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 해서 나온 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2867080569122160&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;따라서 값(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-2867080569122160&lt;/code&gt; ~ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2867080569122160&lt;/code&gt;)을 &amp;lt;angle&amp;gt;의 clamp값으로 선정하였다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="ieee 754" /><summary type="html">Chromium, CSS Math Function 에 &amp;lt;angle&amp;gt;의 무한 값을 도입하면서 삽질한 기록이다.</summary></entry><entry><title type="html">Chromium 새로 개발되는 DOM API Seamless Transitions</title><link href="https://devsdk.github.io/ko/development/2021/03/11/ChromiumSeamlessTransitions.html" rel="alternate" type="text/html" title="Chromium 새로 개발되는 DOM API Seamless Transitions" /><published>2021-03-11T09:00:02+09:00</published><updated>2021-03-11T09:00:02+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/11/ChromiumSeamlessTransitions</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/11/ChromiumSeamlessTransitions.html">&lt;p&gt;오랜만에 patch들을 pull 받고 빌드하는 시간 동안 Chromium에서 SPA(Single Page App)를 위한 API가 어떤 것들이 있을까 라는 생각으로 feature들을 살펴보던 도중 흥미로운 기능이 현재 막 개발되고 있어서 글을 쓴다.&lt;/p&gt;

&lt;p&gt;2021.03.11 기준으로 아직 한창 개발되고 있는 feature이다. Android Webview와 깊은 연관이 있는 만큼 나중에 완성되면 Google IO 같은 데서 한번 말하지 않을까 라는 생각이 든다. (아닐 수도 있다. ㅎㅎ..)&lt;/p&gt;

&lt;p&gt;아직은 비표준인 것 같다. 아마 표준이 되지 않을까 생각된다. &lt;a href=&quot;https://github.com/WICG/proposals/issues/12&quot;&gt;WICS Proposal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/runtime_enabled_features.json5&quot;&gt;runtime flag&lt;/a&gt; 에 따르면 프로토타입은 나온것 같으니 한번 사용해보도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110785255-1436fb00-82ae-11eb-8fe2-5cdad35393b8.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;tltr&quot;&gt;TL;TR&lt;/h1&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;changeBodyBackground&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;background: blue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;handleTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;prepare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;rootTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;reveal-left&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;changeBodyBackground&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;documentTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;transition finished&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;트렌지션을 시도하기 전 그 화면을 texure로 렌더링해놓는다. 이 작업을 prepare라고 한다. 이 작업은 비동기적으로 실행되며 GPU 자원을 사용할 수 있다. 그런 뒤 Transition을 하면 렌더링해놓은 텍스쳐 뒤로/앞으로 DOM을 렌더링한다. 그런 뒤 요청한 방식대로 그 이미지를 제거한다. (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reveal-right&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;문서의 motivation쪽을 보니 transition에 부족한점이 많아서 SPA를 혹은 MPA를 위해 시작했다고 한다.&lt;/p&gt;

&lt;h1 id=&quot;example&quot;&gt;Example&lt;/h1&gt;

&lt;p&gt;개발하고 계신 분의 &lt;a href=&quot;https://github.com/vmpstr/shared-element-transitions/blob/main/sample-code/page_transition_spa.html&quot;&gt;example&lt;/a&gt;을 실행해본다. 실행조건은 pull 받은 시점의 &lt;a href=&quot;https://chromium.googlesource.com/chromium/src.git/+/d6485e20161bf3590e295575e320ef7feca7e665&quot;&gt;HEAD&lt;/a&gt;에서 빌드한 content_shell이다. 실행 커멘드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;./content_shell --enable-features=DocumentTransition test.html&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;아무래도 Under Construction이라서 직접 실행해 보니 빌드 환경이 동일하지 않은 것 인지 크레시가 난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110784763-6deaf580-82ad-11eb-9b92-17c0ef91beaf.gif&quot; alt=&quot;Peek 2021-03-11 21-03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;explode와 implode는 그래도 잘 동작한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110785324-2f096f80-82ae-11eb-8d00-760efae46532.gif&quot; alt=&quot;Peek 2021-03-11 21-02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이걸 만들고 계신 분이 데모로 올리셨던 영상을 따왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110786952-1dc16280-82b0-11eb-96ac-b28a7f7aa14f.gif&quot; alt=&quot;Peek 2021-03-11 21-23&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디테일은 아래 문서 및 모노레일에서 볼 수 있다. 다시 한 번 말하지만, 아직 개발이 진행 중인 기능이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://crbug.com/1150461&quot;&gt;https://crbug.com/1150461&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/vmpstr/shared-element-transitions&quot;&gt;https://github.com/vmpstr/shared-element-transitions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.google.com/document/d/1UmAL_w5oeoFxrMWiw75ScJDQqYd_a20bOEWfbKhhPi8&quot;&gt;https://docs.google.com/document/d/1UmAL_w5oeoFxrMWiw75ScJDQqYd_a20bOEWfbKhhPi8&lt;/a&gt;&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="CSS" /><summary type="html">오랜만에 patch들을 pull 받고 빌드하는 시간 동안 Chromium에서 SPA(Single Page App)를 위한 API가 어떤 것들이 있을까 라는 생각으로 feature들을 살펴보던 도중 흥미로운 기능이 현재 막 개발되고 있어서 글을 쓴다.</summary></entry><entry><title type="html">CSS @counter-style</title><link href="https://devsdk.github.io/ko/development/2021/03/11/CSSCounterStyle.html" rel="alternate" type="text/html" title="CSS @counter-style" /><published>2021-03-11T09:00:01+09:00</published><updated>2021-03-11T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/11/CSSCounterStyle</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/11/CSSCounterStyle.html">&lt;p&gt;오늘 아침 Blink-Dev Group에서 I2S를 보고 재밌는 CSS Feature가 Ship되는걸 보아서 간단히 메모한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110739167-fea4df80-8273-11eb-8cf5-0cae939349db.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;꾸준히 내가 진행중인 CSS Feature를 리뷰해주고 계신 Xiaocheng이 ship 한 기능이다.&lt;/p&gt;

&lt;p&gt;Firefox에서는 2014년부터 이미 지원되는 기능이였던 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/@counter-style&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://drafts.csswg.org/css-counter-styles-3/#the-counter-style-rule&quot;&gt;표준에 따르면&lt;/a&gt; 아주다양한 방식으로 사용될 수 있을 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@counter-style&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;footnote&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;symbolic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;'*'&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;⁑&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;†&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;‡&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;suffix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;It&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;produce&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;lists&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;that&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;look&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;like&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;   &lt;span class=&quot;nt&quot;&gt;One&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;⁑&lt;/span&gt;   &lt;span class=&quot;nt&quot;&gt;Two&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;†&lt;/span&gt;   &lt;span class=&quot;nt&quot;&gt;Three&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;‡&lt;/span&gt;   &lt;span class=&quot;nt&quot;&gt;Four&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;Five&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;⁑⁑&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;Six&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110739184-082e4780-8274-11eb-8719-9f41aec52665.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;근 시일내 당장 쓸 수는 없고, M91버전부터 사용할 수 있을 것 같다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><category term="CSS" /><summary type="html">오늘 아침 Blink-Dev Group에서 I2S를 보고 재밌는 CSS Feature가 Ship되는걸 보아서 간단히 메모한다.</summary></entry><entry><title type="html">Chrome 90 beta is coming, 어떤 기능이 들어올까?</title><link href="https://devsdk.github.io/ko/development/2021/03/08/chrome90.html" rel="alternate" type="text/html" title="Chrome 90 beta is coming, 어떤 기능이 들어올까?" /><published>2021-03-08T09:00:01+09:00</published><updated>2021-03-08T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/08/chrome90</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/08/chrome90.html">&lt;p&gt;Blink Dev-Group에 있으면서, 새로운 Chrome 버전 M90의 beta가 3월 11일에 나온다고 한다. Chromium의 어떤 새로운 기능들이 Chrome 에 도입될 수 있을지 알아보도록 한다.&lt;/p&gt;

&lt;p&gt;이 내용은 &lt;a href=&quot;https://docs.google.com/spreadsheets/d/155euqrhdqVhtbAID7ydaUPjBstLIYZ4PJkpFmqJ6j-o/edit#gid=215381875&quot;&gt;What’s Shipping&lt;/a&gt; 시트를 참고하였다.&lt;/p&gt;

&lt;p&gt;각각 기능은 한 줄에서 두 줄 정도로 이해한 만큼 쓰도록 한다. &lt;em&gt;몇 가지는 생략할 수도 있다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;특히 인상 깊은 건 우선순위 기반 스케쥴러의 도입이 아닐까 싶다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6556060494069760&quot;&gt;Seeking past the end of a file in the File System Access API&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;파일의 끝을 지나서 write를 할 때 reject 대신, 파일을  0x00(NUL)값과 함께 확장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5676695065460736&quot;&gt;StaticRange constructor&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Highlight API Explained를 위한 feature라는데, 아직 잘 모르겠다 WHATWG 스팩에도 &lt;a href=&quot;https://dom.spec.whatwg.org/#interface-staticrange&quot;&gt;constructor만 명시되어 있다.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5710618575241216&quot;&gt;Subresource loading with Web Bundles&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다수의 리소스를(e.g. Web Bundles) 번들로 묶을 수 있는 포멧을 사용하여 많은 수의 리소스들을 효율적으로 로드할 수 있는 방향을 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5737185317748736&quot;&gt;Support specifying width/height on &amp;lt;source&amp;gt; elements for &amp;lt;picture&amp;gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&amp;lt;picture&amp;gt;에 대하여 &amp;lt;source&amp;gt;를 이용해 width와 height를 제공함으로써 image의 화면 비율을 계산할 수 있게 해준다.&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;picture&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;source&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;srcset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image.jpg&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;640&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;480&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width: 100%; height: auto;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/picture&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5370811722498048&quot;&gt;URL protocol setter: New restrictions for file URLs&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;파일에 혹은 파일로 부터 URL이 변경될 때 발생하는 edge case를 바로잡음.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5658873031557120&quot;&gt;Use :focus-visible in the default UA style sheet&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Chromium의 기본 UA스타일을 포커스 인디케이터를 위해 :focus pseudo-class를 사용하는 것 대신 :focus-visible를 사용함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/4756734233018368&quot;&gt;WebAssembly Exception Handling&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;웹 어셈블리의 exception handling 도입.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5086267630944256&quot;&gt;WebAudio: OscillatorOptions.periodicWave is not nullable&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;더이상 periodicWave의 맴버 OscillatorOptions을 null로 설정할 수 없음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5704707957850112&quot;&gt;WebXR AR Lighting Estimation&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;사이트가 WebXr 세션 내에서 environmental lighting의 근사치를 쿼리할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5742647199137792&quot;&gt;WebXR Depth API&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;WebXRDevice의 Deapth Buffer로 접근할 수 있게 해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/5045313003847680&quot;&gt;getCurrentBrowsingContextMedia()&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;navigator.mediaDevices.getCurrentBrowsingContextMedia() 이 api를 통해 현재 탭에서의 MedaiStream을 캡처할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6031161734201344&quot;&gt;Main thread Scheduling APIs: Prioritized scheduler.postTask&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;개발자가 브라우져의 네이티브 스케쥴러를 통해 3개의 우선순위(user-blocking, user-visible, and background)를 가지는 테스크(javscript callbak)를 스케줄 할 수있게 해준다. (성능과 관련 있음)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/5499415634640896&quot;&gt;MediaStreamTrack Insertable Streams (a.k.a. Breakout Box)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;카메라의 출력, 마이크, 화면 캡처 또는 코덱의 디코더 부분과 코덱의 디코더 입력과 같은 MeadiaStreamTracks에서 전달하는 raw 미디어를 조작하기 위한 API&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5670287242690560&quot;&gt;Protect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-protobuffer&lt;/code&gt; via Cross-Origin-Read-Blocking&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;speculative execution 공격으로부터 ‘application/x-protobuffer’을 지킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://chromestatus.com/features/5694001745231872&quot;&gt;Read Chrome device attributes&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Device Web API의 일부분인 Device attribute를 query 할 수 있게 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6123640410079232&quot;&gt;Relative indexing method for Array, String, and TypedArrays&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;at() 함수 추가.&lt;/p&gt;

    &lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Returns 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5633112799182848&quot;&gt;AbstractRange superclass&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;StaticRange와 Range를 추상화 함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5638444178997248&quot;&gt;Add support for CSS properties “overflow: clip” and “overflow-clip-margin”&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#values&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#values&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/6206321818861568&quot;&gt;AV1 Encoder&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Chrome desktop을 위한 AV1 인코더 도입&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5671807392677888&quot;&gt;Clipboard: read-only files support&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5733828735795200&quot;&gt;CORS-RFC1918: CORS restrictions on internet-to-intranet connections.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5682100885782528&quot;&gt;CSS aspect-ratio interpolation&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;비율에 대한 보간 내용인 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6537562418053120&quot;&gt;Custom state pseudo class&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Custom Element의 state를  :state() psuedo class에서 접근 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><summary type="html">Blink Dev-Group에 있으면서, 새로운 Chrome 버전 M90의 beta가 3월 11일에 나온다고 한다. Chromium의 어떤 새로운 기능들이 Chrome 에 도입될 수 있을지 알아보도록 한다.</summary></entry><entry><title type="html">Reflow, Repaint Chromium 입장에서 살펴보기 (왜 transform은 빠를까?)</title><link href="https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint.html" rel="alternate" type="text/html" title="Reflow, Repaint Chromium 입장에서 살펴보기 (왜 transform은 빠를까?)" /><published>2021-03-08T09:00:00+09:00</published><updated>2021-03-08T09:00:00+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint.html">&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;Reflow와 Repaint에 대해서 면접 단골 질문이라고 해서 조금 깊이 살펴보도록 한다.&lt;br /&gt;
최적화와 관련된 이야기며, Message Queue (event loop)에 대한 이해가 필요하다. 그 내용은 &lt;a href=&quot;https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html&quot;&gt;여기서&lt;/a&gt; 볼 수 있다. 요약하자면, 만약 js 태스크와 같은 작업이 message queue에서 선점되어 animation frame이 늦어지는 경우 사용자에게 애니메이션이 끊기는 등의 경험을 줄 수 있다. 이런 것을 피하고 최적화할 수 있는 방법에 대해 알아본다.&lt;/p&gt;
&lt;h3 id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Reflow, Repaint, Layout, Paint, Composite&lt;/li&gt;
  &lt;li&gt;CSS Animation&lt;/li&gt;
  &lt;li&gt;왜 transform을 이용하면 빠를까?&lt;/li&gt;
  &lt;li&gt;tracing으로 알아보는 실제 layout, paint&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;1-reflow-repaint-layout-paint-composite&quot;&gt;1. Reflow, Repaint, Layout, Paint, Composite&lt;/h1&gt;

&lt;p&gt;이 글에서 Reflow와 Repaint는 Layout과 Paint와 대응된다. Reflow와 Repaint는 firefox의 “Gecko” 진영에서 주로 사용하고, layout과 paint는 safari의 webkit과 chromium의 blink 진영에서 사용한다. 혼동을 피하고자 layout과 paint로 설명하도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;layout은-무엇일까&quot;&gt;Layout은 무엇일까?&lt;/h3&gt;

&lt;p&gt;웹브라우져에는 사실 DOM Tree 말고 렌더 스테이지에서 중요한 역할을 하는 트리가 하나 더 있다. 화면에 실제로 그리기 위해 박스모델과 좌표 계산이 끝난 상태인 Layout Tree라는 것을 관리한다. 이는 DOM Tree와 대응되지 않으며, display : none인 경우에는 아예 Layout Tree에 제외되기도 한다. 이러한 내용이 궁금하다면 &lt;a href=&quot;https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_528&quot;&gt;여기&lt;/a&gt;를 살펴보면 좋을 것 같다. layout 단계 혹은 reflow는 &lt;strong&gt;이 트리를 전체 혹은 일부를 새로 구성하는 것&lt;/strong&gt;을 의미한다. layout이 발생한다는 경우에 대해서는 &lt;a href=&quot;https://sites.google.com/site/getsnippet/javascript/dom/repaints-and-reflows-manipulating-the-dom-responsibly&quot;&gt;이곳에서&lt;/a&gt; 리스트업을 하지만 브라우져 레벨에서 &lt;strong&gt;“항상” layout이 발생하는 것은 아니다.&lt;/strong&gt; 예로 CSS Animation을 들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;paint는-무엇일까&quot;&gt;Paint는 무엇일까?&lt;/h3&gt;

&lt;p&gt;위에서 만든 LayoutTree를 순회하며 Paint Command를 만들고 &lt;a href=&quot;https://skia.org/&quot;&gt;SKIA&lt;/a&gt; 레스터라이저한테 전달하는 단계이다.  이를  추상화하고 줄여서 설명하면 &lt;strong&gt;Layout Tree를 화면에 그리는 단계&lt;/strong&gt;라고 이해해도 좋을 것 같다. 여기서 layout 트리에 대응되는 computed style에서 color와 같은 값을 가져와서 화면을 그리게 된다.
 이 단계 또한 매우 방대하며, 관심 있다면 &lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/paint/README.md#Current-compositing-algorithm-CompositeBeforePaint&quot;&gt;이 문서&lt;/a&gt;를 보도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;composite&quot;&gt;Composite?&lt;/h3&gt;

&lt;p&gt;Composite은 각각의 분리 가능한 레이어를 분리해서 처리한 뒤 합성하는 것이다. 거시적인 관점에서 &lt;strong&gt;Composite는 Main Thread (Message Queue)에서 벗어나서 다른 Thread Flow를 가지고 화면을 업데이트&lt;/strong&gt; 할 수 있다. 즉 비동기적으로 실행된 후 기존 레이어에 합성된다. 주로 animation과 scroll 등등에서 활용되며, 다른 Thread Flow를 가지기 때문에 main thread에서 block이 일어나도 composite만 사용하는 애니메이션은 계속 재생될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110417527-1dbb3a00-80d9-11eb-9724-e26417c8324d.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;Composition example from &lt;a href=&quot;https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_1213&quot;&gt;Life of Pixels&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-css-animation&quot;&gt;2. CSS Animation&lt;/h1&gt;

&lt;p&gt;CSS Animation은 공짜가 아니며 브라우져의 리소스를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://csstriggers.com/&quot;&gt;https://csstriggers.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 사이트는 CSS Animation이 렌더 스테이지에서 어떤 단계를 trigger 하는지 보여준다.&lt;/p&gt;

&lt;p&gt;여기서 Layout &amp;gt; Paint &amp;gt; Composite 순으로 cost가 높으며 composite만 있다면 Message Queue와 무관하게 동작하므로 매우 좋은 애니메이션 타겟이 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276915-8641e280-8017-11eb-8f9d-777e61cde490.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276931-8f32b400-8017-11eb-8b37-f3a5209dd077.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;width의 cost는 Layout, Paint, Composite를 전부 사용한다. 따라서 꽤 높은 비용이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276946-98bc1c00-8017-11eb-9929-2508783b42b0.png&quot; alt=&quot;Untitled 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;background-color는 paint, composite를 사용한다.&lt;/p&gt;

&lt;h1 id=&quot;3-왜-transform을-이용하면-빠를까&quot;&gt;3. 왜 transform을 이용하면 빠를까?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276963-a2458400-8017-11eb-8c3e-029f7f5c0b3c.png&quot; alt=&quot;Untitled 4&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276965-a376b100-8017-11eb-962b-e7945a3dd8c2.png&quot; alt=&quot;Untitled 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우리는 같은 역할을 하는 두 가지의 코드를 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    .b &lt;span class=&quot;si&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transform: translateX(200px)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;position:relative;left:200px&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276977-ad001900-8017-11eb-9022-42350b5a8555.png&quot; alt=&quot;Untitled 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 코드는 완전히 화면에 동일한 결과를 내놓는다. 하지만 내부적으로 다르게 동작한다.&lt;/p&gt;

&lt;p&gt;컴퓨터는 그래픽을  matrix의 곱으로 표현한다. (&lt;a href=&quot;http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/&quot;&gt;OpenGL examples&lt;/a&gt;) 이는 OpenGL, DirectX 등에 반드시 사용되며 GPU는 이런 연산을 빠르게 하기 위해 설계되었다.&lt;/p&gt;

&lt;p&gt;transform을 사용한 예시중 첫번째 div는 최종 composite에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Transformation_matrix&quot;&gt;transformation matrix&lt;/a&gt;를 통해 렌더링 되기 전 composite thread에서 GPU의 도움을 받아 계산된다.  아주 빠른 연산이 비동기적으로 일어나 매우 빠른 속도를 보여준다.  어떤 연산이 일어나는지는 &lt;a href=&quot;https://drafts.csswg.org/css-transforms/#mathematical-description&quot;&gt;표준을&lt;/a&gt; 참고하자. 심지어 Main Thread가 다른 태스크에 의해 block 되어도 재생된다.&lt;/p&gt;

&lt;p&gt;left를 사용한 아래 예시는 layout→composite.assign-&amp;gt;paint의 절차를 모두 밟게 된다. 즉 애니메이션으로 사용되기엔 꽤 비싼 cost를 가지고 있다는 소리다.
(Paint → Composite 는 현재 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=471333&quot;&gt;Chromium의 주요 프로젝트중&lt;/a&gt; 하나이다. CAP (Composition After Paiting)이라고 불린다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110435489-6c2b0180-80f6-11eb-9c35-82824d8ad351.gif&quot; alt=&quot;Peek 2021-03-09 16-40&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 즐거운 결론을 낼 수 있다. animation에서 만약 같은 결과를 내는 코드라면 &lt;strong&gt;composite만 사용하는 애니메이션 (i.e.transform)&lt;/strong&gt;을 애용하자.&lt;/p&gt;

&lt;h1 id=&quot;4-tracing으로-알아보는-실제-layout-paint&quot;&gt;4. Tracing으로 알아보는 실제 layout, paint&lt;/h1&gt;

&lt;p&gt;아래부터의 내용은 chromium/chrome의 동작 구조를 직접 살펴보며 위에서 이야기한 내용을 눈으로 봐볼 것이다.&lt;/p&gt;

&lt;p&gt;아래는 width를 이용한 animation을 tracing 한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277005-c0ab7f80-8017-11eb-9b93-6fa9b7769b5e.png&quot; alt=&quot;Screenshot_from_2021-03-08_11-45-14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CrRendererMain에 바코드처럼 빼곡하게 있는 것들이 바로 layout→paint 그리고 composite를 트리거 하는 단계이다.&lt;/p&gt;

&lt;p&gt;저 바코드의 줄 하나를 확대하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277012-c608ca00-8017-11eb-999d-aa8f220241a2.png&quot; alt=&quot;Screenshot_from_2021-03-08_13-45-51&quot; /&gt;&lt;/p&gt;

&lt;p&gt;트레이스가 기록된 저 상자는 c++ 구현과 1대1로 대응되며, 필요하다면 소스코드를 볼 수 있다. 이 내용을 보면 &lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/frame/local_frame_view.cc;l=3312;drc=3c992b98c58db034eb5af6bc51aac6fb1939d571&quot;&gt;LocalFrameView::UpdateStyleAndLayoutIfNeededRecursive()&lt;/a&gt;이 호출됨으로써 layout과 paint가 끊임없이 일어난다는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;만약 DOM Tree의 깊이가 깊어진다면 그만큼의 recursion 호출이 발생한다.&lt;/p&gt;

&lt;p&gt;그렇다면 반대로 transform을 사용한 경우는 어떤 트레이싱을 볼 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277028-cdc86e80-8017-11eb-87dc-550b7e53f85a.png&quot; alt=&quot;Untitled 6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞에 빼곡하게 있는 것은 마우스 때문에 발생한 animation이고 실제로 trigger 돼서 화면에 보인 것은 갑자기 빈 공간이 생기는 부분부터 이다. 여기서 compositor는 전달받은 역할을 &lt;strong&gt;비동기적&lt;/strong&gt;으로 실행하는 것을 볼 수 있다. 이런 이유 때문에 composite만 사용하는 애니메이션은 alert와 같이 main thread가 block 된 상황에서도 정상적으로 렌더 수행이 진행된다.&lt;/p&gt;

&lt;p&gt;오타/질문/틀린 내용이 있다면 언제든지 피드백 바란다. :)&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Web" /><category term="HTML" /><category term="CSS" /><category term="Optimization" /><summary type="html">Overview</summary></entry><entry><title type="html">React 파헤치기, 리액트가 동작하는 방법 (overview)</title><link href="https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview.html" rel="alternate" type="text/html" title="React 파헤치기, 리액트가 동작하는 방법 (overview)" /><published>2021-03-07T09:00:00+09:00</published><updated>2021-03-07T09:00:00+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview.html">&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;Chromium에서 활동하면서 웹브라우져가 어떻게 동작하는지는 어느 정도 (완벽할 순 없다고 생각한다.. 너무 거대하다.)알고 있다.&lt;/p&gt;

&lt;p&gt;그리고 리액트를 사용하는 방법을 알고 있다.&lt;/p&gt;

&lt;p&gt;그러나 React-DOM과 내부 사항들에 대해서는 너무 추상적으로 알고있거나 모른다고 생각한다.&lt;/p&gt;

&lt;p&gt;그래서 리액트와 브라우져 사이의 블랙박스가 너무 궁금하여 몇몇 가지의 문서와 react 소스코드를 뒤졌던 결과 어느정도 오버뷰가 나올 것 같아서 블로그에 정리하도록 한다.&lt;/p&gt;

&lt;p&gt;하지만 아직 완전히 모든 소스코드를 본 것은 아니며, 생략되거나, 틀릴 수도 있는 내용이다.&lt;/p&gt;

&lt;p&gt;언제든지 피드백을 받는다면 반영하도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232600-03128500-7f62-11eb-8f38-c3e5015e0303.png&quot; alt=&quot;Untitled (2)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글을 쓰기 시작한 큰 이유다.&lt;/p&gt;

&lt;p&gt;중간에 블랙박스가 너무 많아 실제로 어떻게 동작하는지 그리고 내가 더 생각해 볼 수 있는 다른 방향은 없는지 알기가 어려웠다. 덧붙이자면 말 그대로 &lt;strong&gt;마법상자&lt;/strong&gt; 가 있어서 이를 화면에 그려주고 상태를 변경시키는 작업을 하는 느낌을 받았다.&lt;/p&gt;

&lt;p&gt;지금부터 그 마법상자를 열어보도록 한다.&lt;/p&gt;

&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232607-09a0fc80-7f62-11eb-9780-6bd6e032638c.png&quot; alt=&quot;Untitled (3)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;글 내용이 뒤죽박죽이라, 아래의 내용을 바탕으로 위의 이미지를 정리하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;콜백에 의해 fiber 스케쥴러가 업데이트되고, 그 스케쥴러는 fiber들의 테스크를 실행하여 산출물인 업데이트 트리(WorkInProgress or Finished)를 Commit을 통해 dom에 반영한다.&lt;/p&gt;

&lt;h1 id=&quot;detail&quot;&gt;Detail&lt;/h1&gt;

&lt;p&gt;React는 다음과 같은 JSX 문법을 통해 “선언적” 인 구현을 권장한다. (&lt;a href=&quot;https://reactjs.org/docs/jsx-in-depth.html&quot;&gt;리엑트 공식 문서&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;리액트를 처음 썼을때 가장 놀랐던 부분이기도 하다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MyButton&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;blue&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;shadowSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  Click Me
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MyButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공식문서에서도 설명하듯이, 이는 컴파일러에 의해 (babel-loader?) 다음과 같이 코드로 변경된다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;MyButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;shadowSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Click Me&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 함수를 거치면서 아래의 계층을 가진 object 형식으로 반환이 된다.&lt;/p&gt;

&lt;p&gt;DOM과 유사하게 children이 있고 여러 가지 정보들을 담고 있다.&lt;/p&gt;

&lt;p&gt;(위 소스코드와 아래의 결과와는 다르다. 위는 공식문서에서 가져왔다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232637-3d7c2200-7f62-11eb-930c-b90f62771320.png&quot; alt=&quot;Untitled (4)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 우리는 위 내용을 ReactDOM.render를 통해 react-dom에 전달한다. react-dom은 위 정보를 fiber 라는 형태로 관리한다.&lt;/p&gt;

&lt;p&gt;Fiber는 react의 element는 1대1로 대응되면서 여러 내부 정보를 가지고 있는 구조이며 react의 작업의 단위가 되기도 하고, 자체적인 스택프레임을 가지는 일의 주체라고 한다.&lt;/p&gt;

&lt;p&gt;reconciliation 작업에 사용된다. (fiber는 &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-reconciler/src&quot;&gt;react-reconciler&lt;/a&gt; 패키지에서 관리한다.) 내부적인 reconciliation 알고리즘은 O(n)의 휴리스틱 한 알고리즘이라고 한다. 공식문서에서는 개발자가 key를 줌으로써 알고리즘에 힌트를 줄 수 있다는 중요한 내용이 담겨있다.&lt;/p&gt;

&lt;p&gt;그렇다면 fiber는 어떤 역할을 할까?&lt;/p&gt;

&lt;p&gt;너무 &lt;a href=&quot;https://github.com/facebook/react/blob/7df65725ba7826508e0f3c0f1c6f088efdbecfca/packages/react-reconciler/src/ReactFiber.new.js#L111&quot;&gt;필드가 많아서&lt;/a&gt; 봤던 article의 내용 중 일부를 빌리자면 이렇게 생겼다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;stateNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;alternate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;chiled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;updateQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;memoizedState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;pendingProps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;memoizedProps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;effectTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;nextEffect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tree 형태로 내용을 기반으로 순회하면서 WorkInProgress 트리를 만들게 된다. 그리고 WorkInProgress는 이후 화면으로 반영될 트리를 의미한다. 여기서 자주 보던 녀석들이 있는데 React.memo에 의해 property를 기록할 때 실제로 반영되는 필드인 memoizedProps와, 공식문서에서도 설명하던 key 필드이다. 이 필드는 reconciliation 작업에서 휴리스틱한 탐색에 주요 factor로 사용된다.&lt;/p&gt;

&lt;p&gt;또한, 자체적인 스택프레임을 가지고 있다는 부분이 정말 재밌는데, &lt;a href=&quot;https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html&quot;&gt;이벤트루프의 동작 방식&lt;/a&gt; 에 따르면 js execution이 길어지면 다음 태스크가 계속 기다려야 하므로 사용자경험이 안 좋아(애니메이션이 끊긴다거나, 터치가 씹힌다거나 등) 질 수 있는 것을 방지하기 위해 도입된 방식이다.&lt;/p&gt;

&lt;p&gt;fiber한테는 자체적인 실행 스택(work queue로 관리되는 듯해 보인다)을 가지고 자체적인 priority 기반 scheduler를 이용하여 태스크를 쪼개서 관리하면서 Message Queue가 다른 이벤트를 처리할 수 있도록 하여 Message Queue가 다른 task를 실행할 수 있도록 해주는 것 같다. 여기서 스케쥴러는 requestIdleCallback (requestAnimationframe?) API에 의해 호출된다.&lt;/p&gt;

&lt;p&gt;이제 react-dom의 마지막 산출 단계에서는 render 페이즈와 commit 페이즈로 나뉘게 된다.&lt;/p&gt;

&lt;p&gt;렌더페이즈는 위에서 서술했듯이 current 트리에서 WorkInPregress를 생성하는 (변경사항들을 찾아서 렌더링할 재료를 만드는) 단계라면 commit 페이즈는 말 그대로 화면에 그리도록 제출하는 단계이다. 여기서 didComponentMount 와 같은 lifecycle 함수들이 호출된다. (렌더 페이즈에서 호출되든 lifecycle 함수들은 UNSAFE_ 태그를 달고 있다고 한다.)&lt;/p&gt;

&lt;p&gt;실제로 react 소스코드에서 &lt;a href=&quot;https://github.com/facebook/react/blob/c7b4497988e81606f1c7686434f55a49342c9efc/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1350&quot;&gt;commitUpdate&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/react/blob/c7b4497988e81606f1c7686434f55a49342c9efc/packages/react-dom/src/client/ReactDOMHostConfig.js#L451&quot;&gt;commitPlacement&lt;/a&gt; 등등을 통해 dom에 반영하는 것을 찾아볼 수 있다. 내부적으론 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore&quot;&gt;insertBefore&lt;/a&gt; 와 같은 함수를 호출하는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;위 내용은 글 초반에 말했듯이, 소스코드레벨에서 완전한 이해를 바탕으로 쓴 글이 아니다.&lt;/p&gt;

&lt;p&gt;몇몇 가지의 글을 보고, 소스를 뒤적이다가 오버뷰를 만들면 좋을 것 같다는 생각에 작성했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;refs&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react&quot;&gt;https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;https://github.com/acdlite/react-fiber-architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/lifeofapixel&quot;&gt;http://bit.ly/lifeofapixel&lt;/a&gt;&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="React" /><category term="Web" /><category term="React-DOM" /><summary type="html">Motivation</summary></entry><entry><title type="html">Chrome Inspector로 화면이 왜 느린지 찾아보기</title><link href="https://devsdk.github.io/ko/development/2021/03/06/ChromeInspectorPerformnace.html" rel="alternate" type="text/html" title="Chrome Inspector로 화면이 왜 느린지 찾아보기" /><published>2021-03-06T09:00:01+09:00</published><updated>2021-03-06T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/06/ChromeInspectorPerformnace</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/06/ChromeInspectorPerformnace.html">&lt;p&gt;DFD를 구현하고 항상 들던 의문이 있었다.&lt;/p&gt;

&lt;p&gt;화면을 구성하고 어느 순간부터 main 화면에서 로딩이 늦는것&lt;/p&gt;

&lt;p&gt;다루는 데이터가 그렇게 많은 편이 아닌데도 chart나 render 부분이 느린 것 같다는 생각이 종종 들었다. 물론 사용하는 데 전혀 지장은 없지만 UX 적으로 조금 개선할 방향을 찾아보고 싶었다.&lt;/p&gt;

&lt;p&gt;가장 먼저 해본 것은, React Profiler를 사용해 확인하는 것이었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197436-fcffa400-7e8e-11eb-9df0-f3b2367aadae.png&quot; alt=&quot;Screenshot_from_2021-03-06_14-49-03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 프로파일러에서는 계속 LOLGameElement 가 느린 것 같아!! 라고 이야기하고 있었다.&lt;/p&gt;

&lt;p&gt;사실 살펴보면 시간 단위가 문제가 될 만큼 느리지 않았다. 즉 다른 곳이 느리거나, 놓치고 있는 게 있다는 것일 것이라는 가설을 세우게 되었다. 가장 느린 구간이 70ms라니, 이는 화면에 보이는 것보다 느린 것이 아니다.&lt;/p&gt;

&lt;p&gt;또한 얻는 정보가 한정되어있다는 생각이 많이 들었다. 
(이는 내 react profiler 사용이 서툴러서 그런 것 일수도 있다.)&lt;/p&gt;

&lt;p&gt;다른 방법을 취해보기로 했다.&lt;/p&gt;

&lt;p&gt;chrome://tracing에 들어가서 전체 렌더 시간에 일어나는 일들을 Web Developer Mode로 트레이싱 하였다.&lt;/p&gt;

&lt;p&gt;웹 개발자 모드로 한 이유는 그 정보로도 충분할 가능성이 높기 때문이다. 만약 필요해서 더 깊이 들어가야 한다면 Chromium flag를 enable 한 뒤 빌드하여 전체모드 트레이싱 하면 skia 렌더 커멘드 (네모 그리기가 매우 많다.) 단위까지 조사할 수 있다&lt;/p&gt;

&lt;p&gt;트레이싱 도구를 사용한 이유는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;어떤 &lt;strong&gt;렌더스테이지&lt;/strong&gt; 에서 시간을 쓰고 있는지 (ex, composition, layout, javascript execution, style compute recursion … )&lt;/li&gt;
  &lt;li&gt;디버깅에는 가능성을 최대한 열어두고 소거하는 것을 좋아한다.&lt;/li&gt;
  &lt;li&gt;단계적인 접근 방법&lt;/li&gt;
  &lt;li&gt;만약 필요하면 C++ 네이티브 코드를 바로 볼 수 있게 제공받는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197458-07ba3900-7e8f-11eb-9760-ff918d830abe.png&quot; alt=&quot;Screenshot_from_2021-03-06_14-43-40&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일단 한눈에 들어온 정보는 v8이 가져가는 시간이 정말 많다는 점이었다.&lt;/p&gt;

&lt;p&gt;이 말은  javascript execution 쪽에서 느려짐을 의미한다. 여기서 다른 렌더 스테이지에서 느려지지 않는 것을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;이제 javascript execution을 추적하기 위해 insepcator를 이용하여 Performance 체크를 해보기로 했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197472-11dc3780-7e8f-11eb-8421-e4f1ec7361df.png&quot; alt=&quot;Screenshot_from_2021-03-06_15-03-22&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 느려지는 구간은 3가지 정도인 것 같고, 공통점을 찾아낼 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197480-202a5380-7e8f-11eb-9e22-f0b6ce9f7e02.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;apexchart 쪽에서 이러한 이벤트들이 모이고 모여 엄청 긴 시간을 가져가게 된 것이다.&lt;/p&gt;

&lt;p&gt;여기서 잠정적인 결론을 내릴 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apexchart를 제거하거나 optimize 하면 이 느려지는 것이 해결 될 것&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최적화를 위해 관련 정보를 찾아보고 문서를 봐봤지만, Apexchart의 고질적인 문제인 것 같다는 생각이 든다.&lt;/p&gt;

&lt;p&gt;일단 꽤 자주 퍼포먼스이야기가 (i.e. &lt;a href=&quot;https://github.com/apexcharts/vue-apexcharts/issues/208&quot;&gt;github issue&lt;/a&gt;) 보였다.&lt;/p&gt;

&lt;p&gt;또한 내가 apexchart를 잘못 사용한 것인가? 라는 의문을 가지고 공식 홈페이지의 live demo에 가서 퍼포먼스 체크를 진행했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197498-39330480-7e8f-11eb-9547-62cb0c3a33f1.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공식 홈페이지의 Demo에서 데이터가 그리 많지 않음에도 꽤 많은 시간을 apexchart가 가져간다.&lt;/p&gt;

&lt;p&gt;아마도 고질적인 문제가 아닐까 조심스럽게 추측하면서, apexchart를 대체할 방법을 생각해 보면 좋을 것 같다는 생각이 들었다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chrome" /><category term="Web" /><category term="Javascript" /><category term="Optimization" /><category term="Debugging" /><summary type="html">DFD를 구현하고 항상 들던 의문이 있었다.</summary></entry><entry><title type="html">SCL Notion Checklist generator 개발</title><link href="https://devsdk.github.io/ko/development/2021/03/06/IntroduceSCL.html" rel="alternate" type="text/html" title="SCL Notion Checklist generator 개발" /><published>2021-03-06T09:00:00+09:00</published><updated>2021-03-06T09:00:00+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/06/IntroduceSCL</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/06/IntroduceSCL.html">&lt;p&gt;아침 일찍 일어나서 취업준비를 위해 Chromium 커밋 리스트를 다시한번 훑어보는데 아뿔싸… 머지한 커밋중에 Commit Message와 코드가 다른 것을 보았다.&lt;/p&gt;

&lt;p&gt;아래는 커밋 메시지 중 일부분.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110193524-b488bc00-7e77-11eb-82eb-2b22114266cd.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래는 실제 코드&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110193525-b5b9e900-7e77-11eb-90f9-be68a9a97b18.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아무래도 패치셋이 진행되면서 이름을 바꾸게 되었는데, CR+2받고 그냥 머지시킨 것 같다.&lt;/p&gt;

&lt;p&gt;앞으로도 이런 실수를 안 하리라는 보장이 없기 때문에 scl이라는 간단한 프로젝트를 진행했다.&lt;/p&gt;

&lt;p&gt;아이디어는 다음과 같았다. “Commit Checklist를 패치별로 notion에 저장하면 편하지 않을까?”&lt;/p&gt;

&lt;p&gt;notion은 api를 아직 정식으로 제공하지 않는다.&lt;/p&gt;

&lt;p&gt;Private test 중이라고 하는데, 언제 열릴지 모르기 때문에 그걸 기다리기는 건 어려울 것 같다는 결론을 냈다.&lt;/p&gt;

&lt;p&gt;처음에는 golang으로 짜인 라이브러리가 보이길래, go언어로 짜다가 block(노션의 컨텐츠)를 생성하는 것이 없어 다른 방법을 찾아보았다. 그렇게 API를 따서 python 라이브러리로 만든 notion-py을 발견했는데, notion 대부분의 기능을 사용할 수 있어서 python으로 갈아타기로 했다.&lt;/p&gt;

&lt;p&gt;개발환경이 워낙 CLI와 가깝다 보니 CLI 기반으로 작성하였다.&lt;/p&gt;

&lt;p&gt;레포지토리 &lt;a href=&quot;https://github.com/DevSDK/scl&quot;&gt;https://github.com/DevSDK/scl&lt;/a&gt;&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Python" /><category term="Notion" /><category term="CLI" /><category term="Productivity" /><summary type="html">아침 일찍 일어나서 취업준비를 위해 Chromium 커밋 리스트를 다시한번 훑어보는데 아뿔싸… 머지한 커밋중에 Commit Message와 코드가 다른 것을 보았다.</summary></entry><entry><title type="html">Flux 아키텍처</title><link href="https://devsdk.github.io/ko/development/2021/03/03/FluxArchitecture.html" rel="alternate" type="text/html" title="Flux 아키텍처" /><published>2021-03-03T14:02:20+09:00</published><updated>2021-03-03T14:02:20+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/03/FluxArchitecture</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/03/FluxArchitecture.html">&lt;p&gt;이번 글에서는 면접 질문으로 들어왔던 Redux 써봤냐 → 그럼 flux 구조를 아느냐 에 대한 답변을 내 개인적으로 시원하게 하지 못해 아쉬움에 내용을 정리해 보도록 한다.&lt;/p&gt;

&lt;p&gt;Q: Flux 구조에 대해서 알고 계신 게 있나요?&lt;/p&gt;

&lt;p&gt;“사실 Flux는 들어만 보았고, 정확하게 어떤 것을 의미하는지는 기억하지 못합니다. 저는 이 구조가 글로벌 상태 관리를 하는 패턴이라고 알고 있습니다. 이 구조를 활용한 Redux를 사용하여 어플리케이션을 개발했는데~”.&lt;/p&gt;

&lt;p&gt;이번 기회에 Flux 구조에 대해 다시 한 번 공부해보도록 한다.&lt;/p&gt;

&lt;p&gt;3줄 요약부터 해보도록 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;FLUX는 MVC패턴과 같은 패턴의 한 일종이다.&lt;/li&gt;
  &lt;li&gt;단방향으로 데이터가 흐른다.&lt;/li&gt;
  &lt;li&gt;Redux와 같은 녀석들은 이러한 구조를 편하게 쓸 수 있게 해주는 것들이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;사실 위 3줄 요약보다 더 간단한 이미지가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109767232-93875780-7c3a-11eb-86f3-753e5c7a4674.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화살표는 데이터의 흐름을 의미한다.&lt;/p&gt;

&lt;p&gt;이미지에서 볼 수 있듯이 단방향으로 흐른다.&lt;/p&gt;

&lt;p&gt;그렇다면 만약 사용자가 인터렉션을 취해서 상태를 변경한다면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109767265-9f731980-7c3a-11eb-95fb-089ead36252c.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다시 dispatcher를 통해 데이터를 action을 이용해 보내게 된다.&lt;/p&gt;

&lt;h3 id=&quot;dispatcher&quot;&gt;Dispatcher&lt;/h3&gt;

&lt;p&gt;Dispatcher는 Flux 아키텍처에서 모든 데이터의 흐름을 관리한다.  액션을 분배하고 store에 콜백을 등록하는 등 간단한 메커니즘으로 동작한다.&lt;/p&gt;

&lt;p&gt;Action Creator가 새로운 action이 있다고 dispatch를 호출하면 어플리케이션의 모든 store는 action을 등록한 callback으로 전달받는다.&lt;/p&gt;

&lt;p&gt;아래는 dispatcher의 실제 구조이다.&lt;/p&gt;

&lt;div class=&quot;language-tsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TPayload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;invariant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_isDispatching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_startDispatching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_callbacks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_isPending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_invokeCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_stopDispatching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/Dispatcher.js#L180&quot;&gt;https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/Dispatcher.js#L180&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 설명대로 모든 callback을 invoke한다. (_invokeCallback함수에서 payload를 전달해준다.)&lt;/p&gt;

&lt;h3 id=&quot;store&quot;&gt;Store&lt;/h3&gt;

&lt;p&gt;스토어는 어플리케이션의 상태와 로직을 가지고 있다. Store라는 이름답게 상태를 저장하고 있다고 생각해도 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;store는 개별적인 도메인에서 상태를 관리해주는데 이는 스토어별로 dispatcher token을 별도로 할당하기 때문이다.&lt;/p&gt;

&lt;p&gt;이걸 조금 더 풀어쓰기 위해 flux 공식 문서에 따르면 “페이스북의 되돌아보기 비디오 편집기”는 트랙의 플레이 백 포지션 같은 정보를 TimeStore에 관리(트레킹) 하고 “이미지”는 ImageStore에서 관리하는 것을 말할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;action&quot;&gt;Action&lt;/h3&gt;

&lt;p&gt;Dispatcher는 action을 호출해 데이터를 불러오고 store로 전달할 수 있게 해주는 메서드를 제공한다.&lt;/p&gt;

&lt;p&gt;변경할 데이터가 담겨진 객체라고 이해해도 괜찮을 것 같다.&lt;/p&gt;

&lt;p&gt;이런식으로 생겼다.&lt;/p&gt;

&lt;div class=&quot;language-tsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;actionType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;city-update&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;selectedCity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;paris&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;view와-controller-view&quot;&gt;View와 Controller-View&lt;/h3&gt;

&lt;p&gt;store로부터 이벤트를 받으면 데이터를 비교하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setState()&lt;/code&gt;  또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forceUpdate()&lt;/code&gt; 매서드를 호출하게 되어 화면이 갱신된다.&lt;/p&gt;

&lt;p&gt;컨트롤러 뷰는 자식에게도 데이터를 흘려보낸다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/container/FluxContainer.js#L187&quot;&gt;https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/container/FluxContainer.js#L187&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여기서 그 역할을 하는 것 같다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;redux&quot;&gt;Redux?&lt;/h2&gt;

&lt;p&gt;Redux는 Reducer + Flux 라는 뜻을 가지고&lt;/p&gt;

&lt;p&gt;Flux에서 간소화시키고 간단한 사용을 주제로 개발되었다고 한다.&lt;/p&gt;

&lt;p&gt;Flux 개발자인 Jing Chen이나 Bill Fisher의 찬사를 받았다고 한다.&lt;/p&gt;

&lt;p&gt;아래는 차이점이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109767292-aa2dae80-7c3a-11eb-8b03-3fb8c41fc800.png&quot; alt=&quot;Untitled 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109767214-8b2f1c80-7c3a-11eb-9b79-2819f00a1311.gif&quot; alt=&quot;1_f3gS9znOZvX8HfCLg7T--Q&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리덕스는 스토어가 하나이고, 디스페쳐가 없으며, immutable state(Reducer가 순수함수여서 copy 해서 replace 하는 방식으로 변경)이라고 한다.&lt;/p&gt;

&lt;p&gt;나중에 기회가 된다면 redux 내부 코드도 한번 훑어보고 싶다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="React" /><category term="Web" /><category term="Flux" /><summary type="html">이번 글에서는 면접 질문으로 들어왔던 Redux 써봤냐 → 그럼 flux 구조를 아느냐 에 대한 답변을 내 개인적으로 시원하게 하지 못해 아쉬움에 내용을 정리해 보도록 한다.</summary></entry></feed>