<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://devsdk.github.io/ko/atom.xml" rel="self" type="application/atom+xml" /><link href="https://devsdk.github.io/ko/" rel="alternate" type="text/html" hreflang="ko" /><updated>2021-03-10T11:36:42+09:00</updated><id>https://devsdk.github.io/ko/</id><title type="html">Seokho’s blog</title><subtitle>Development and Tech blog</subtitle><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><entry><title type="html">Chrome 90 beta is coming, 어떤 기능이 들어올까?</title><link href="https://devsdk.github.io/ko/development/2021/03/08/chrome90.html" rel="alternate" type="text/html" title="Chrome 90 beta is coming, 어떤 기능이 들어올까?" /><published>2021-03-08T09:00:01+09:00</published><updated>2021-03-08T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/08/chrome90</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/08/chrome90.html">&lt;p&gt;Blink Dev-Group에 있으면서, 새로운 Chrome 버전 M90의 beta가 3월 11일에 나온다고 한다. Chromium의 어떤 새로운 기능들이 Chrome 에 도입될 수 있을지 알아보도록 한다.&lt;/p&gt;

&lt;p&gt;이 내용은 &lt;a href=&quot;https://docs.google.com/spreadsheets/d/155euqrhdqVhtbAID7ydaUPjBstLIYZ4PJkpFmqJ6j-o/edit#gid=215381875&quot;&gt;What’s Shipping&lt;/a&gt; 시트를 참고하였다.&lt;/p&gt;

&lt;p&gt;각각 기능은 한 줄에서 두 줄 정도로 이해한 만큼 쓰도록 한다. &lt;em&gt;몇 가지는 생략할 수도 있다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;특히 인상 깊은 건 우선순위 기반 스케쥴러의 도입이 아닐까 싶다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6556060494069760&quot;&gt;Seeking past the end of a file in the File System Access API&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;파일의 끝을 지나서 write를 할 때 reject 대신, 파일을  0x00(NUL)값과 함께 확장한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5676695065460736&quot;&gt;StaticRange constructor&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Highlight API Explained를 위한 feature라는데, 아직 잘 모르겠다 WHATWG 스팩에도 &lt;a href=&quot;https://dom.spec.whatwg.org/#interface-staticrange&quot;&gt;constructor만 명시되어 있다.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5710618575241216&quot;&gt;Subresource loading with Web Bundles&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;다수의 리소스를(e.g. Web Bundles) 번들로 묶을 수 있는 포멧을 사용하여 많은 수의 리소스들을 효율적으로 로드할 수 있는 방향을 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5737185317748736&quot;&gt;Support specifying width/height on &amp;lt;source&amp;gt; elements for &amp;lt;picture&amp;gt;&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&amp;lt;picture&amp;gt;에 대하여 &amp;lt;source&amp;gt;를 이용해 width와 height를 제공함으로써 image의 화면 비율을 계산할 수 있게 해준다.&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nt&quot;&gt;&amp;lt;picture&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;source&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;srcset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image.jpg&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;640&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;480&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width: 100%; height: auto;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/picture&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5370811722498048&quot;&gt;URL protocol setter: New restrictions for file URLs&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;파일에 혹은 파일로 부터 URL이 변경될 때 발생하는 edge case를 바로잡음.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5658873031557120&quot;&gt;Use :focus-visible in the default UA style sheet&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Chromium의 기본 UA스타일을 포커스 인디케이터를 위해 :focus pseudo-class를 사용하는 것 대신 :focus-visible를 사용함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/4756734233018368&quot;&gt;WebAssembly Exception Handling&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;웹 어셈블리의 exception handling 도입.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5086267630944256&quot;&gt;WebAudio: OscillatorOptions.periodicWave is not nullable&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;더이상 periodicWave의 맴버 OscillatorOptions을 null로 설정할 수 없음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5704707957850112&quot;&gt;WebXR AR Lighting Estimation&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;사이트가 WebXr 세션 내에서 environmental lighting의 근사치를 쿼리할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5742647199137792&quot;&gt;WebXR Depth API&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;WebXRDevice의 Deapth Buffer로 접근할 수 있게 해준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/5045313003847680&quot;&gt;getCurrentBrowsingContextMedia()&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;navigator.mediaDevices.getCurrentBrowsingContextMedia() 이 api를 통해 현재 탭에서의 MedaiStream을 캡처할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6031161734201344&quot;&gt;Main thread Scheduling APIs: Prioritized scheduler.postTask&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;개발자가 브라우져의 네이티브 스케쥴러를 통해 3개의 우선순위(user-blocking, user-visible, and background)를 가지는 테스크(javscript callbak)를 스케줄 할 수있게 해준다. (성능과 관련 있음)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/5499415634640896&quot;&gt;MediaStreamTrack Insertable Streams (a.k.a. Breakout Box)&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;카메라의 출력, 마이크, 화면 캡처 또는 코덱의 디코더 부분과 코덱의 디코더 입력과 같은 MeadiaStreamTracks에서 전달하는 raw 미디어를 조작하기 위한 API&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5670287242690560&quot;&gt;Protect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-protobuffer&lt;/code&gt; via Cross-Origin-Read-Blocking&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;speculative execution 공격으로부터 ‘application/x-protobuffer’을 지킨다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://chromestatus.com/features/5694001745231872&quot;&gt;Read Chrome device attributes&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Device Web API의 일부분인 Device attribute를 query 할 수 있게 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6123640410079232&quot;&gt;Relative indexing method for Array, String, and TypedArrays&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;at() 함수 추가.&lt;/p&gt;

    &lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Returns 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5633112799182848&quot;&gt;AbstractRange superclass&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;StaticRange와 Range를 추상화 함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5638444178997248&quot;&gt;Add support for CSS properties “overflow: clip” and “overflow-clip-margin”&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#values&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#values&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/feature/6206321818861568&quot;&gt;AV1 Encoder&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Chrome desktop을 위한 AV1 인코더 도입&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5671807392677888&quot;&gt;Clipboard: read-only files support&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5733828735795200&quot;&gt;CORS-RFC1918: CORS restrictions on internet-to-intranet connections.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/5682100885782528&quot;&gt;CSS aspect-ratio interpolation&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;비율에 대한 보간 내용인 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.chromestatus.com/features/6537562418053120&quot;&gt;Custom state pseudo class&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Custom Element의 state를  :state() psuedo class에서 접근 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Chrome" /><summary type="html">Blink Dev-Group에 있으면서, 새로운 Chrome 버전 M90의 beta가 3월 11일에 나온다고 한다. Chromium의 어떤 새로운 기능들이 Chrome 에 도입될 수 있을지 알아보도록 한다.</summary></entry><entry><title type="html">Reflow, Repaint Chromium 입장에서 살펴보기 (왜 transform은 빠를까?)</title><link href="https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint.html" rel="alternate" type="text/html" title="Reflow, Repaint Chromium 입장에서 살펴보기 (왜 transform은 빠를까?)" /><published>2021-03-08T09:00:00+09:00</published><updated>2021-03-08T09:00:00+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/08/ReflowRepaint.html">&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;Reflow와 Repaint에 대해서 면접 단골 질문이라고 해서 조금 깊이 살펴보도록 한다.&lt;br /&gt;
최적화와 관련된 이야기며, Message Queue (event loop)에 대한 이해가 필요하다. 그 내용은 &lt;a href=&quot;https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html&quot;&gt;여기서&lt;/a&gt; 볼 수 있다. 요약하자면, 만약 js 태스크와 같은 작업이 message queue에서 선점되어 animation frame이 늦어지는 경우 사용자에게 애니메이션이 끊기는 등의 경험을 줄 수 있다. 이런 것을 피하고 최적화할 수 있는 방법에 대해 알아본다.&lt;/p&gt;
&lt;h3 id=&quot;table-of-contents&quot;&gt;Table of contents&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Reflow, Repaint, Layout, Paint, Composite&lt;/li&gt;
  &lt;li&gt;CSS Animation&lt;/li&gt;
  &lt;li&gt;왜 transform을 이용하면 빠를까?&lt;/li&gt;
  &lt;li&gt;tracing으로 알아보는 실제 layout, paint&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;1-reflow-repaint-layout-paint-composite&quot;&gt;1. Reflow, Repaint, Layout, Paint, Composite&lt;/h1&gt;

&lt;p&gt;이 글에서 Reflow와 Repaint는 Layout과 Paint와 대응된다. Reflow와 Repaint는 firefox의 “Gecko” 진영에서 주로 사용하고, layout과 paint는 safari의 webkit과 chromium의 blink 진영에서 사용한다. 혼동을 피하고자 layout과 paint로 설명하도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;layout은-무엇일까&quot;&gt;Layout은 무엇일까?&lt;/h3&gt;

&lt;p&gt;웹브라우져에는 사실 DOM Tree 말고 렌더 스테이지에서 중요한 역할을 하는 트리가 하나 더 있다. 화면에 실제로 그리기 위해 박스모델과 좌표 계산이 끝난 상태인 Layout Tree라는 것을 관리한다. 이는 DOM Tree와 대응되지 않으며, display : none인 경우에는 아예 Layout Tree에 제외되기도 한다. 이러한 내용이 궁금하다면 &lt;a href=&quot;https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_528&quot;&gt;여기&lt;/a&gt;를 살펴보면 좋을 것 같다. layout 단계 혹은 reflow는 &lt;strong&gt;이 트리를 전체 혹은 일부를 새로 구성하는 것&lt;/strong&gt;을 의미한다. layout이 발생한다는 경우에 대해서는 &lt;a href=&quot;https://sites.google.com/site/getsnippet/javascript/dom/repaints-and-reflows-manipulating-the-dom-responsibly&quot;&gt;이곳에서&lt;/a&gt; 리스트업을 하지만 브라우져 레벨에서 &lt;strong&gt;“항상” layout이 발생하는 것은 아니다.&lt;/strong&gt; 예로 CSS Animation을 들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;paint는-무엇일까&quot;&gt;Paint는 무엇일까?&lt;/h3&gt;

&lt;p&gt;위에서 만든 LayoutTree를 순회하며 Paint Command를 만들고 &lt;a href=&quot;https://skia.org/&quot;&gt;SKIA&lt;/a&gt; 레스터라이저한테 전달하는 단계이다.  이를  추상화하고 줄여서 설명하면 &lt;strong&gt;Layout Tree를 화면에 그리는 단계&lt;/strong&gt;라고 이해해도 좋을 것 같다. 여기서 layout 트리에 대응되는 computed style에서 color와 같은 값을 가져와서 화면을 그리게 된다.
 이 단계 또한 매우 방대하며, 관심 있다면 &lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/core/paint/README.md#Current-compositing-algorithm-CompositeBeforePaint&quot;&gt;이 문서&lt;/a&gt;를 보도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;composite&quot;&gt;Composite?&lt;/h3&gt;

&lt;p&gt;Composite은 각각의 분리 가능한 레이어를 분리해서 처리한 뒤 합성하는 것이다. 거시적인 관점에서 &lt;strong&gt;Composite는 Main Thread (Message Queue)에서 벗어나서 다른 Thread Flow를 가지고 화면을 업데이트&lt;/strong&gt; 할 수 있다. 즉 비동기적으로 실행된 후 기존 레이어에 합성된다. 주로 animation과 scroll 등등에서 활용되며, 다른 Thread Flow를 가지기 때문에 main thread에서 block이 일어나도 composite만 사용하는 애니메이션은 계속 재생될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110417527-1dbb3a00-80d9-11eb-9724-e26417c8324d.png&quot; alt=&quot;image&quot; /&gt;
&lt;em&gt;Composition example from &lt;a href=&quot;https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_1213&quot;&gt;Life of Pixels&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-css-animation&quot;&gt;2. CSS Animation&lt;/h1&gt;

&lt;p&gt;CSS Animation은 공짜가 아니며 브라우져의 리소스를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://csstriggers.com/&quot;&gt;https://csstriggers.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 사이트는 CSS Animation이 렌더 스테이지에서 어떤 단계를 trigger 하는지 보여준다.&lt;/p&gt;

&lt;p&gt;여기서 Layout &amp;gt; Paint &amp;gt; Composite 순으로 cost가 높으며 composite만 있다면 Message Queue와 무관하게 동작하므로 매우 좋은 애니메이션 타겟이 될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276915-8641e280-8017-11eb-8f9d-777e61cde490.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276931-8f32b400-8017-11eb-8b37-f3a5209dd077.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;width의 cost는 Layout, Paint, Composite를 전부 사용한다. 따라서 꽤 높은 비용이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276946-98bc1c00-8017-11eb-9929-2508783b42b0.png&quot; alt=&quot;Untitled 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;background-color는 paint, composite를 사용한다.&lt;/p&gt;

&lt;h1 id=&quot;3-왜-transform을-이용하면-빠를까&quot;&gt;3. 왜 transform을 이용하면 빠를까?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276963-a2458400-8017-11eb-8c3e-029f7f5c0b3c.png&quot; alt=&quot;Untitled 4&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276965-a376b100-8017-11eb-962b-e7945a3dd8c2.png&quot; alt=&quot;Untitled 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우리는 같은 역할을 하는 두 가지의 코드를 만들 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    .b &lt;span class=&quot;si&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transform: translateX(200px)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;position:relative;left:200px&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110276977-ad001900-8017-11eb-9022-42350b5a8555.png&quot; alt=&quot;Untitled 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 코드는 완전히 화면에 동일한 결과를 내놓는다. 하지만 내부적으로 다르게 동작한다.&lt;/p&gt;

&lt;p&gt;컴퓨터는 그래픽을  matrix의 곱으로 표현한다. (&lt;a href=&quot;http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/&quot;&gt;OpenGL examples&lt;/a&gt;) 이는 OpenGL, DirectX 등에 반드시 사용되며 GPU는 이런 연산을 빠르게 하기 위해 설계되었다.&lt;/p&gt;

&lt;p&gt;transform을 사용한 예시중 첫번째 div는 최종 composite에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Transformation_matrix&quot;&gt;transformation matrix&lt;/a&gt;를 통해 렌더링 되기 전 composite thread에서 GPU의 도움을 받아 계산된다.  아주 빠른 연산이 비동기적으로 일어나 매우 빠른 속도를 보여준다.  어떤 연산이 일어나는지는 &lt;a href=&quot;https://drafts.csswg.org/css-transforms/#mathematical-description&quot;&gt;표준을&lt;/a&gt; 참고하자. 심지어 Main Thread가 다른 태스크에 의해 block 되어도 재생된다.&lt;/p&gt;

&lt;p&gt;left를 사용한 아래 예시는 layout→composite.assign-&amp;gt;paint의 절차를 모두 밟게 된다. 즉 애니메이션으로 사용되기엔 꽤 비싼 cost를 가지고 있다는 소리다.
(Paint → Composite 는 현재 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=471333&quot;&gt;Chromium의 주요 프로젝트중&lt;/a&gt; 하나이다. CAP (Composition After Paiting)이라고 불린다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110435489-6c2b0180-80f6-11eb-9c35-82824d8ad351.gif&quot; alt=&quot;Peek 2021-03-09 16-40&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 즐거운 결론을 낼 수 있다. animation에서 만약 같은 결과를 내는 코드라면 &lt;strong&gt;composite만 사용하는 애니메이션 (i.e.transform)&lt;/strong&gt;을 애용하자.&lt;/p&gt;

&lt;h1 id=&quot;4-tracing으로-알아보는-실제-layout-paint&quot;&gt;4. Tracing으로 알아보는 실제 layout, paint&lt;/h1&gt;

&lt;p&gt;아래부터의 내용은 chromium/chrome의 동작 구조를 직접 살펴보며 위에서 이야기한 내용을 눈으로 봐볼 것이다.&lt;/p&gt;

&lt;p&gt;아래는 width를 이용한 animation을 tracing 한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277005-c0ab7f80-8017-11eb-9b93-6fa9b7769b5e.png&quot; alt=&quot;Screenshot_from_2021-03-08_11-45-14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CrRendererMain에 바코드처럼 빼곡하게 있는 것들이 바로 layout→paint 그리고 composite를 트리거 하는 단계이다.&lt;/p&gt;

&lt;p&gt;저 바코드의 줄 하나를 확대하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277012-c608ca00-8017-11eb-999d-aa8f220241a2.png&quot; alt=&quot;Screenshot_from_2021-03-08_13-45-51&quot; /&gt;&lt;/p&gt;

&lt;p&gt;트레이스가 기록된 저 상자는 c++ 구현과 1대1로 대응되며, 필요하다면 소스코드를 볼 수 있다. 이 내용을 보면 &lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/frame/local_frame_view.cc;l=3312;drc=3c992b98c58db034eb5af6bc51aac6fb1939d571&quot;&gt;LocalFrameView::UpdateStyleAndLayoutIfNeededRecursive()&lt;/a&gt;이 호출됨으로써 layout과 paint가 끊임없이 일어난다는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;만약 DOM Tree의 깊이가 깊어진다면 그만큼의 recursion 호출이 발생한다.&lt;/p&gt;

&lt;p&gt;그렇다면 반대로 transform을 사용한 경우는 어떤 트레이싱을 볼 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110277028-cdc86e80-8017-11eb-87dc-550b7e53f85a.png&quot; alt=&quot;Untitled 6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞에 빼곡하게 있는 것은 마우스 때문에 발생한 animation이고 실제로 trigger 돼서 화면에 보인 것은 갑자기 빈 공간이 생기는 부분부터 이다. 여기서 compositor는 전달받은 역할을 &lt;strong&gt;비동기적&lt;/strong&gt;으로 실행하는 것을 볼 수 있다. 이런 이유 때문에 composite만 사용하는 애니메이션은 alert와 같이 main thread가 block 된 상황에서도 정상적으로 렌더 수행이 진행된다.&lt;/p&gt;

&lt;p&gt;오타/질문/틀린 내용이 있다면 언제든지 피드백 바란다. :)&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Web" /><category term="HTML" /><category term="CSS" /><category term="Optimization" /><summary type="html">Overview</summary></entry><entry><title type="html">React 파헤치기, 리액트가 동작하는 방법 (overview)</title><link href="https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview.html" rel="alternate" type="text/html" title="React 파헤치기, 리액트가 동작하는 방법 (overview)" /><published>2021-03-07T09:00:00+09:00</published><updated>2021-03-07T09:00:00+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/07/ReactInternalOverview.html">&lt;h1 id=&quot;motivation&quot;&gt;Motivation&lt;/h1&gt;

&lt;p&gt;Chromium에서 활동하면서 웹브라우져가 어떻게 동작하는지는 어느 정도 (완벽할 순 없다고 생각한다.. 너무 거대하다.)알고 있다.&lt;/p&gt;

&lt;p&gt;그리고 리액트를 사용하는 방법을 알고 있다.&lt;/p&gt;

&lt;p&gt;그러나 React-DOM과 내부 사항들에 대해서는 너무 추상적으로 알고있거나 모른다고 생각한다.&lt;/p&gt;

&lt;p&gt;그래서 리액트와 브라우져 사이의 블랙박스가 너무 궁금하여 몇몇 가지의 문서와 react 소스코드를 뒤졌던 결과 어느정도 오버뷰가 나올 것 같아서 블로그에 정리하도록 한다.&lt;/p&gt;

&lt;p&gt;하지만 아직 완전히 모든 소스코드를 본 것은 아니며, 생략되거나, 틀릴 수도 있는 내용이다.&lt;/p&gt;

&lt;p&gt;언제든지 피드백을 받는다면 반영하도록 하겠다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232600-03128500-7f62-11eb-8f38-c3e5015e0303.png&quot; alt=&quot;Untitled (2)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 글을 쓰기 시작한 큰 이유다.&lt;/p&gt;

&lt;p&gt;중간에 블랙박스가 너무 많아 실제로 어떻게 동작하는지 그리고 내가 더 생각해 볼 수 있는 다른 방향은 없는지 알기가 어려웠다. 덧붙이자면 말 그대로 &lt;strong&gt;마법상자&lt;/strong&gt; 가 있어서 이를 화면에 그려주고 상태를 변경시키는 작업을 하는 느낌을 받았다.&lt;/p&gt;

&lt;p&gt;지금부터 그 마법상자를 열어보도록 한다.&lt;/p&gt;

&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232607-09a0fc80-7f62-11eb-9780-6bd6e032638c.png&quot; alt=&quot;Untitled (3)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;글 내용이 뒤죽박죽이라, 아래의 내용을 바탕으로 위의 이미지를 정리하면 다음과 같다.&lt;/p&gt;

&lt;p&gt;콜백에 의해 fiber 스케쥴러가 업데이트되고, 그 스케쥴러는 fiber들의 테스크를 실행하여 산출물인 업데이트 트리(WorkInProgress or Finished)를 Commit을 통해 dom에 반영한다.&lt;/p&gt;

&lt;h1 id=&quot;detail&quot;&gt;Detail&lt;/h1&gt;

&lt;p&gt;React는 다음과 같은 JSX 문법을 통해 “선언적” 인 구현을 권장한다. (&lt;a href=&quot;https://reactjs.org/docs/jsx-in-depth.html&quot;&gt;리엑트 공식 문서&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;리액트를 처음 썼을때 가장 놀랐던 부분이기도 하다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MyButton&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;blue&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;shadowSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  Click Me
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MyButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;공식문서에서도 설명하듯이, 이는 컴파일러에 의해 (babel-loader?) 다음과 같이 코드로 변경된다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;MyButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;shadowSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Click Me&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 함수를 거치면서 아래의 계층을 가진 object 형식으로 반환이 된다.&lt;/p&gt;

&lt;p&gt;DOM과 유사하게 children이 있고 여러 가지 정보들을 담고 있다.&lt;/p&gt;

&lt;p&gt;(위 소스코드와 아래의 결과와는 다르다. 위는 공식문서에서 가져왔다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110232637-3d7c2200-7f62-11eb-930c-b90f62771320.png&quot; alt=&quot;Untitled (4)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 우리는 위 내용을 ReactDOM.render를 통해 react-dom에 전달한다. react-dom은 위 정보를 fiber 라는 형태로 관리한다.&lt;/p&gt;

&lt;p&gt;Fiber는 react의 element는 1대1로 대응되면서 여러 내부 정보를 가지고 있는 구조이며 react의 작업의 단위가 되기도 하고, 자체적인 스택프레임을 가지는 일의 주체라고 한다.&lt;/p&gt;

&lt;p&gt;reconciliation 작업에 사용된다. (fiber는 &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-reconciler/src&quot;&gt;react-reconciler&lt;/a&gt; 패키지에서 관리한다.) 내부적인 reconciliation 알고리즘은 O(n)의 휴리스틱 한 알고리즘이라고 한다. 공식문서에서는 개발자가 key를 줌으로써 알고리즘에 힌트를 줄 수 있다는 중요한 내용이 담겨있다.&lt;/p&gt;

&lt;p&gt;그렇다면 fiber는 어떤 역할을 할까?&lt;/p&gt;

&lt;p&gt;너무 &lt;a href=&quot;https://github.com/facebook/react/blob/7df65725ba7826508e0f3c0f1c6f088efdbecfca/packages/react-reconciler/src/ReactFiber.new.js#L111&quot;&gt;필드가 많아서&lt;/a&gt; 봤던 article의 내용 중 일부를 빌리자면 이렇게 생겼다.&lt;/p&gt;

&lt;div class=&quot;language-jsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;stateNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;alternate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;chiled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;updateQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;memoizedState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;pendingProps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;memoizedProps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;effectTag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;nextEffect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Tree 형태로 내용을 기반으로 순회하면서 WorkInProgress 트리를 만들게 된다. 그리고 WorkInProgress는 이후 화면으로 반영될 트리를 의미한다. 여기서 자주 보던 녀석들이 있는데 React.memo에 의해 property를 기록할 때 실제로 반영되는 필드인 memoizedProps와, 공식문서에서도 설명하던 key 필드이다. 이 필드는 reconciliation 작업에서 휴리스틱한 탐색에 주요 factor로 사용된다.&lt;/p&gt;

&lt;p&gt;또한, 자체적인 스택프레임을 가지고 있다는 부분이 정말 재밌는데, &lt;a href=&quot;https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html&quot;&gt;이벤트루프의 동작 방식&lt;/a&gt; 에 따르면 js execution이 길어지면 다음 태스크가 계속 기다려야 하므로 사용자경험이 안 좋아(애니메이션이 끊긴다거나, 터치가 씹힌다거나 등) 질 수 있는 것을 방지하기 위해 도입된 방식이다.&lt;/p&gt;

&lt;p&gt;fiber한테는 자체적인 실행 스택(work queue로 관리되는 듯해 보인다)을 가지고 자체적인 priority 기반 scheduler를 이용하여 태스크를 쪼개서 관리하면서 Message Queue가 다른 이벤트를 처리할 수 있도록 하여 Message Queue가 다른 task를 실행할 수 있도록 해주는 것 같다. 여기서 스케쥴러는 requestIdleCallback (requestAnimationframe?) API에 의해 호출된다.&lt;/p&gt;

&lt;p&gt;이제 react-dom의 마지막 산출 단계에서는 render 페이즈와 commit 페이즈로 나뉘게 된다.&lt;/p&gt;

&lt;p&gt;렌더페이즈는 위에서 서술했듯이 current 트리에서 WorkInPregress를 생성하는 (변경사항들을 찾아서 렌더링할 재료를 만드는) 단계라면 commit 페이즈는 말 그대로 화면에 그리도록 제출하는 단계이다. 여기서 didComponentMount 와 같은 lifecycle 함수들이 호출된다. (렌더 페이즈에서 호출되든 lifecycle 함수들은 UNSAFE_ 태그를 달고 있다고 한다.)&lt;/p&gt;

&lt;p&gt;실제로 react 소스코드에서 &lt;a href=&quot;https://github.com/facebook/react/blob/c7b4497988e81606f1c7686434f55a49342c9efc/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1350&quot;&gt;commitUpdate&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/react/blob/c7b4497988e81606f1c7686434f55a49342c9efc/packages/react-dom/src/client/ReactDOMHostConfig.js#L451&quot;&gt;commitPlacement&lt;/a&gt; 등등을 통해 dom에 반영하는 것을 찾아볼 수 있다. 내부적으론 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore&quot;&gt;insertBefore&lt;/a&gt; 와 같은 함수를 호출하는 것으로 보인다.&lt;/p&gt;

&lt;p&gt;위 내용은 글 초반에 말했듯이, 소스코드레벨에서 완전한 이해를 바탕으로 쓴 글이 아니다.&lt;/p&gt;

&lt;p&gt;몇몇 가지의 글을 보고, 소스를 뒤적이다가 오버뷰를 만들면 좋을 것 같다는 생각에 작성했다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;refs&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react&quot;&gt;https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;https://github.com/acdlite/react-fiber-architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://bit.ly/lifeofapixel&quot;&gt;http://bit.ly/lifeofapixel&lt;/a&gt;&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="React" /><category term="Web" /><category term="React-DOM" /><summary type="html">Motivation</summary></entry><entry><title type="html">Chrome Inspector로 화면이 왜 느린지 찾아보기</title><link href="https://devsdk.github.io/ko/development/2021/03/06/ChromeInspectorPerformnace.html" rel="alternate" type="text/html" title="Chrome Inspector로 화면이 왜 느린지 찾아보기" /><published>2021-03-06T09:00:01+09:00</published><updated>2021-03-06T09:00:01+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/06/ChromeInspectorPerformnace</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/06/ChromeInspectorPerformnace.html">&lt;p&gt;DFD를 구현하고 항상 들던 의문이 있었다.&lt;/p&gt;

&lt;p&gt;화면을 구성하고 어느 순간부터 main 화면에서 로딩이 늦는것&lt;/p&gt;

&lt;p&gt;다루는 데이터가 그렇게 많은 편이 아닌데도 chart나 render 부분이 느린 것 같다는 생각이 종종 들었다. 물론 사용하는 데 전혀 지장은 없지만 UX 적으로 조금 개선할 방향을 찾아보고 싶었다.&lt;/p&gt;

&lt;p&gt;가장 먼저 해본 것은, React Profiler를 사용해 확인하는 것이었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197436-fcffa400-7e8e-11eb-9df0-f3b2367aadae.png&quot; alt=&quot;Screenshot_from_2021-03-06_14-49-03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 프로파일러에서는 계속 LOLGameElement 가 느린 것 같아!! 라고 이야기하고 있었다.&lt;/p&gt;

&lt;p&gt;사실 살펴보면 시간 단위가 문제가 될 만큼 느리지 않았다. 즉 다른 곳이 느리거나, 놓치고 있는 게 있다는 것일 것이라는 가설을 세우게 되었다. 가장 느린 구간이 70ms라니, 이는 화면에 보이는 것보다 느린 것이 아니다.&lt;/p&gt;

&lt;p&gt;또한 얻는 정보가 한정되어있다는 생각이 많이 들었다. 
(이는 내 react profiler 사용이 서툴러서 그런 것 일수도 있다.)&lt;/p&gt;

&lt;p&gt;다른 방법을 취해보기로 했다.&lt;/p&gt;

&lt;p&gt;chrome://tracing에 들어가서 전체 렌더 시간에 일어나는 일들을 Web Developer Mode로 트레이싱 하였다.&lt;/p&gt;

&lt;p&gt;웹 개발자 모드로 한 이유는 그 정보로도 충분할 가능성이 높기 때문이다. 만약 필요해서 더 깊이 들어가야 한다면 Chromium flag를 enable 한 뒤 빌드하여 전체모드 트레이싱 하면 skia 렌더 커멘드 (네모 그리기가 매우 많다.) 단위까지 조사할 수 있다&lt;/p&gt;

&lt;p&gt;트레이싱 도구를 사용한 이유는 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;어떤 &lt;strong&gt;렌더스테이지&lt;/strong&gt; 에서 시간을 쓰고 있는지 (ex, composition, layout, javascript execution, style compute recursion … )&lt;/li&gt;
  &lt;li&gt;디버깅에는 가능성을 최대한 열어두고 소거하는 것을 좋아한다.&lt;/li&gt;
  &lt;li&gt;단계적인 접근 방법&lt;/li&gt;
  &lt;li&gt;만약 필요하면 C++ 네이티브 코드를 바로 볼 수 있게 제공받는다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197458-07ba3900-7e8f-11eb-9760-ff918d830abe.png&quot; alt=&quot;Screenshot_from_2021-03-06_14-43-40&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일단 한눈에 들어온 정보는 v8이 가져가는 시간이 정말 많다는 점이었다.&lt;/p&gt;

&lt;p&gt;이 말은  javascript execution 쪽에서 느려짐을 의미한다. 여기서 다른 렌더 스테이지에서 느려지지 않는 것을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;이제 javascript execution을 추적하기 위해 insepcator를 이용하여 Performance 체크를 해보기로 했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197472-11dc3780-7e8f-11eb-8421-e4f1ec7361df.png&quot; alt=&quot;Screenshot_from_2021-03-06_15-03-22&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 느려지는 구간은 3가지 정도인 것 같고, 공통점을 찾아낼 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197480-202a5380-7e8f-11eb-9e22-f0b6ce9f7e02.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;apexchart 쪽에서 이러한 이벤트들이 모이고 모여 엄청 긴 시간을 가져가게 된 것이다.&lt;/p&gt;

&lt;p&gt;여기서 잠정적인 결론을 내릴 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apexchart를 제거하거나 optimize 하면 이 느려지는 것이 해결 될 것&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최적화를 위해 관련 정보를 찾아보고 문서를 봐봤지만, Apexchart의 고질적인 문제인 것 같다는 생각이 든다.&lt;/p&gt;

&lt;p&gt;일단 꽤 자주 퍼포먼스이야기가 (i.e. &lt;a href=&quot;https://github.com/apexcharts/vue-apexcharts/issues/208&quot;&gt;github issue&lt;/a&gt;) 보였다.&lt;/p&gt;

&lt;p&gt;또한 내가 apexchart를 잘못 사용한 것인가? 라는 의문을 가지고 공식 홈페이지의 live demo에 가서 퍼포먼스 체크를 진행했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110197498-39330480-7e8f-11eb-9547-62cb0c3a33f1.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공식 홈페이지의 Demo에서 데이터가 그리 많지 않음에도 꽤 많은 시간을 apexchart가 가져간다.&lt;/p&gt;

&lt;p&gt;아마도 고질적인 문제가 아닐까 조심스럽게 추측하면서, apexchart를 대체할 방법을 생각해 보면 좋을 것 같다는 생각이 들었다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chrome" /><category term="Web" /><category term="Javascript" /><category term="Optimization" /><category term="Debugging" /><summary type="html">DFD를 구현하고 항상 들던 의문이 있었다.</summary></entry><entry><title type="html">SCL Notion Checklist generator 개발</title><link href="https://devsdk.github.io/ko/development/2021/03/06/IntroduceSCL.html" rel="alternate" type="text/html" title="SCL Notion Checklist generator 개발" /><published>2021-03-06T09:00:00+09:00</published><updated>2021-03-06T09:00:00+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/06/IntroduceSCL</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/06/IntroduceSCL.html">&lt;p&gt;아침 일찍 일어나서 취업준비를 위해 Chromium 커밋 리스트를 다시한번 훑어보는데 아뿔싸… 머지한 커밋중에 Commit Message와 코드가 다른 것을 보았다.&lt;/p&gt;

&lt;p&gt;아래는 커밋 메시지 중 일부분.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110193524-b488bc00-7e77-11eb-82eb-2b22114266cd.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아래는 실제 코드&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/110193525-b5b9e900-7e77-11eb-90f9-be68a9a97b18.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아무래도 패치셋이 진행되면서 이름을 바꾸게 되었는데, CR+2받고 그냥 머지시킨 것 같다.&lt;/p&gt;

&lt;p&gt;앞으로도 이런 실수를 안 하리라는 보장이 없기 때문에 scl이라는 간단한 프로젝트를 진행했다.&lt;/p&gt;

&lt;p&gt;아이디어는 다음과 같았다. “Commit Checklist를 패치별로 notion에 저장하면 편하지 않을까?”&lt;/p&gt;

&lt;p&gt;notion은 api를 아직 정식으로 제공하지 않는다.&lt;/p&gt;

&lt;p&gt;Private test 중이라고 하는데, 언제 열릴지 모르기 때문에 그걸 기다리기는 건 어려울 것 같다는 결론을 냈다.&lt;/p&gt;

&lt;p&gt;처음에는 golang으로 짜인 라이브러리가 보이길래, go언어로 짜다가 block(노션의 컨텐츠)를 생성하는 것이 없어 다른 방법을 찾아보았다. 그렇게 API를 따서 python 라이브러리로 만든 notion-py을 발견했는데, notion 대부분의 기능을 사용할 수 있어서 python으로 갈아타기로 했다.&lt;/p&gt;

&lt;p&gt;개발환경이 워낙 CLI와 가깝다 보니 CLI 기반으로 작성하였다.&lt;/p&gt;

&lt;p&gt;레포지토리 &lt;a href=&quot;https://github.com/DevSDK/scl&quot;&gt;https://github.com/DevSDK/scl&lt;/a&gt;&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Python" /><category term="Notion" /><category term="CLI" /><category term="Productivity" /><summary type="html">아침 일찍 일어나서 취업준비를 위해 Chromium 커밋 리스트를 다시한번 훑어보는데 아뿔싸… 머지한 커밋중에 Commit Message와 코드가 다른 것을 보았다.</summary></entry><entry><title type="html">Flux 아키텍처</title><link href="https://devsdk.github.io/ko/development/2021/03/03/FluxArchitecture.html" rel="alternate" type="text/html" title="Flux 아키텍처" /><published>2021-03-03T14:02:20+09:00</published><updated>2021-03-03T14:02:20+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/03/FluxArchitecture</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/03/FluxArchitecture.html">&lt;p&gt;이번 글에서는 면접 질문으로 들어왔던 Redux 써봤냐 → 그럼 flux 구조를 아느냐 에 대한 답변을 내 개인적으로 시원하게 하지 못해 아쉬움에 내용을 정리해 보도록 한다.&lt;/p&gt;

&lt;p&gt;Q: Flux 구조에 대해서 알고 계신 게 있나요?&lt;/p&gt;

&lt;p&gt;“사실 Flux는 들어만 보았고, 정확하게 어떤 것을 의미하는지는 기억하지 못합니다. 저는 이 구조가 글로벌 상태 관리를 하는 패턴이라고 알고 있습니다. 이 구조를 활용한 Redux를 사용하여 어플리케이션을 개발했는데~”.&lt;/p&gt;

&lt;p&gt;이번 기회에 Flux 구조에 대해 다시 한 번 공부해보도록 한다.&lt;/p&gt;

&lt;p&gt;3줄 요약부터 해보도록 한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;FLUX는 MVC패턴과 같은 패턴의 한 일종이다.&lt;/li&gt;
  &lt;li&gt;단방향으로 데이터가 흐른다.&lt;/li&gt;
  &lt;li&gt;Redux와 같은 녀석들은 이러한 구조를 편하게 쓸 수 있게 해주는 것들이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;사실 위 3줄 요약보다 더 간단한 이미지가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109767232-93875780-7c3a-11eb-86f3-753e5c7a4674.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화살표는 데이터의 흐름을 의미한다.&lt;/p&gt;

&lt;p&gt;이미지에서 볼 수 있듯이 단방향으로 흐른다.&lt;/p&gt;

&lt;p&gt;그렇다면 만약 사용자가 인터렉션을 취해서 상태를 변경한다면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109767265-9f731980-7c3a-11eb-95fb-089ead36252c.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다시 dispatcher를 통해 데이터를 action을 이용해 보내게 된다.&lt;/p&gt;

&lt;h3 id=&quot;dispatcher&quot;&gt;Dispatcher&lt;/h3&gt;

&lt;p&gt;Dispatcher는 Flux 아키텍처에서 모든 데이터의 흐름을 관리한다.  액션을 분배하고 store에 콜백을 등록하는 등 간단한 메커니즘으로 동작한다.&lt;/p&gt;

&lt;p&gt;Action Creator가 새로운 action이 있다고 dispatch를 호출하면 어플리케이션의 모든 store는 action을 등록한 callback으로 전달받는다.&lt;/p&gt;

&lt;p&gt;아래는 dispatcher의 실제 구조이다.&lt;/p&gt;

&lt;div class=&quot;language-tsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;dispatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TPayload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;invariant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_isDispatching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_startDispatching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_callbacks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_isPending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_invokeCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_stopDispatching&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/Dispatcher.js#L180&quot;&gt;https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/Dispatcher.js#L180&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 설명대로 모든 callback을 invoke한다. (_invokeCallback함수에서 payload를 전달해준다.)&lt;/p&gt;

&lt;h3 id=&quot;store&quot;&gt;Store&lt;/h3&gt;

&lt;p&gt;스토어는 어플리케이션의 상태와 로직을 가지고 있다. Store라는 이름답게 상태를 저장하고 있다고 생각해도 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;store는 개별적인 도메인에서 상태를 관리해주는데 이는 스토어별로 dispatcher token을 별도로 할당하기 때문이다.&lt;/p&gt;

&lt;p&gt;이걸 조금 더 풀어쓰기 위해 flux 공식 문서에 따르면 “페이스북의 되돌아보기 비디오 편집기”는 트랙의 플레이 백 포지션 같은 정보를 TimeStore에 관리(트레킹) 하고 “이미지”는 ImageStore에서 관리하는 것을 말할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;action&quot;&gt;Action&lt;/h3&gt;

&lt;p&gt;Dispatcher는 action을 호출해 데이터를 불러오고 store로 전달할 수 있게 해주는 메서드를 제공한다.&lt;/p&gt;

&lt;p&gt;변경할 데이터가 담겨진 객체라고 이해해도 괜찮을 것 같다.&lt;/p&gt;

&lt;p&gt;이런식으로 생겼다.&lt;/p&gt;

&lt;div class=&quot;language-tsx highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;actionType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;city-update&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;selectedCity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;paris&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;view와-controller-view&quot;&gt;View와 Controller-View&lt;/h3&gt;

&lt;p&gt;store로부터 이벤트를 받으면 데이터를 비교하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setState()&lt;/code&gt;  또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forceUpdate()&lt;/code&gt; 매서드를 호출하게 되어 화면이 갱신된다.&lt;/p&gt;

&lt;p&gt;컨트롤러 뷰는 자식에게도 데이터를 흘려보낸다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/container/FluxContainer.js#L187&quot;&gt;https://github.com/facebook/flux/blob/5f6d5817a63e275c95b571ca2949379c4c1640b5/src/container/FluxContainer.js#L187&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여기서 그 역할을 하는 것 같다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;redux&quot;&gt;Redux?&lt;/h2&gt;

&lt;p&gt;Redux는 Reducer + Flux 라는 뜻을 가지고&lt;/p&gt;

&lt;p&gt;Flux에서 간소화시키고 간단한 사용을 주제로 개발되었다고 한다.&lt;/p&gt;

&lt;p&gt;Flux 개발자인 Jing Chen이나 Bill Fisher의 찬사를 받았다고 한다.&lt;/p&gt;

&lt;p&gt;아래는 차이점이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109767292-aa2dae80-7c3a-11eb-8b03-3fb8c41fc800.png&quot; alt=&quot;Untitled 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109767214-8b2f1c80-7c3a-11eb-9b79-2819f00a1311.gif&quot; alt=&quot;1_f3gS9znOZvX8HfCLg7T--Q&quot; /&gt;&lt;/p&gt;

&lt;p&gt;리덕스는 스토어가 하나이고, 디스페쳐가 없으며, immutable state(Reducer가 순수함수여서 copy 해서 replace 하는 방식으로 변경)이라고 한다.&lt;/p&gt;

&lt;p&gt;나중에 기회가 된다면 redux 내부 코드도 한번 훑어보고 싶다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="React" /><category term="Web" /><category term="Flux" /><summary type="html">이번 글에서는 면접 질문으로 들어왔던 Redux 써봤냐 → 그럼 flux 구조를 아느냐 에 대한 답변을 내 개인적으로 시원하게 하지 못해 아쉬움에 내용을 정리해 보도록 한다.</summary></entry><entry><title type="html">Chromium 첫번째 패치부터 지금까지 돌아보기</title><link href="https://devsdk.github.io/ko/development/2021/03/02/FirstStoryWithChromiumContributing.html" rel="alternate" type="text/html" title="Chromium 첫번째 패치부터 지금까지 돌아보기" /><published>2021-03-02T17:02:20+09:00</published><updated>2021-03-02T17:02:20+09:00</updated><id>https://devsdk.github.io/ko/development/2021/03/02/FirstStoryWithChromiumContributing</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/03/02/FirstStoryWithChromiumContributing.html">&lt;p&gt;Chromium에서 활동한 지 반년 정도 되어가는 것 같고, 11개의 패치를 머지시켰다.&lt;/p&gt;

&lt;p&gt;라인수로는 정확하지는 않지만 1600라인 넘게 수정한 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109617938-5360a000-7b7a-11eb-86a0-1bd7d6d20773.png&quot; alt=&quot;Screenshot_from_2021-03-02_12-56-55&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그중의 하나인 첫 패치는 deprecated 된 매크로 함수를 지우는 오타 수정과 비슷한 패치 trivial 패치여서 제외하면 10개에 도달한 것이다.&lt;/p&gt;

&lt;p&gt;이 말은 &lt;a href=&quot;http://www.chromium.org/getting-involved/become-a-committer&quot;&gt;커미터가 되기 위한 조건&lt;/a&gt; 중 첫 번째를 달성했다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10-20 non-trivial patches in the Chromium src Git repository&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2~3개월 내로 커미터를 달 수 있을 것이라고 기대하고 있는데, 언제 노미네이션 될지는 잘 모르겠다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;크로미움 이메일 주소 가지고 싶다….&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;웹브라우져를-만들자&quot;&gt;웹브라우져를 만들자&lt;/h3&gt;

&lt;p&gt;사실 Chromium 건들기 시작하게 된 계기는 반년 전이 아니라 1년 전이다. 친한 형하고 놀면서 (프론트엔드 개발자) 이야기하다가 웹브라우져를 이해하기 위해 웹브라우져를 만드는 프로젝트를 해보고 싶다는 대화가 오고 갔다.&lt;/p&gt;

&lt;p&gt;그렇게 웹브라우져의 코드를 분석하고 공유하는 팀인 team_seoksoo (친한 형 이름이 ‘영수’라 내 이름의 석과 형 이름의 수를 붙여 만들었다.)를 만들게 되었다.&lt;/p&gt;

&lt;p&gt;시작부터 수월하지는 않았다. 상대는 3000만 라인이 넘는 거대한 오픈소스 프로젝트 Chromium과 하나부터 알아가야 했던 WebKit이였기 때문이다.&lt;/p&gt;

&lt;p&gt;첫번째로 직면했던 문제 중 하나는 레포 덩치가 어마어마하다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/docs/linux/build_instructions.md&quot;&gt;여기&lt;/a&gt;서 볼 수 있는 Chromium의 권장 빌드 스팩은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 64-bit Intel machine with at least 8GB of RAM. More than 16GB is highly recommended.&lt;/li&gt;
  &lt;li&gt;At least 100GB of free disk space.&lt;/li&gt;
  &lt;li&gt;You must have Git and Python v2 installed already.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실제로 내 컴퓨터에서는 150GB (…) 정도를 크로미움이 먹고 있다.&lt;/p&gt;

&lt;p&gt;빌드하는데는 3시간 정도 걸린다. (XPS 9560 최고급모델, i7 7700HQ, 32GB)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109617999-66737000-7b7a-11eb-9fae-0f4199fe7f27.png&quot; alt=&quot;Untitled&quot; /&gt;
)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;이 글을 쓰기 한참 전부터 빌드를 돌려놨는데 아직도 끝나지 않았다..&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우여곡절 끝에 코드를 받고 빌드해서 실행까지 해내는 데 성공했고, 그 시기에 Blink Renderer의 정수가 담긴 문서 “&lt;a href=&quot;http://bit.ly/lifeofapixel&quot;&gt;Life of Pixels&lt;/a&gt;“를 보게 되었다. “웹브라우져가 구체적으로 어떻게 동작하는구나~” 라는 것을 배울 수 있던 시기였다.&lt;/p&gt;

&lt;p&gt;idl에 대해 배우고, 콘솔에 로그 찍어보고, 여타 다른 것들 분석하듯이 분석하다가,  자연스럽게 다른 task들의 비중이 높아지고, 팀의 의욕이 줄어들어서 (서로 본업과, 학업 및 기타 등등) 멈춘 것 같다. 그렇게 2학년 1학기가 흘러갔다.&lt;/p&gt;

&lt;h3 id=&quot;본격적인-시작&quot;&gt;본격적인 시작&lt;/h3&gt;

&lt;p&gt;Chromium 활동에 불이 다시 붙은 건 2학년 여름방학이었다. 컨트리뷰톤이라는 활동에서  Chromium 팀에 선정되었다. 대단한 멘토 분들 (hyunjune.kim&amp;amp;samsung.com,jh718.park&amp;amp;gmail.com) 이 컨트리뷰션 프로세스에 대해 잘 알려주고 간단한 trivial issue를 지정해줘서 전체적인 컨트리뷰션 프로세스를 경험할 수 있었다.&lt;/p&gt;

&lt;p&gt;그리고 GoodFirstBug 라는 태그를 이용해 초심자가 해결하기 좋은 이슈를 찾아다녔다.&lt;/p&gt;

&lt;p&gt;(그렇게 나는 속았다.) 사실 GoodFirstBog로 분류된 이슈 중에서는 사실 GoodFirstBug가 아닌 경우도 꽤 많고, 까고 보니까 규모가 커지는 경우도 많은 것 같다.&lt;/p&gt;

&lt;p&gt;컨트리뷰톤 내내 잡고 있던 이슈는 select의 스크롤바 이슈를 해결하는 것, 이 내용에 대해서는 &lt;a href=&quot;https://devsdk.github.io/ko/chromium/2020/12/13/ChromiumCustomscrollbarForSelect.html&quot;&gt;이 글에&lt;/a&gt; 나와 있다. 놀랍게도 GoodFirstBug였다.&lt;/p&gt;

&lt;p&gt;이 패치 말고도 html form의 validation message를 수정하는 등의 패치를 이어나갔다.&lt;/p&gt;

&lt;p&gt;그렇게 패치를 이어나가고, 3~4패치가 머지 되었을 때 멘토님이 커미터 분들한테 프로젝트 맴버 권한을 요청해주셨다.&lt;/p&gt;

&lt;p&gt;그렇게 받은 권한들.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109618232-a33f6700-7b7a-11eb-992d-5a754dfe5c23.png&quot; alt=&quot;permissions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tryjob-access: &lt;a href=&quot;https://ci.chromium.org/p/chromium&quot;&gt;testfarm&lt;/a&gt;에 테스트를 실행하고 코드 리뷰를 받고 내 패치를 &lt;strong&gt;머지&lt;/strong&gt;시킬 수 있는 권한&lt;/p&gt;

&lt;p&gt;edit-bug-access: &lt;a href=&quot;https://crbug.com/&quot;&gt;https://crbug.com/&lt;/a&gt; 에 올라온 모든 이슈를 직접 &lt;strong&gt;수정&lt;/strong&gt;할 수 있는 권한. (이 권한이 있어야만 볼 수 있는 이슈도 있음).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;이 권한들이 있고 없고의 차이가 꽤 크다고 생각한다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;권한을 받고 활동을 하면서 욕심이 생겼다. 원동력이 된 것들은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영어를 계속 사용할(사용해야만) 환경&lt;/li&gt;
  &lt;li&gt;디버깅 능력을 입증할 기회&lt;/li&gt;
  &lt;li&gt;모두가 쓰는 SW를 개발한다는 것에 대한 자부심&lt;/li&gt;
  &lt;li&gt;코드를 읽고 수정하는 능력 향상 및 증명&lt;/li&gt;
  &lt;li&gt;전 세계의 훌륭한 개발자들과의 협업&lt;/li&gt;
  &lt;li&gt;맡은 것에 대한 책임감&lt;/li&gt;
  &lt;li&gt;프로젝트 맴버로써 받은 권한에 대한 자부심&lt;/li&gt;
  &lt;li&gt;탐나는 ssh&amp;amp;chromium.org 커미터 이메일 (중요한 동기부여라고 생각한다.)&lt;/li&gt;
  &lt;li&gt;취업에 도움이 될 것&lt;/li&gt;
  &lt;li&gt;좋은 코드를 유지하는 방법에 대해 코드 리뷰를 받으며 성장 기회&lt;/li&gt;
  &lt;li&gt;그리고…. &lt;strong&gt;재미있다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;계속 커밋을 하고 리뷰를 받으며 점점 “내가 Owner로 마크한 이슈들을 해결하는 것”에 책임감을 가지고 조금 더 나은 방향과 좋은 구조를 항상 고민할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;디버깅 관련 지식이 많이 늘어났다.&lt;/p&gt;

&lt;p&gt;chrome://tracing 에서 트레이싱할 수 있는 것들이 정확히 어느 시점에서 (브라우져 내부에서) 기록이 되고 있는지를 그리고 -show-paint-rects와 같은 실제로 draw가 일어나는 영역에 대한 디버깅 관련한 지식을 3D Preserve 관련 패치를 하면서 살펴볼 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109618315-bbaf8180-7b7a-11eb-95d7-1fcbc1159ff0.gif&quot; alt=&quot;Peek 2020-09-14 15-08&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;chromium-개발은-꾸준히-진행-중&quot;&gt;Chromium 개발은 꾸준히 진행 중!&lt;/h3&gt;

&lt;p&gt;그러다가 현재에 와서, Chromium에 정식 기능 추가 절차를 밟으며 CSS에 기능을 추가하는 &lt;strong&gt;“프로젝트”&lt;/strong&gt;를 진행하게 되었다. 처음에는 작은 이슈에 대한 간단한 패치였지만, 이 내용이 커지고 CSS 전반적으로 영향을 미치게 되면서 프로젝트가 되었다.&lt;/p&gt;

&lt;p&gt;Chromium에 feature 도입 상태에 대해 볼 수 있는 곳 Chromium Feature Status에 정식으로 &lt;a href=&quot;https://chromestatus.com/feature/5657825571241984&quot;&gt;등록되어&lt;/a&gt; 었다.&lt;/p&gt;

&lt;p&gt;이 프로젝트를 진행하며 &lt;a href=&quot;https://bit.ly/349gXjq&quot;&gt;Design Docs&lt;/a&gt;를 쓰게 되었는데, 논의가 필요한 부분이 있어서 구글 본사 Chrome 팀 직원분과 Google Meet을 통해 화상통화를 하며 프로젝트에 대해 논의하는 어찌 보면 꿈과 같은 경험을 하게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109618401-d97ce680-7b7a-11eb-99d5-3486e6234614.png&quot; alt=&quot;googlemeet&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109618399-d84bb980-7b7a-11eb-96f9-aec6610565b6.png&quot; alt=&quot;googlemeet2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화상회의 한 번으로 프로젝트의 진행 방향을 어느 정도 정리할 수 있었다.&lt;/p&gt;

&lt;p&gt;(여러 패치로 나누는 것, W3C의 스팩이 부족한 점이 있어서 논의가 필요한 부분이 있다는 것, 이 값에 대한 “animation” 에서의 “보간”에 대해 추후에 논의가 필요할 것 같다 등등)&lt;/p&gt;

&lt;p&gt;이 프로젝트는 현재 진행형이다. 3개의 패치가 이 프로젝트에 대한 패치이다.&lt;/p&gt;

&lt;p&gt;어떤 기능을 함께 만들어나간다는 기쁨을 온몸으로 즐기고 있다.&lt;/p&gt;

&lt;p&gt;느낀것 혹은 얻은 것은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Full Test driven의 이점과 3000만 라인의 거대한 프로젝트가 높은 퀄리티로 유지되는 방법&lt;/li&gt;
  &lt;li&gt;웹 표준의 중요성. Browser 간의 interoperability를 생각하는 능력&lt;/li&gt;
  &lt;li&gt;개발자를 위한 좋은 인프라가 생산성에 어떤 이점을 주는지 (&lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/css/css_value_clamping_utils.h&quot;&gt;Chromium Source Search&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;Code-review의 순기능&lt;/li&gt;
  &lt;li&gt;Blink-dev에 새로 나오는 기능을 살펴보는 습관&lt;/li&gt;
  &lt;li&gt;웹으로 무엇이든 할 수 있게 될 것이라는 생각&lt;/li&gt;
  &lt;li&gt;매우 높은 수준의 개발자들과의 협업&lt;/li&gt;
  &lt;li&gt;스택오버플로우 없이 문제 해결하기 (내부적인 이슈들은 소스코드를 보고 내가 해결해야 한다.)&lt;/li&gt;
  &lt;li&gt;생각보다 웹브라우져에는 버그가 많다 (특히 scroll 쪽 이슈들 )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;혹시 이 글을 보고 Chromium에 흥미가 생겼다면, 오픈소스 개발자의 문은 언제나 열려있다! 누구든 같이 Chromium을 개발하면 좋겠다.&lt;/p&gt;

&lt;p&gt;취준생이 돼서 개인프로젝트도 진행하며 바빠지고, 불안함이 많아졌지만, 시간 날 때마다 책임감을 가지고 활동을 이어나가고 있다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Open Source" /><summary type="html">Chromium에서 활동한 지 반년 정도 되어가는 것 같고, 11개의 패치를 머지시켰다.</summary></entry><entry><title type="html">Chromium, Event Loop는 싱글 스레드</title><link href="https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html" rel="alternate" type="text/html" title="Chromium, Event Loop는 싱글 스레드" /><published>2021-02-25T05:02:20+09:00</published><updated>2021-02-25T05:02:20+09:00</updated><id>https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/02/25/ChromiumEventLoop.html">&lt;p&gt;이곳저곳 코딩테스트를 마치고,&lt;/p&gt;

&lt;p&gt;면접준비를 하면서 Javascript의 Event Loop에 대하여 설명하세요 라는 질문이 자주 나온다는 사실을 알았다.&lt;/p&gt;

&lt;p&gt;내가 기억하는 이벤트 루프는 싱글스레드라서  태스크들을 순서대로 처리한다는 것이었다.&lt;/p&gt;

&lt;p&gt;자바스크립트를 자주 사용했고, 분명 언제 본 내용일 텐데 까먹어서 표준 문서와 브라우져 코드를 좀 보았다.&lt;/p&gt;

&lt;p&gt;검색을 하니까 알기 쉽게 잘 나와 있는 글을 발견했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://meetup.toast.com/posts/89&quot;&gt;https://meetup.toast.com/posts/89&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 글을 보고,  의문점이 좀 생겨 알아보기로 했다.&lt;/p&gt;

&lt;h3 id=&quot;2-이벤트루프의-정의&quot;&gt;2. 이벤트루프의 정의&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#event-loops&quot;&gt;WHATWG의 HTML 표준&lt;/a&gt;에 따르면,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;
To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;“이벤트, 유저 인터렉션, 스크립트, 렌더링, 네트워킹 등등과 같은 것들은 이벤트 루프를 &lt;strong&gt;반드시&lt;/strong&gt; 사용해야 합니다.”&lt;/p&gt;

&lt;p&gt;즉 무엇인가 “일” (화면을 그린다거나, HTML을 파싱한다거나)을 하는 모든 것들은 이벤트 루프를 사용해야 한다고 명시되어 있다. 실제로 표준에서는 구체적으로 어떤 일들이 이벤트 루프를 사용할지 적어두었다.&lt;/p&gt;

&lt;p&gt;내가 이해한 바로는, 웹브라우저가 OS 라고 한다면, Event Loop라는 CPU에서 처리되어야 한다는 느낌을 받았다.&lt;/p&gt;

&lt;p&gt;하지만, 위 구조라면 통신과 같은 작업이 동기적으로 실행되고 이는 HTTP 통신이 있다면 다른 태스크를 실행하지 못한다는 이야기가 된다. 우리가 웹 환경을 이용하면서 통신이 있을 때마다 클릭이 안 된다거나 그런 일은 있지 않았다. 어떻게 된 일일까?&lt;/p&gt;

&lt;h3 id=&quot;3-이벤트루프&quot;&gt;3. 이벤트루프&lt;/h3&gt;

&lt;p&gt;MDN의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop&quot;&gt;Concurrency model and the event loop&lt;/a&gt; 에 따르면, 현대 자바스크립트는 다음 그림으로 설명할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109103285-f32ec000-776d-11eb-8db8-58de71874a3c.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 이미지에서 중요하게 봐야 할 것은 &lt;strong&gt;단일스택&lt;/strong&gt; 이라는 점이다.&lt;/p&gt;

&lt;p&gt;또한 중요하게 다루고 있는 개념이 있는데 &lt;strong&gt;“Run-to-completion”&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;메시지가 처리되고 난 뒤 다음 메시지를 처리하는 것이다. (만약 무한루프와 같이 처리가 끝나지 않는다면 다음 이벤트는 영원히 처리되지 않게 된다. 물론 브라우져에서 이에 대한 alert을 제공한다.)&lt;/p&gt;

&lt;p&gt;위에서 말한 것과 같이 Event Loop 혹은 Message Queue에는 다양한 작업이 들어간다.&lt;/p&gt;

&lt;p&gt;이 다양한 작업 중 하나인 Javascript Execution의 끝은 무엇일까?&lt;/p&gt;

&lt;p&gt;조금 단순히 말하자면, 스택이 비었다→ JS작업이 완료되었다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;그렇다면 여러 콜백 함수, 비동기적인 실행은 어떻게 처리하는 것일까?&lt;/p&gt;

&lt;h3 id=&quot;4-이벤트루프의-내부-구조&quot;&gt;4. 이벤트루프의 내부 구조&lt;/h3&gt;

&lt;p&gt;이벤트루프에 등록된 일들은 태스크라는 단위로 변경되어 브라우져에서 처리된다.&lt;/p&gt;

&lt;p&gt;(사실 크롬에서는 EventLoop 라는 개념이 스팩과 조금 다르게 구현되어 있다.)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;third_party/blink/renderer/platform/scheduler/public/event_loop.h&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // The specification says an event loop has (non-micro) task queues. However,
  // we process regular tasks in a different granularity; in our implementation,
  // a frame has task queues. This is an intentional violation of the
  // specification.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문서와 코드를 좀 보니까, 의외로 금방 찾았는데 MessagePump라는 곳에 있었다.&lt;/p&gt;

&lt;p&gt;Chromium에서의 스케줄링은 다양한 방식으로 진행한다. 그리고 그 스케쥴링의 결과가 아래 함수에서 실행된다.&lt;/p&gt;

&lt;p&gt;아래 코드에서 Task는 이벤트랑은 조금 다른, 브라우져에서 관리하는 실행 컨텍스트이다.&lt;/p&gt;

&lt;p&gt;DoWork 내에서 우리가 알고있는 이벤트 루프의 행위가 벌어진다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:base/message_loop/message_pump_default.cc;l=31;drc=9d1a1d6154cae517f76de279682185c8abc30868&quot;&gt;[여기]&lt;/a&gt; 서 더 자세히 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/18409763/109103312-fd50be80-776d-11eb-894f-6a7a0da624bc.png&quot; alt=&quot;Untitled 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연관된 코드가 너무 많아 다 설명하기 어려울 것 같지만 위 코드면 어느 정도 정리가 될 것 같다.&lt;/p&gt;

&lt;p&gt;위 코드를 보면&lt;/p&gt;

&lt;p&gt;무한루프 속에 태스크가 순차적으로 실행되고 있음을 알 수 있다.&lt;/p&gt;

&lt;p&gt;태스크는 &lt;em&gt;아마도&lt;/em&gt; 스케줄러에 의해 계속 변할 것이다.&lt;/p&gt;

&lt;p&gt;(Event Loop의 경우 microtask를 우선 실행하고, 원래 태스크를 실행하는 그런 일련의 작업)&lt;/p&gt;

&lt;p&gt;메인 Task가 아니거나, 비동기적으로 실행될 수 있는 태스크의 경우 다른 곳에서 실행된다.&lt;/p&gt;

&lt;p&gt;setTimeout, xmlhttprequest와 같은 것은 내부 API를 사용하며, JS에서는 Non-Blocking으로 실행된다.&lt;/p&gt;

&lt;p&gt;이들은 메시지 큐를 콜백 혹은 이벤트를 등록하는 데 사용한다. 만약 async 태스크가 완료되었다면 아까 등록한 이벤트나 콜백을 이벤트루프에 던져서 실행하는 형식이다.&lt;/p&gt;

&lt;p&gt;그렇다면 그때 또 다른 실행 context가 생길 것(스택이 쌓이고 등등..)이고, 그 태스크가 끝나면 다음 이벤트를 처리할 것이다.&lt;/p&gt;

&lt;p&gt;따라서 이벤트루프, 자바스크립트의 동작은 &lt;strong&gt;싱글스레드&lt;/strong&gt; 지만, &lt;strong&gt;내부적인 동작이나, API(DOM API 등) 들은 다른 Thread를 활용할 수도 있다&lt;/strong&gt;. 하지만 이러한 요청과 결과는 이벤트 루프에 의해 순차적으로 처리된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;부족한 내용이나, 틀린 내용이 있으면 언제든지 댓글을 …&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="Javascript" /><category term="Web Sepc" /><summary type="html">이곳저곳 코딩테스트를 마치고,</summary></entry><entry><title type="html">html webpack plugin URL undefined 이슈</title><link href="https://devsdk.github.io/ko/development/2021/02/18/Webpack-HtmlLoader-Issue.html" rel="alternate" type="text/html" title="html webpack plugin URL undefined 이슈" /><published>2021-02-18T05:02:20+09:00</published><updated>2021-02-18T05:02:20+09:00</updated><id>https://devsdk.github.io/ko/development/2021/02/18/Webpack-HtmlLoader-Issue</id><content type="html" xml:base="https://devsdk.github.io/ko/development/2021/02/18/Webpack-HtmlLoader-Issue.html">&lt;p&gt;짧은 포스팅&lt;/p&gt;

&lt;p&gt;WebPack에는 html-webpack-plugin 이라는 플러그인이 있다.&lt;/p&gt;

&lt;p&gt;HTML을 불러와서 컴파일 한 녀석에 붙여주는 역할을 한다. 링커랑 비슷한 것 같기도 하다.&lt;/p&gt;

&lt;p&gt;DFD의 favicon을 추가하는 작업을 하다가 계속 이 에러메시지를 보았다.&lt;/p&gt;

&lt;p&gt;&amp;lt;link rel=”icon” type=”image/x-icon” href=”static/favicon.ico” /&amp;gt; 이 태그가 들어가면,&lt;/p&gt;

&lt;p&gt;정확히는 href가 포함된 태그가 들어가면 아래와 같은 메시지를 내보내며 컴파일 에러를 띄운다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ERROR in   Error: /home/seokho/projects/DFD-WEB/public/index.html:147
  var ___HTML_LOADER_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./static/favicon.ico */ &quot;./public/static/favicon.ico&quot;), __webpack_require__.b);
                                   ^
  ReferenceError: URL is not defined
  
  - index.html:147 
    /home/seokho/projects/DFD-WEB/public/index.html:147:34
  
  - index.html:153 
    /home/seokho/projects/DFD-WEB/public/index.html:153:3
  
  - index.html:156 
    /home/seokho/projects/DFD-WEB/public/index.html:156:12
  
  - index.js:136 HtmlWebpackPlugin.evaluateCompilationResult
    [DFD-WEB]/[html-webpack-plugin]/index.js:136:28
  
  - index.js:333 
    [DFD-WEB]/[html-webpack-plugin]/index.js:333:26
  
  - async Promise.all
  
  - async Promise.all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;왜 그런 것이지 하고 검색을 해도 방법이 잘 나오지 않았다.&lt;/p&gt;

&lt;p&gt;의심한 건 가장 첫 번째로 노드 버전이다.&lt;/p&gt;

&lt;p&gt;아니나 다를까 버전이 아주 낮았다. 업데이트해도 해결이 되지 않았다.&lt;/p&gt;

&lt;p&gt;그래서 HtmlWebpackPlugin 이쪽 코드를 한번 보자고 깃헙에 들어가서 소스를 읽고 이슈리스트를 보았다.&lt;/p&gt;

&lt;p&gt;아니나 다를까, 3일 전에 2.0으로 업데이트된 html-loader 라는 녀석에서 발생하는 이슈였다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jantimon/html-webpack-plugin/issues/1602&quot;&gt;https://github.com/jantimon/html-webpack-plugin/issues/1602&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이슈가 해결되는 패치가 등장하기 전까진,&lt;/p&gt;

&lt;p&gt;html-loader 버전을 2.0에서 1.3.2 으로 다운그레이드 하는것으로 해결&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Webpack" /><category term="html" /><category term="Web" /><summary type="html">짧은 포스팅</summary></entry><entry><title type="html">Chromium CSS에 무한과 NaN 개념 도입하기 - 1</title><link href="https://devsdk.github.io/ko/chromium/2020/12/24/ChromiumCSSInfinityAndNaN-1.html" rel="alternate" type="text/html" title="Chromium CSS에 무한과 NaN 개념 도입하기 - 1" /><published>2020-12-24T00:00:20+09:00</published><updated>2020-12-24T00:00:20+09:00</updated><id>https://devsdk.github.io/ko/chromium/2020/12/24/ChromiumCSSInfinityAndNaN-1</id><content type="html" xml:base="https://devsdk.github.io/ko/chromium/2020/12/24/ChromiumCSSInfinityAndNaN-1.html">&lt;p&gt;Issue: &lt;a href=&quot;http://crbug.com/1133390&quot;&gt;http://crbug.com/1076508&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Patches:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://chromium-review.googlesource.com/c/chromium/src/+/2465414&quot;&gt;https://chromium-review.googlesource.com/c/chromium/src/+/2465414&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;현재 진행 중인 프로젝트에 대한 활동 기록을 이 블로그에 적고자 한다.&lt;/p&gt;

&lt;p&gt;아무래도 기능 추가에 관련된 이야기다 보니 글이 몇 개로 나누어질 것 같다.&lt;/p&gt;

&lt;p&gt;이 글은 이 기능을 구현하면서 고민하고, 조사했던 내용을 담았다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/calc()&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/CSS/calc()&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CSS에는 calc라는 함수가 있다.&lt;/p&gt;

&lt;p&gt;이 함수를 CSS에서 직접 사용하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 결과는 20px값이 width에 반영된다.&lt;/p&gt;

&lt;p&gt;앞으로 다룰 내용은 이 함수에 대한 기능 구현이다.&lt;/p&gt;

&lt;p&gt;Chromium monorail에서 할만한 이슈를 찾던 중, 이 이슈가 눈에 들어왔다.&lt;/p&gt;

&lt;p&gt;간결하디간결한 이슈 본문을 보니 간단할 것이라고 생각했다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I'm told that per the spec, calc(1px/0) should compute to infinity and not be a parse error.

Testcase:
&amp;lt;div style=&quot;width: calc(1px/0); height: 10px; background: green;&quot;&amp;gt;&amp;lt;/div&amp;gt;
http://plexode.com/eval3/#s=aekVQXANJVQMbAx1yAXgePQOCGwFEQk1ECRJRWRARChwBg50SEaWqi51IU0ZGTxyaHx0Qch8DXgA=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;요약하자면 1px/0을 했을때 무한을 내놔야 합니다. 라는 내용이다.&lt;/p&gt;

&lt;p&gt;이것이 이번 프로젝트의 발단을 알린 첫 이슈의 제시문이였다.&lt;/p&gt;

&lt;p&gt;이슈가 제시되었을 때, 부랴부랴 표준 문서를 읽어보았다. 
CSS3와 MDN을 기준으로 “0으로 나누기는 무시되어야 합니다” 라고 쓰여있었다.&lt;/p&gt;

&lt;p&gt;그래서 이슈 제시자한테 표준에 따르면 나누기 0은 무시되어야 한다는데 출처 있니? 라고 물어보았고, 제시자는 “새로운 스팩 CSS Values and Units Module Level 4”를 참조로 알려주었다. 즉, 표준에 따르면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무한&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NaN&lt;/code&gt; 개념을 calc 함수가 지원해야 했다.  그 답을 보자마자 이슈 owner를 박고 조사를 시작했다.&lt;/p&gt;

&lt;p&gt;처음으로 한 것은, calc 함수가 어디서 계산이 되는가를 찾는 것이었다.&lt;/p&gt;

&lt;p&gt;기본적인 생각은 다음과 같았다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc 함수는 CSS 파서에 의해서 계산될 것&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다음의 명령어를 치면 결과를 사람이 구별할 정도로 줄어든다.&lt;/p&gt;

&lt;p&gt;그곳에서 parser 디렉토리 쪽 코드를 살펴보았다.&lt;/p&gt;

&lt;p&gt;명령어를 좀 설명하자면 대소문자 상관없이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc(&lt;/code&gt; 문자가 매칭되는 test.cc가 아닌 .cc 파일로 끝나는 파일을 검색하여 리스트로 나타내라 이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'calc('&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rni&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--include&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.cc &lt;span class=&quot;nt&quot;&gt;--exclude&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;test.cc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/1.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그중에서 눈에 띄는 주석이 있다.&lt;/p&gt;

&lt;p&gt;이 글을 쓰면서 생각난 것이지만, k&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;토큰 이름&lt;/code&gt;으로 도 검색할 수 있었다고 생각한다. (i.e. kCalc) 이는 크로미움에서 json5 파일을 통해 토큰 식별자를 자동생성하는 메커니즘 덕분에 떠올릴 수 있었다.&lt;/p&gt;

&lt;p&gt;하여튼 저곳을 들어가면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/2.png&quot; alt=&quot;2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 코드를 볼 수 있는데, 이 말은 kCalc 함수에 대하여 참조하는 곳을 찾아서 수식이 계산되는 곳을 찾으면 된다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/3.png&quot; alt=&quot;3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10개 남짓한 레퍼런스를 보며 소스코드를 보다 보면 third_party/blink/renderer/core/css/css_math_expression_node.cc 코드 안에 관련 코드가 있음을 찾을 수 있다. (대부분 코드는 이렇게 검색할 수 있다)&lt;/p&gt;

&lt;p&gt;일단 calc 함수는 재귀적인 방식을 통해 괄호와 사칙연산을 계산한다. 꽤 재밌는 부분인데 좀 간략히 설명하자면, parse 함수 호출→ Additive 함수 호출 → Multiplicative 함수 호출 → parse 함수 호출(재귀) 방식으로 사칙연산의 우선순위를 제공하고 있다.&lt;/p&gt;

&lt;p&gt;사실 이러한 구현은, 웹 표준에서 정의하고 있다.&lt;/p&gt;

&lt;p&gt;아래는 표준 문서에서 나타낸 식의 계산이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/4.png&quot; alt=&quot;4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/5.png&quot; alt=&quot;5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 내용을 깊이 따라가는 것도 꽤 재밌는 일이다. &lt;a href=&quot;https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/css/css_math_expression_node.cc;l=1101;drc=8b5f6ef28dd93e62fc1a75bc7a812af1b33777ec&quot;&gt;이곳이&lt;/a&gt; 실제 소스코드를 따라가기 좋은 시작 포인트라고 생각된다. 관심 있으면 링크를 타고 가서 보길 바란다.&lt;/p&gt;

&lt;p&gt;이제 시작점을 알았으니 값이 계산되는 부분을 찾고, 들어오는 문자열을 이용하여 infinity와 NaN을 구현하면 되는 것이다.&lt;/p&gt;

&lt;p&gt;사실 첫 패치에선 NaN을 명시적으로 구현해야 함을 모르고 있었다. 따라서 코드리뷰를 통해 NaN 또한 추가되었다. 이번 포스팅에선 NaN을 다루는 이야기는 나오지 않을 것이다.&lt;/p&gt;

&lt;p&gt;함수 콜을 잘 따라가다 보면 이러한 함수에 도달한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/6.png&quot; alt=&quot;6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;즉 실질적인 계산을 담당하는 함수다.&lt;/p&gt;

&lt;p&gt;무한을 구현하는 것을 정말 간단하게 생각하자면, case CSSMathOperator::kDivide: 에서 right_value가 0이라면 std::numeric_limits&amp;lt;double&amp;gt;::infinity() 를 리턴하면 되는 것이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 다음과 같이 추가하였다.
&lt;img src=&quot;/uploads/2020-12-23/11.png&quot; alt=&quot;11.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한 토큰에 대하여&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/7.png&quot; alt=&quot;7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;와 같이 infinity가 왔을 때 해당하는 형식으로 반환하게 하면 될 것이라고 생각했다.&lt;/p&gt;

&lt;h4 id=&quot;테스트-작성&quot;&gt;테스트 작성&lt;/h4&gt;

&lt;p&gt;위 코드와 함께 test 코드를 작성했다.&lt;/p&gt;

&lt;p&gt;테스트 코드를 작성하면서 문제가 되었던 점은 round 함수가 없어 wpt 테스트가 실패하는 것과 blink_unittests 결과가 계속 실패하여 찾아보니 유닛테스트에는 다른 모듈을 이용하여 calc를 계산하고 있음이었다.&lt;/p&gt;

&lt;p&gt;블링크 유닛테스트에는 calc 함수에 대해 다른 파서인 sizes_math_function_parser를 이용하여 파싱을 한다. 따라서 그에 해당하는 테스트인 sizes_math_function_parser_test.cc에서 테스트를 진행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/8.png&quot; alt=&quot;8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 테스트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;third_party/blink/renderer/core/css/parser/sizes_math_function_parser.cc&lt;/code&gt; 안에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CalcToReversePolishNotation&lt;/code&gt; 함수를 통하여 파싱이되고 계산이 된다. 스택 기반으로 작성되어 있다. 따라서 이곳에 우리가 필요했던 코드를 넣어줘야 했다. 
각각 무한을 스택에 집어넣는 AppendInfinity() 함수를 정의하여 사용하였다.&lt;/p&gt;

&lt;p&gt;다음은 스택에서 토큰을 만났을 때 문자열을 비교하여 infinity일시 무한을 집어넣는 코드이다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kIdentToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EqualIgnoringASCIICase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;infinity&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;EqualIgnoringASCIICase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-infinity&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;AppendInfinity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이를 통해 유닛테스트 부분은 해결할 수 있었다.&lt;/p&gt;

&lt;p&gt;또한, blink_web_tests에 새로운 테스트 파일들을 추가하였다.&lt;/p&gt;

&lt;p&gt;자바스크립트 기반의 테스트를 작성하였고, dumpAsText() (이 함수를 호출하면 -expected.txt 라는 파일의 렌더링 결과 텍스트와 비교한다. 간단히 말하면 화면에 나오는 텍스트를 덤프 뜨는 것)를 사용하였다.&lt;/p&gt;

&lt;p&gt;아래는 새로 추가한 blink/web_tests/css3/calc/calc-infinity.html 파일이다.&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dummy&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;results&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;Calc could handle an infinity value&lt;span class=&quot;nt&quot;&gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;testRunner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;testRunner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;dumpAsText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * infinity / infinity&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * 0 * infinity&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * (infinity + -infinity)&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * (-infinity + infinity)&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * (infinity - infinity)&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * infinity&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * -infinity&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * (infinity + infinity)&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * (-infinity + -infinity)&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * 1/infinity&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * infinity * infinity&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1px * -infinity * -infinity&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dummy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;dummy&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;expression&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;dummy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;calc(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;expression&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHTML&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;expression&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; =&amp;gt; &lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;dummy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 결과는 blink/web_tests/css3/calc/calc-infinity-expected.txt 파일로 다음과 같이 저장되고 추후에 테스트에 사용된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Calc could handle an infinity value

1px * infinity / infinity =&amp;gt;
1px * 0 * infinity =&amp;gt;
1px * (infinity + -infinity) =&amp;gt;
1px * (-infinity + infinity) =&amp;gt;
1px * (infinity - infinity) =&amp;gt;
1px * infinity =&amp;gt; calc(infpx)
1px * -infinity =&amp;gt; calc(-infpx)
1px * (infinity + infinity) =&amp;gt; calc(infpx)
1px * (-infinity + -infinity) =&amp;gt; calc(-infpx)
1px * 1/infinity =&amp;gt; calc(0px)
1px * infinity * infinity =&amp;gt; calc(infpx)
1px * -infinity * -infinity =&amp;gt; calc(infpx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;패치-작성&quot;&gt;패치 작성&lt;/h4&gt;
&lt;p&gt;테스트와 소스코드를 추가한 한 뒤, 이렇게 완성한 패치를 git cl format을 통해 포멧팅을 하고, 소스코드를 정리하는 등 적절히 정리하여 아래와 같은 커밋메시지와 함깨 패치를 올렸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/9.png&quot; alt=&quot;9.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2020-12-23/10.png&quot; alt=&quot;10.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여러 글로 나뉠 것 같았는데, 이번 글은 여기서 끊는 게 맞을 것 같다.&lt;/p&gt;

&lt;p&gt;다음 글에는 이 패치에 대한 코드리뷰, 그리고 그것에 대한 반영 부분일 듯하다.&lt;/p&gt;</content><author><name>Seokho Song</name><email>0xdevssh@gmail.com</email></author><category term="Chromium" /><category term="C++" /><category term="Web Engine" /><category term="HTML/CSS" /><category term="InfinityAndNaN" /><category term="DevLog" /><summary type="html">Issue: http://crbug.com/1076508</summary></entry></feed>