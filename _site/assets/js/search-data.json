var store = [{
        "title": "Start up! DevSDK's blog",
        "excerpt":"This time, I will start my new Jekyll + GithubIO blog. This blog’s goal is devlog, technical documents. I felt quite annoyed when I build up this blog because I spent a lot of time choosing damm jkyll skin. Chosen skin’s colors weren’t satisfied for me, so I modified CSS to change it. Also, I appended tag system. I found some improvement points in this blog. Well, Recently I develop: Game Engine GitHub And the Operating System for studying called 0SOS. I will write posts when I develop that. ","categories": ["development"],
        "tags": ["Jekyll","GitHubIO"],
        "url": "https://devsdk.github.io/development/2017/06/26/FirstPost.html"
      },{
        "title": "About Custom Allocator in Comet Engine",
        "excerpt":"For the last two weeks, I’ve been thinking that should implement a custom allocator. As you know, if you use a system allocator, you have to use Malloc in C and New in C++. The problem is the speed. The current method is far too slow for me when I want to use a fast system for the MS unit. First of all, I can’t ignore the cost of the User-Kernel Mode Context Switch when allocating memory. There’s also an additional code that makes it slow. I’ve been mulling over the question “When do I need a really fast code requirement or fastest allocator?” As you can see, One of the solutions is to remove the allocator in the code. Like a making all thing by the stack. But I hate that. A bit unexpectedly, I read some documents and found some interesting stuff about the allocator structure. Pool based memory allocators, Stack-based memory allocators, and Paging addresses with segmentation like OS are candidates for allocators, but they create some problems like free and continuous memory blocks. And It’s so complicated. Then, I found a FreeList Based Allocator document.  Above is the visualization of the Free List Structure. A simple summary of the above: After creating a Linked List in the memory’s free space, we slice and provide memory in that list when we try to allocate memory. When we do Free, make sure to attach that list. (Of course say specifically, it is adjacent. We can make some process like growing the previous block) Internally: While allocating the memory, we implant the 16-byte size Header in that allocated block and provide that block memory’s address after 16 bytes to users. In other word, Real Allocating size = Request size + Header Size + Align Offset. After that, we can simply do Free by reading the header information. When we do Free that Memory block was contained Header, we make to FreeList-Node and link to Free List. Simple. Anyway, I’ve been implementing that stuff in my own Engine  If you want to see the source code for that LINK. (FreeListAllocator Class) How to use it: char* MemoryBlock = new char[1024 * 1024 * 10];Memory::FreeListAllocator allocator = Memory::FreeListAllocator(MemoryBlock, 4, 1024 * 1024);Assign the memory block for Allocator. And Initialize FreeListAllocator. allocator.alloc(size_t);allocator.dealloc(void*);Each function is used to memory allocating and free. Well, as you can see from the image above, it is well-worked. Also, keep that alignment. Because I implemented that, Let’s prove it is faster than System allocator. I believe that it is faster than the system stuff so, I made a test. Test condition: Allocate 10000 times int type array size 1000 ( sizeof(int)*1000) iteration 10000 time. ) The result is 10 times faster than before.             System Alloc      Custom Alloc      System Free      Custom Free                  0.0120 s      0.0015 s      0.0091 s      0.0013 s      Well, I appreciate this code. Good. That is fast. Later, I think it would be good to attach a Proxy and include a profiler or Leak Management system. ","categories": ["development"],
        "tags": ["CometEngine","GameEngine","Memory","Optimization"],
        "url": "https://devsdk.github.io/development/2017/06/26/Custom-Allocator.html"
      },{
        "title": "Memory bug on the Visual Studio 2017",
        "excerpt":"[Addition] It wasn’t a debugger issue. I guess this is the visual studio’s problem. I found the same issue without debugging. First of all, this is just my supposition, so, it’s possible that this isn’t VS’s problem. I think this is made by one of the VS’s so many processors. In the case that is a VS problem, I can’t do anything, so I’m not sure I can even research what the problem is, but I noticed when VS  was closed then the memory usage return to normal. Because of that, I guess I’ll have to solve the issue by researching some of the cases that cause processors to by killed when closing VS I experienced this stuff a while ago. I noticed this happened on Visual Studio 2017 first. On 2010, 2013 and 2015, I didn’t experience this…. or I maybe I used, it after 2015 on a laptop? anyways, I wasn’t sure when it happened. When the environment was Laptop: I didn’t know why, but this time when I closed my laptop while running C# WPF solution Debug mode and without running C++ solution, I got a lot of lag because they use all of the memory. It was impossible out of the memory on my laptop if that was a normal program. Anyways, I felt delay and I wanted to know what happened so I open task manager. I got a shock.  It takes 31GB memory. I guess one of the Visual Studio processors is going to explode. I didn’t know why. I couldn’t act in that situation. It made me confused. ","categories": ["development"],
        "tags": ["VisualStudio","Memory","Bug"],
        "url": "https://devsdk.github.io/development/2017/06/26/Visual-Studio-2017-Memory-Bug.html"
      },{
        "title": "OS DevLog-Let's push into the frame buffer.",
        "excerpt":"I hadn’t been looking for other modes, and I didn’t know anything about the GUI Framebuffer yet so, I wrote this; my area of expertise. In real-mode, the text video memory address is 0xB800. A single character takes 2 bytes. The first byte is the ASCII code and the second byte is attribute value. If you want to see specifics, here In case you’ve written a bootloader or something, we can display the characters on the screen when we push an order into 0xB800  like ‘H’, (attribute), ‘E’, (attribute)… We definitely couldn’t see clearly without initialization. We need to clear in the existing (QEMU) BIOS’s data. In order to do the above, we need to clear the frame buffer. (setting 0) When clearing, insert the attribute in the framebuffer. [ORG 0x00]              ; Start Address 0x00[BITS 16]               ; 16 bit codesSECTION .text           ;text section.jmp 0x07C0:START        ;Jump to code startpoint.START:    mov ax, 0x07C0      ; Bootloader start address (before that containing something stuff.)    mov ds, ax          ; assign data segment address    mov ax, 0xB800      ; assign video memory address    mov es, ax    mov si, 0           ; register for string indexing    .SCREENCLEARLOOP        ; Label for screen clear    mov byte[ es: si],0 ; Interation from 0xB800 by size    mov byte[ es: si + 1], 0x0A    add si,2    cmp si, 80*25*2     ; If *si* is smaller than 80*25*2 (size of video memory), run codes below.    jl .SCREENCLEARLOOP ; Iteration    mov si, 0           ;Initialization    mov di, 0.MESSAGELOOP:           ; Label of displaying message on screen    mov cl, byte[MESSAGE1+si]   ;It's like array[i] in C Language. Checking Message1    cmp cl, 0                   ;If this meet 0,    je .MESSAGEEND              ; exit    mov byte[es:di],cl        add si, 1                   ;Index for character    add di, 2                   ;Index for video memory    jmp .MESSAGELOOP.MESSAGEEND    jmp $MESSAGE1:   db 'Hello World. Boot Loader Start', 0 times 510 - ($-$$) db 0x00db 0x55db 0xAAI added the comment. Well,  It worked clearly. As you can see, it isn’t a bootloader. It is just binary for displaying characters on the framebuffer If you say “What is different about printing ‘Hello world!’ in C?”, Just close this posting. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","FrameBuffer"],
        "url": "https://devsdk.github.io/development/2017/06/27/Develop-OS.html"
      },{
        "title": "How to access memory in Real-Mode",
        "excerpt":"I have just wasted 2 hours because I just forget things. I’m sure I’ve already read it before but why did I forget? I’ve rattled my brains 2 hours because I saw that 0x020 shows as 512 in the ES register. As you can see the value is 32. It definitely wasn’t 512. Don’t forget, in the real-mode, segment registers such as CS, DS, ES, FS, and SS are used for addressing physical memory addresses by multiplying 16 and adding the general register value. In another word, to ASM. mov si, 0x0020 mov es, siIf you see code like this, you can just imagine that 0 is added onto the end figure. It’s is obviously basic stuff even I read before but forgot. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Memory"],
        "url": "https://devsdk.github.io/development/2017/06/27/RealModeMemory.html"
      },{
        "title": "When you read a book and find something odd check if it was a misprint",
        "excerpt":"When I read OS book descriptions, I focus on example code within my expertise On page 149, Function Call. The issue was, just one variable was contained in the function on the stack frame, but the stack pointer was decreased by 8byte. After that page was something weird. I’ve tried to find whether it was a misprint or not in the online community. The author said, he pasted Visual Studio’s code into the book. Obviously, VS caused a weird result.Anyways, The code that took up my time was:     int Add(int a, int b, int c)    {        return a+b+c;    }    void main()    {        int Result;        Result = Add(1,2,3);    }I knew that void main wasn’t standard.  That part was written in the book. The code above to assembly: Add:    push ebp    mov ebp, esp        mov eax, dword[ebp + 8]    add eax, dword[ebp + 12]    add eax, dword[ebp + 16]    pop ebp        ret 12main:    push ebp    mov evp, esp    sub esp, 8    push 3    push 2    push 1    call Add    mov dword[ebp - 4],eax    retIt would be changed like this above. The problem was three lines below from the main function and two lines above from last: sub esp, 8mov dword[ebp - 4], eaxI wondered what the hell was going one with the 4 bytes from the stack frame. I didn’t know whether there was an internal requirement or whether it was. Anyways, that had just one variable in C code definitely. So I didn’t know why need 8 bytes. When I studied Compiler, I learned the memory assigned in stack per variable size. So it was something weird. It is different when I develop the OS? I’m not thinking like that so, I tried to find inserting something into stackframe but it wasn’t After then, I ask author and author said, I wrote this code by VS’s assembly code. Anyways, Maybe the correct code is: sub esp, 4mov dword[ebp], eaxAuthor said that is correct ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","function"],
        "url": "https://devsdk.github.io/development/2017/06/27/Do-not-believe-examplecode-in-a-book.html"
      },{
        "title": "The first 0SOS's BootLoader.",
        "excerpt":"Something learning gives me pleasure. Of course, If you want to memorize something effectively, you should have a hard time learning. So I’m trying to avoid copy example code from the book. I tried to change variable name, order and rewrite to a function. Well, It’s so fun while I tried to do something and got trouble. As you know, It needs much time than before. In this time, It can be called a bootloader. Of course, This bootloader aimed to the floppy disk, but later, It can be changed hard disk. I decided to satisfy for now because I’m a learner. When I execute the bootloader:  It’s worked! You can see the number 1234567 in the image because I need to detect this bootloader has errors. So I wrote this code for jumping to loaded memory. (I’m already set up an increasing number on loaded memory (also it can’t be upper than 10 because that is ASCII value.)) The count of the number is exactly 1024. That is the count of a loaded sector. Anyway, The steps of bootloader are the following: Initialize register(Stack, Adress, …) on the start point. After then execute the message print function. The calling conversion is cdecl on the C Language. Because of the caller clean up the stack. Anyway, it isn’t point. No problem when it changed stdcall. For BIOS services, We need to call interrupt. When it makes some errors, it would be handled by an error handler. If not, Complete. And then jump to the loaded memory. Code [ORG 0x00][BITS 16]SECTION .textjmp 0x07C0:START;;;;;;;;;;;;;;;;;;;;; CONFIG ;;;;;;;;;;;;;;;;;;;;;;TOTALSECTOR: dw 1024 ;START:    mov ax, 0x07C0    mov ds, ax    ;;;;;;;;;; STACK INITALIZATION ;;;;;;;;;;    mov ax, 0x0000    mov ss, ax    mov sp, 0xFFFE    mov bp, 0XFFFE    mov si, 0    call CLEAR     ;;;;;;;;;; PRINT HELLO ;;;;;;;    push HELLO    push 0    push 0    call PRINT    add sp, 6    ;;;;;;;;;; PRINT LOAD INFO ;;;;;;    push LOADINFO    push 0    push 1    call PRINT    add sp, 6    DISKRESET:    mov ax, 0    mov dl, 0    int 0x13    jc ERRORHANDLER    ;;;;;;;;;;; READ DISK SECTOR ;;;;;;;    mov si, 0x1000    mov es, si    mov bx, 0x0000    mov di, word[TOTALSECTOR].READ:    cmp di, 0    je BREAKREAD    sub di, 0x1    mov ah, 0x02    mov al, 0x1    mov ch, byte[TRACK]    mov cl, byte[SECTOR]    mov dh, byte[HEADER]    mov dl, 0x00    int 0x13    jc ERRORHANDLER    ;;;;;;;;;; calculate Address    add si, 0x0020    mov es, si    mov al, byte[SECTOR]    add al, 0x01    mov byte[SECTOR],al    cmp al, 19    jl .READ    xor byte[HEADER], 0x01    mov byte[SECTOR], 0x01    cmp byte[HEADER], 0x00    jne .READ    add byte[TRACK], 0x01        jmp .READBREAKREAD:    push LOADSUCCESS    push 24    push 1    call PRINT    add sp,6    jmp 0x1000:0x0000ERRORHANDLER:    push DISKERROR    push 24    push 1    call PRINT    jmp $PRINT:    push bp,    mov bp, sp        push es    push si    push di    push ax    push cx    push dx        mov ax, 0xB800    mov es, ax    mov ax, word[bp + 4]    mov si, 160    mul si    mov di, ax    mov ax, word[bp + 6]    mov si, 2    mul si    add di, ax    mov si, word[bp+8].PRINTLOOP    mov cl, byte[si]    cmp cl,0    je .ENDPRINTLOOP    mov byte[es:di], cl    add si, 1    add di, 2    jmp .PRINTLOOP.ENDPRINTLOOP    pop dx    pop cx    pop ax    pop di    pop si    pop es    pop bp    retCLEAR:    push bp    mov bp, sp        push es    push si    push di    push ax    push cx    push dx    mov ax, 0xB800    mov es, ax    .CLEARLOOP:    mov byte[es:si],0    mov byte[es:si+1], 0x0B    add si,2        cmp si,80*25*2    jl .CLEARLOOP        pop dx    pop cx    pop ax    pop di    pop si    pop es    pop bp    ret    HELLO: db 'Welcome To 0SOS.',0DISKERROR: db 'ERROR', 0LOADSUCCESS: db 'SUCCESS',0LOADINFO: db 'Now Loading From DISK...', 0SECTOR:    db 0x02HEADER:    db 0x00TRACK:    db 0x00times 510 - ($ - $$) db 0x00db 0x55db 0xAAIt worked correctly. Now, It time to take 32-bit mode. Before that, I should complete another working. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Booting","function"],
        "url": "https://devsdk.github.io/development/2017/06/27/MyFirstBootLoader.html"
      },{
        "title": "Thinking about Container Library in Comet Engine",
        "excerpt":"I want to develop this game engine slowly and completely. So, I’d like to wish this fast and strong The first step is Custom Allocator providing. You can see about that Anyway, I hope to construct step by step from the low-level subsystem to the editor. Well, I didn’t have a deadline. (Maybe 2 years?) The second step is container designing and implements for providing a container library. I should make this twice version: Custom Allocator version and System Allocator version. It’ll be faster than STL. Of course, In case the same algorithm. Also, It’s more comfortable for maintaining. Now concerning thing is: What is the best prefix for the Custom Allocator version? One of the prefixes is C.     CArrayList&lt;int&gt;Well, I’m not sure it is the perfect prefix, but it is exactly matched with Game Engine’s name. On the other hand, The System Allocator version will not take any prefix. Maybe, the System allocator will use Virtual Alloc. Also, I concern about the namespace. Maybe the candidates are: CometEngine::Core::Container::C //Custom AllocatorCometEngine::Core::Container::S //System Allocatoror without S and C in the namespace. I should hard work to organize those classes. Also, It isn’t urgent work, so I should think more slowly. I have to see STL internal. Addtion Ah, Damm it, About constructing thread-safe. That concerning are making more gray hairs. ","categories": ["development"],
        "tags": ["CometEngine","GameEngine","Container","Library","Optimization"],
        "url": "https://devsdk.github.io/development/2017/06/28/ContainerConcerning.html"
      },{
        "title": "Approximately, I thought an idea for the container of Comet Engine.",
        "excerpt":"Recently, I’m enjoying developing the OS. Is the reason fresh? So I think this project will be freeze… I mean, It is not completely frozen. I’ll make it very slowly. I can take it after a few weeks rest. Um, I  a few weeks too much. Hum.. a few days? I guess? Today, I decided to focus on the Game Engine. First of all, I fixed warnings in Custom Memory on Visual Studio. When I change c style casting to static_cast, that error has been removed. Anyway, I should make the library that wasn’t tiny, called Container. So, I drew UML instead of the code. Reference is Java’s Container and C#’s Collection. Also, I referred to C++’s STL.  It wasn’t’ had detail like the name of the functions and member. It just had a silhouette… After that, I should consider this with paper writing. I’ll add patterns like Iterator later. Anyway, I make a Custom Allocator, so why don’t I develop the Container. Well, Because custom allocator has a limitation of the memory size (They require the Memory blocks), I should implement the wrapper for the resizable memory structure. Haa, I guess I’ll get a headache even I just concern about it. As you know, the Array List is easy for that but Linked List is…… Roughly, I should write abstraction for memory require code. I’m not sure how can I solve when the memory pointer address is changed. One of the solution: On the user-side must not access in data address. Well, I’m not implementing the foundation of this system yet. Also, something that I should concern is how can I guarantee thread-safe between containers. I think I should get gray hair….. I need to draw a simple design of functions and requirements, or not immediately… If I read and examine STL’s internal source code, it’ll give some inspiration I guess, but I don’t want to do like that because they had a lot of damm template. The aim is faster than STL. I felt some depression when I thought that I should touch my game engine project sometimes Also, I want to develop the OS at the same time… I need more time to split. ","categories": ["development"],
        "tags": ["CometEngine","GameEngine","Container","Library","Optimization"],
        "url": "https://devsdk.github.io/development/2017/06/28/Design-of-the-GameEngine.html"
      },{
        "title": "0SOS's 32bit mode, Hello 32bit ProtectedMode",
        "excerpt":"Hooray!! Now, 0SOS can execute the 32-bit code as well. That mean, We can use 32bit general registers. Like eax, esi registers. I’m so glad. Look at this:  As you can see, It is completely working. If you say like this: “I can simply do it, using C Language” Please, Close this post. Anyway, I’ve made an effort for understanding. And success! Dammit… Especially, segment table, the range of used memory and stack makes me a headache. First of all, Following steps are the description for change 16-bit real-mode to 32-bit protect-mode: First, Organize a GDT table, and then addressing GDT to the processor. That table’s first elements is NULLDescriptor that is filled 0 in Descriptor element. Second, We need to define descriptor. Me and author insert Code and Data segment descriptor in GDT. This step makes me much harder to understand. I guess code and data descriptor shouldn’t overlap. Something weird is the base address of descriptor and access limitation are the same. But I just miss understanding. Dammit… Eventually, on the current code, specifically on the defined table, segment descriptors doesn’t sperate the code and data area of the memory. Both of them could address the 0~4GB memory area. Also, the stack couldn’t be overlapped because stack grows downwards from the top. (Because that have a 64kb limit. You should see esp and ebp in the code) So We can find an expression of calculation for a relative address on the example code. Like (LABEL - $$ + 0x10000). Anyway, I understand completely. And then, Third, Set up CR0 Register that manages operating mode. You can see the table of the setup value below. And If you want to find more, google it. After then, You just jump to the 32-bit code area. Yeah! Anyway below code is the entry point of my kernel for the 32-bit system: [ORG 0x00][BITS 16]SECTION .textSTART:    mov ax, 0x1000    mov ds, ax    mov es, ax        cli        ;Ignore Interrupt    lgdt[GDTR]    ;    Now Switch Protected Mode.    ;    ;   CR0 Register    ;    Summary:     ;        Disable Paging, Disable Cache, Internal FPU, Disable Align Check    ;    ;   fields:    ;    ;    |PG|CD|NW|  |  |  |  |  |  |  |  |  |  |AM|  |WP|    ;    31---------------------------------------------16    ;    | 0| 1| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 0|    ;    ;    |  |  |  |  |  |  |  |  |  |  |NE|ET|TS|EM|MP|PE|     ;    15----------------------------------------------0    ;    | 0| 0| 0| 0| 0| 0| 0| 0| 0| 0| 1| 1| 1| 0| 1| 1|    ;    ;    0b01000000000000000000000000111011        ;     0x4000003B    ;    mov eax, 0x4000003B    mov cr0, eax    jmp dword 0x08 : (PROTECTEDMODE - $$ + 0x10000)    ; Following Code Now Protected Mode[BITS 32]PROTECTEDMODE:    mov ax, 0x10    mov ds, ax    mov es, ax    mov fs, ax    mov gs, ax    mov ss, ax    mov esp, 0XFFFE    mov ebp, 0XFFFE            push (SWITCHMESSAGE - $$ + 0x10000)    push 2    push 0    call PRINT    add  esp, 12    jmp $PRINT:    push ebp    mov ebp, esp    push esi    push edi    push eax    push ecx    push edx    mov eax, dword [ebp + 12]    mov esi, 160    mul esi    mov edi, eax            mov eax, dword[ebp + 8]    mov esi, 2    mul esi    add edi, eax            mov esi, dword[ebp + 16]    .PRINTLOOP:    mov cl, byte[esi]        cmp cl,0    je PRINTEND        mov byte[edi + 0xB8000], cl        add esi,1    add edi,2        jmp .PRINTLOOP PRINTEND:    pop edx    pop ecx    pop eax    pop edi    pop esi    pop ebp    ret;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DATA AREA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;align 8, db 0dw 0x0000    ;For AlignGDTR:    dw GDTREND - GDT -1    dd GDT - $$ + 0x10000GDT:    NULLDescriptor:    dw 0x0000    dw 0x0000    db 0x00    db 0x00    db 0x00    db 0x00    CODEDescriptor:    dw 0xFFFF    ; Limit[15:0]    dw 0x0000    ; Base[15:0]    db 0x00        ; Base[23:16]    db 0x9A        ; P = 1, DPL = 0, Code Segment, Execute/Read    db 0xCF        ; G = 1, D = 1, L = 0, Limit [19:16]    db 0x00        ; Base[31:24]        DATADescriptor:    dw 0xFFFF    ; Limit    dw 0x0000    ; Base    db 0x00        ; Base    db 0x92        ; P=1, DPL =0, Data Segment, Read/Write    db 0xCF        ; G= 1, D= 1, L= 0, Limit    db 0x00        ; BaseGDTREND:SWITCHMESSAGE: db 'Switch Success. Now Running 32bit Protected Mode.',0times 512 - ( $ - $$) db 0x00It won’t hard code to understand. Also, we should change the sector number to 1 for the bootloader. Surely, real-mode and protected-mode are different for addressing memory. Well, Well, I’m excited about how much complex on IA-32e mode. And currently, paging is disabled but if it is enabled… Anyway, I’ve made a table of the code. On the vim:  I’m not sure above table correct. well, Worke is done for 32bit! Let’s write kernel code. ","categories": ["development"],
        "tags": ["0SOS","OS","ProtectedMode","Operating System","System","Booting","32bit"],
        "url": "https://devsdk.github.io/development/2017/06/28/Hello32BIt.html"
      },{
        "title": "Now 0SOS will be written by C Langauge.",
        "excerpt":"I guess this post is quite long. Phew, I’ve spent a good day because I focus on OS today. Everything is fresh! Afternoon today, I’ve succeeded 0SOS jumping to 32bit code. Well, It has been spent many steps for that. Like, organize GDTR and GDT. You can see that here Now, We could write C Langauge kernel source code.  A single line, Mostly I have an effort. Above running C code is: #include \"Types.h\"void PrintVideoMemory(int x, int y, const char* _str);void __Kernel__Entry(){    PrintVideoMemory(0,3, \"Now C Language Binary.\");        while(1);}void PrintVideoMemory(int x, int y, const char* _str){    CHARACTER_MEMORY* Address = ( CHARACTER_MEMORY* ) 0xB8000;        int i = 0;        += ( y * 80 ) + x;    for ( i = 0; _str[i] != 0; i++)    {        Address[i].bCharactor = _str[i];    }}As you can see, It is working as well! Again, I need many stuff for preparing and a waste of time. First, We need controlling linker, build script of the code and jumping asm entry point to C language. Basically, We can use the 32-bit code so we can use the result of the compiler. Of course, We cannot use the output of the default setup. Because they had a lot of unnecessary data for Operating System kernel, Like code position and reorder formation. Sometimes they attach the library, even they try to link. And that is different from the section information. So we need to edit link script. Of course, I didn’t have expertise of link script. And the author said If He explains that, it would be a book. So I just try to copy about that. I can understand about a little bit, of course not at all. But I can see a big picture. I’ll not copy my link script on here. That wasn’t point. If you want to see that, here It really hard about explains all of them. Foundation of code is from /usr/lib/ldscript/elf_i386.x I copied the code from there and then remove unnecessary code, changing sections and addressing. The most important thing is:     /*SKIP*/    .text 0x10200      :  {    *(.text.unlikely .text.*_unlikely .text.unlikely.*)    *(.text.exit .text.exit.*)    *(.text.startup .text.startup.*)    *(.text.hot .text.hot.*)    *(.text .stub .text.* .gnu.linkonce.t.*)    /* .gnu.warning sections are handled specially by elf32.em.  */    *(.gnu.warning)  }    /* SKIP */  .data           :   {    *(.data .data.* .gnu.linkonce.d.*)    SORT(CONSTRUCTORS)  }      /* SKIP */}First, I edited almost half the code. Let’s see this. As you can see, We were addressing 0x10200 at the start point of .text section and addressing data section after that. Then let’s compile that C file for the kernel with many options. gcc -c -m32 -ffreestanding Main.cIf We compile like that, it would be 32-bit code, not linked and not loaded another library. The object file that is produced by compiler link again. Currently, this file cannot execute. It just the object file. When this file disassemble: Plus, The assembly code on that image above is 3 number addition function example for this posting instead of the kernel.  You could see the start address command line is 0 So, We need to use a linker script wrote before.  ld -elf_i386 -nostdlib -T LinkerScript.x Main.o Main.elfSkip of more things after that command line. So that will make relocation instruction and runnable.  The important thing is not instruction. That is different to the start address. Anyway, If you made it, the something work left is to initialize 32-bit code and jump kernel entry point to c language entry point.   [BITS 32]  PROTECTEDMODE:     mov ax, 0x10     mov ds, ax     mov es, ax     mov fs, ax     mov gs, ax      mov ss, ax     mov esp, 0XFFFE     mov ebp, 0XFFFE      push (SWITCHMESSAGE - $$ + 0x10000)     push 2     push 0     call PRINT     add  esp, 12      jmp dword 0x08:0x10200      ;Let's Jump To CUh, It’s hard to write build script. I think I need to examine in makefiles. Anyway, Build completed after one or two hours writing build script with brain burning. Oh, I’m excited. So I look at…  It must be like the first picture, but as you can see the VM was exploded. So I can suppose why the VM was exploded. Because I have to choose just one section to read. After editing that, It worked correctly. So I going to prepare that find why it wasn’t worked correctly by reading the dump files. Huh, It gonna more complicate! Let’s do this to END. ","categories": ["development"],
        "tags": ["0SO","OS","ProtectedMode","Operating System","System","32bit","Booting","C Language"],
        "url": "https://devsdk.github.io/development/2017/06/29/LetsJumpToC.html"
      },{
        "title": "Improvement of output, ready for jumping to the 64bit mode and almost completely to the 64-bit system.",
        "excerpt":"After jumping to the 64 bit and jump to the C language kernel, I should prepare to jump to the 64 bit. First of all, the output wasn’t satisfying. So I’ve made a plan for that improvement.  After then,  As you can see, that was changed. And already fixed that miss typing SICCESS to SUCCESS on second. But you know I’m so lazy for taking a new screenshot that was fixed. So I’ll use the unfixed image. I’ve read a lot of code for this. First, I’ve fixed the 16bit bootloader assembly code for the 1~2 line output function. Before the output function is:     push HELLO        push 0    push 0    call PRINT    add sp, 6You cannot display the color on the output. So, I’ve fixed that. Now it requires four parameters for output. Currently, the output code is:     push HELLO        push 0x0B    push 30    push 1    call PRINT    add sp, 8Also, I’ve edited internal of a function. PRINT:    push bp,    mov bp, sp        push es    push si    push di    push ax    push cx    push dx        mov ax, 0xB800    mov es, ax    mov ax, word[bp + 4]    mov si, 160    mul si    mov di, ax    mov ax, word[bp + 6]        mov si, 2    mul si    add di, ax    mov si, word[bp+10]    mov bl, byte[bp+8]    .PRINTLOOP    mov cl, byte[si]            cmp cl,0    je .ENDPRINTLOOP    mov byte[es:di], cl    mov byte[es:di+1], bl    add si, 1    add di, 2    jmp .PRINTLOOPUh, Pretty long line. I’ve changed this code to use attribute code on bl register. And then I’ve edited assembly code using 32bit code entry point for printing 32-bit mode change success message on 3 lines. No big change.     push (SUCCESS - $$ + 0x10000)    push 0x0A    push 4    push 60    call PRINT    add  esp, 16Simply, It has been added attribute code. Also, I’ve edited the function partly as well. PRINT:    push ebp    mov ebp, esp    push esi    push edi    push eax    push ecx    push edx    mov eax, dword [ebp + 12]    mov esi, 160    mul esi    mov edi, eax            mov eax, dword[ebp + 8]    mov esi, 2    mul esi    add edi, eax    mov bl, byte[ebp + 16]    mov esi, dword[ebp + 20]    .PRINTLOOP:    mov cl, byte[esi]        cmp cl,0    je PRINTEND        mov byte[edi + 0xB8000], cl    mov byte[edi + 0xB8000+1], bl        add esi,1    add edi,2        jmp .PRINTLOOPIt’s same that inserting value by ‘mov bl, byte[ebp+16]’ and then using that on output code. And then I added a parameter in function PrintVideoMemory for using C Language. The Implementation is: void PrintVideoMemory(int x, int y, BYTE Attribute ,const char* _str){    CHARACTER_MEMORY* Address = ( CHARACTER_MEMORY* ) 0xB8000;        int i = 0;        Address+= ( y * 80 ) + x;    for ( i = 0; _str[i] != 0; i++)    {        Address[i].bCharactor = _str[i];        Address        [i].bAttribute = Attribute;        }}For my satisfaction, I’ve tried to change a few parts of codes even that hasn’t existed on the book. The pretty output makes me happy. Also, I added the code for checking memory and set by 0 in the area for 64-bit kernel memory. BOOL Initalization64KernelMemoryArea(){    DWORD* Address     = (DWORD*) 0x100000;        while((DWORD) Address     &lt; 0x600000)    {        *Address         = 0x00;        if( *Address         != 0 )            return FALSE;        Address        ++;    }                return TRUE;}BOOL CheckMemorySize(){    DWORD* Address     = (DWORD*) 0x100000;        while( (DWORD) Address    &lt; 0x4000000 )    {        *Address         = 0x12345678;        if( *Address         != 0x12345678)            return FALSE;        Address         += (0x100000 / 4);    }    return TRUE;    }These functions are used on the entry point for checking and printing messages. I want to check this code working well. So I’ve changed command line in launch_qemu.sh. Before change a commend is: qemu-system-x86_64 -L . -m 64 -fda disk.img -localtime -M pcIf set up like that, Qemu allocates 64 MB memory by -m option.  As you can see, It’s working well. So, Let me try to allow low memory to VM.     qemu-system-x86_64 -L . -m 32 -fda disk.img -localtime -M pcI give 32 MB memory to VM by -m 32 option.  Oh yeah! That’s what I wanna expect about it. The left things used to turn on the paging, something ready for jumping to the 64 bit. Also, I want to make the code much pretty. It looks like complex codes. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Booting","function"],
        "url": "https://devsdk.github.io/development/2017/06/30/preparing64.html"
      },{
        "title": "Definition of DataStructure related Paging, Prepare to jump to 64 bit.",
        "excerpt":"It’s the time, to 64 bit. We didn’t enable paging and define data structure because 32bit protection mode is before IA-32e mode. Anyway, We need to define a data structure for memory paging function. There are two methods exist. First one is 4-step-paging that would slice memory every 2MB. The second one is 5-step-paging that would slice memory every 4KB. In this picture describe 5-step-paging using 4KB, but I’ll use 4-step-paging using 2MB. No PT.  One of entry in Page Directory Table. 512 2MB Entries can be stored in this Table. That means each directory can be present 512 * 2MB = 1GB. We need the 64-page directory point because we will support 64GB. So We need only one entry in PML4 table. Shortly, Securing memory area is PML4 table, Page Directory Point Table and Page Directory Table. In source code that was named PMl4, PDPT, and PD. Also, BITFLAG was supported because A lot of Flags has existed that would be overlapped. Following is Memory assign size for this data structure. 512 8byte of PML4 Entry would use 512 * 8byte. 512 8byte of PDPT Entry would use 512 * 8byte. 512 8byte of PD Entry would use 512 * 64 (support 64GB). So We need 264KB. We’ll assign 64-bit kernel to 2MB area, so let’s store to 1~2MB area. #ifndef __PAGE_H__#define __PAGE_H__#include \"Types.h\"#define PAGE_FLAG_P            0x00000001#define PAGE_FLAG_RW        0x00000002#define PAGE_FLAG_US        0x00000004#define PAGE_FLAG_PWT        0x00000008#define PAGE_FLAG_PCD        0x00000010#define PAGE_FLAG_A            0x00000020#define PAGE_FLAG_D            0x00000040#define PAGE_FLAG_PS        0x00000080#define PAGE_FLAG_G            0x00000100#define PAGE_FLAG_PAT        0x00001000    #define PAGE_FLAG_EXB        0x80000000    #define PAGE_FLAG_DEFAULT    (PAGE_FLAG_P | PAGE_FLAG_RW)#define PAGE_TABLE_SIZE        0x1000 //4KB#define PAGE_DEFAULT_SIZE    0X200000#define PAGE_MAX_ENTRY_COUNT        512#pragma(push, 1)/*    For IA-32e Paging    IA-32e Address Structure    63            48 47    39 38               30 29       21 20            0    |SIGNEXTENSION| PML4 | DIRECTORY POINTER | DIRCTORY  |    OFFSET     |    PML4 Reference PML4 ENTRY    and, that Reference DIRECTORY POINTER ENTRY using DIRECTORY POINTER    and, that Reference DIRECTORY ENTRY using DIRECTORY     and, DIRECTORY + OFFSET is Memory Address.         so, We Need Space for this Structure        PML4 Table Need 512 * 8 Byte = 4KB    PAGE DIRECTORY POINTER Table Need 512 * 8 Byte = 4KB    PAGE DIRECTORY Need 512 * 8 Byte * 64 = 256KB (for 64GB Memory)        So we using 4KB + 4KB+ 256KB = 264KB Memory Space.    The following code is its implementation.            We Use 4 Level Paging, So NOT USE PTENTRY.*/typedef struct __Struct_PageEntry{            /*0----------------31 bit */    DWORD dwLowAddress;    /*32---------------64 bit */    DWORD dwHighAddress;} PML4ENTRY, PDPTENTRY, PDENTRY, PTENTRY;    #pragma(pop)void InitializePageTable();void SetPageEntryData(PTENTRY* pEntry, DWORD dwHighBaseAddress,                       DWORD dwLowBaseAddress, DWORD dwLowFlag, DWORD dwHighFlag);#endif /*__PAGE_H__ */Damm, Comment was broken. It looks like this.  __Struct_PageEntry is defined for 64 bit sized Table Entry. PTENTRY structure isn’t used (It’s only for 5-step-paging). #include \"Page.h\"void InitializePageTable(){    PML4ENTRY*    pml4entry  = (PML4ENTRY*) 0x100000;    PDPTENTRY*    pdptentry  = (PDPTENTRY*) 0x101000;    PDENTRY*    pdentry    = (PDENTRY*    ) 0x102000;    SetPageEntryData(&amp;pml4entry[0], 0x00, 0x101000, PAGE_FLAG_DEFAULT, 0);    for(int i = 1; i&lt; PAGE_MAX_ENTRY_COUNT; i++)    {        SetPageEntryData(&amp;pml4entry[i], 0,0,0,0);    }    for(int i = 0; i &lt; 64; i++)    {        SetPageEntryData(&amp;pdptentry[i], 0, 0x102000 + i * PAGE_TABLE_SIZE,                         PAGE_FLAG_DEFAULT, 0);    }    for(int i=64; i &lt; PAGE_MAX_ENTRY_COUNT; i++)    {        SetPageEntryData(&amp;pdptentry[i], 0, 0, 0, 0);    }    DWORD LowMapping = 0;         /*        'high' for Calculate out of 32bit area. using HighAddressArea     */    for(int i=0; i&lt;PAGE_MAX_ENTRY_COUNT * 64; i++)    {        DWORD high = (i * (PAGE_DEFAULT_SIZE &gt;&gt; 20) ) &gt;&gt; 12;        SetPageEntryData(&amp;pdentry[i], high, LowMapping,                         PAGE_FLAG_DEFAULT | PAGE_FLAG_PS, 0);                        LowMapping += PAGE_DEFAULT_SIZE;    }     }void SetPageEntryData(PTENTRY* pEntry, DWORD dwHighBaseAddress, DWORD dwLowBaseAddress,                      DWORD dwLowFlag, DWORD dwHighFlag){    pEntry-&gt;dwLowAddress  = dwLowBaseAddress  | dwLowFlag;    pEntry-&gt;dwHighAddress = (dwHighBaseAddress &amp; 0xFF )| dwHighFlag;}It looks quite complex. But it isn’t. ”»20»12” is the operation of address over than 32-bit area. I present 64-bit using a struct. We will store data by FLAG before we defined  And add initialize function in main.c.     PrintVideoMemory(5,7, 0x0F,\"Initalization PML4, PDPT, PD .........................\");    InitializePageTable();    PrintVideoMemory(60,7,0x0A,\"[SUCCESS]\");Memory size check is simple, so it prints just SUCCESS. Let’s see in VM.  I’m glad that function was added You can find full source code in GITHUB. STAR PLZ :) ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Booting","64bit"],
        "url": "https://devsdk.github.io/development/2017/06/30/readytojump64.html"
      },{
        "title": "Booting complete, The journey is over. Hello 64Bit!",
        "excerpt":"Yeh I made it. Now entering assembly to C Language entry.  Today I’m going to google IO seoul so I’ll spend a night in cafe with acquaintance. But Nobody came here so I’ve spent alone lol. So I did coding in the cafe corner alone.  Of coruse I didn’t carry my book because that was so heavy. I started the development without the book. I had little goals that were developments 64 bit entry code left and C Language entry. That mean… I wanted success development booting step. Anyway, I thoguht the structure is similar as before because I already had experience about switching 16 bit mode to 32 bit mode with my book. And I almost completed page data structure related to 64 bit mode. So I thought It’s simple. The first thing I have to do was moveing the 2MB area that we jumped before. In another word, We need to change link script. Well Before starting address is 0x10200, so I think that change to 0x200000. Also Before thing was only 32 bit mode, so We need to support x86-64. I decided to read already existed code. The file /usr/lib/ldscript/elf_x86_64 was link script for 64 bit mode. As I looked at this file and I think It wans’t so different LinkScript32.x, so I tried to command ‘diff’ to find editing point. Plus, I wanna look properly, so I used colordiff.  Oh? It hadn’t lots change points. Set the starting point to 0x200000 and write the link script. Because I didn’t have book, so I just try it by my sense. But I felt liitle complicate because I thought ‘64 bit kernel didn’t have a asm entry points??’ like this. Because when 32bit mode, I load EntryPoint.s to 0x10000 and call 0x102000 to C language entry. I think one of them start address will start at 0x200000, so I start to research. Because I didn’t have the book, So I check all of them. I interpreted something secret hinding in the linker and I started the tests. At the result of checking makefile: EntryPoint’s binary was first target of linking, so as address 0x200000 started application like kernel functions or etc. First, Almost understanding was done, so I started developments and edited file was LinkerScript and makefiles. I’ve refered memory load part code from OS book community. First, Load all of data by bootloader. Like stack. Unit is 512 bytes. Already existed kernel32 will make 5 sector, Kernel64 will maek 1 sector. That was loaded by bootloader at 0x10000. I cannot understand why do like this because i didnt’t read books. So I’m so excited to read that. As I expect, Something to use left areas or advantage of performence. For the implementation, we need a information about sector number in front of disk image. And that image used from that information. Anyway, as 64bit kernel copy at 2MB position, and after IA-32e mode switch then jump to 2 MB. If it was properly working when It jumped, it will simply success, but something misstype and unexpected bugs, so I spent quite hard time. First, Wrong page directory pointer table position. It wasn’t 0x10200 it was 0x102000. //Page.c\tfor(int i = 0; i &lt; 64; i++)\t{\t\tSetPageEntryData(&amp;pdptentry[i], 0, 0x10200 /*0x102000*/        + i * PAGE_TABLE_SIZE, PAGE_FLAG_DEFAULT, 0);\t}at the expression of calculating address, PAGE_FLAG_DEFAULT was exsisted instead of PAGE_DEFAULT_SIZE. damm it.     //Page.c\tDWORD high = (i * (PAGE_FLAG_DEFAULT &gt;&gt; 20) ) &gt;&gt; 12;\t//Above is error code    //Below is proper code    DWORD high = (i * (PAGE_DEFAULT_SIZE) &gt;&gt; 20) ) &gt;&gt; 12;\tIt worked wrong like booting and flashing problems, I think paging setted by r0 register through the ModeSwitchAndJumpKernel64 function. Well, I fixed that. The real problem was notting happend when it jumped at 2MB entry. ModeSwitchAndJumpKernel64:\t\t\t; Set 1 CR4 Register PAE Bit\tmov eax, cr4\tor eax, 0x20\tmov cr4, eax\tmov eax, 0x100000\tmov cr3, eax\t\tmov ecx, 0xC0000080\trdmsr\tor eax, 0x0100\twrmsr\t\t\t;Write Table\tmov eax, cr0\tor  eax, 0xE0000000\txor eax, 0x60000000\tmov cr0, eax\t\tjmp 0x08:0x200000\t\t;Not Entry\tjmp $\t\tAbove codes has contained jumping to 0x200000 at “jmp 0x08:0x200000”, but notting happend. I tried to check that codes are executed. And I examine my OS with doubt. So I found the clue. On the QEMU, Press CTRL + R + 2 and you can access the command shell. You can check the value in the address by that: x 0x200000Always I can’t find any value. I thought copying part or data set has been problems. I thought the sector information was wrong, but it was not problem because hex value was properly by vim. %!xxd And I should check the data copying, so I looked at the data at 0x10A00 by segment * 512 * 5, and I found it worked properly. Let’s look at the copy function. void LoadKernel64ImageToMemory(DWORD _address){\tWORD TotalKernelSector \t= *( (WORD*) 0x7C05);\tWORD Kernel32Sector \t= *( (WORD*) 0x7C07);\t\tDWORD* SourceAddress = (DWORD*) 0x10000 + Kernel32Sector * 512;\tDWORD* DestAddress\t= (DWORD*) 0x200000; \t\tfor(int i=0; i&lt; 512 * (TotalKernelSector -Kernel32Sector) / 4; i++)\t{\t\t*DestAddress = *SourceAddress;\t\tDestAddress++;\t\tSourceAddress++;\t}\t}Ah, There is it. \tDWORD* Source = ((DWORD*) (0x10000 + Kernel32Sector * 512));Primary operators. Dammit, that was mistake. I did like beginner. Anyway, After fixing that miss, it would be load below entrypoint code on the 2MB: [BITS 64]SECTION .textextern __KERNEL_ENTRYSTART:\tmov ax, 0x10\tmov ds, ax\tmov es, ax\tmov fs, ax\tmov gs, ax\tmov ss,  ax\tmov rsp, 0x6FFFF8\tmov rbp, 0x6FFFF8\tcall __KERNEL_ENTRY\tjmp $That Entry call the C Entry: #include \"Types.h\"void PrintVideoMemory(int _x, int _y, BYTE _Attribute, const char* _str);void __KERNEL_ENTRY(){\tPrintVideoMemory(5,12, 0x0F,\"64 bit C Language Kernel.\");\t}void PrintVideoMemory(int _x, int _y, BYTE _Attribute ,const char* _str){\tCHARACTER_MEMORY*  = ( CHARACTER_MEMORY* ) 0xB8000;\t\tint i = 0;\t\tAddress+= ( _y * 80 ) + _x;\t\tfor ( i = 0; _str[i] != 0; i++)\t{\t\tAddress[i].bCharactor = _str[i];\t\tAddress[i].bAttribute = _Attribute;\t\t\t}}It worked properly like above image! Well, I spent a lot time of coding time for that, also I spent many debugging time. I think, I should use GDB skillfully. Now the booting steps are done. I spent whole night, and  I write this article while travel, so this article might be something weird i guess. Please understanding me. I think it is good compare what i’ve done and book. after take a rest in a while, and I will fix the value in code on the previous article. Now, Start! ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Booting","64bit"],
        "url": "https://devsdk.github.io/development/2017/07/02/Hello64Bit.html"
      },{
        "title": "Make a debugging environment using QEMU + GDB",
        "excerpt":"Currently, in progress, OS was made on Ubuntu(Windows bash) + VIM. Until now, I can handle it, but I felt limitation so I think I need debugging tools. QEMU itself has some debugging tools but it is weak than professional tools. Before, We can check the value in the memory using qemu’s function. You can use that function to press ALT + 2 to enter the QEMU console and you can check the value using command-line x [address] I think maybe I can make 64bit kernel much faster if I use a debugger. Well, Qemu has a function of gdb hosting itself. If you want to use that, type the initial qemu options: -gdb tcp::[prot]And a GDB side, launch gdb, (gdb) target remote tcp::[port]and you can successfully connect that. For now, Debugging is available. Like handling memory. (gdb) break *0x200000You can make a breakpoint on that address, (gdb) continueand you can enter the debugging console when it executes that address.  But it hasn’t symbol data so you cannot break on particular expression or function, so I felt that is a half. And I cannot use many functions as a list. For adding symbol, first, add a gcc option -g in makeifle, now the OS containing debugging information.  The picture above is the result of opening .elf file using objdump. and when you launch gdb, you can connect with that. gdb -s [location]You can address the .elf file that completed linking. For me, I thought I’ll develop 64-bit mode, So I appoint ‘02_Kernel64/Obj/Kernel64.elf’ Well,  We can make a breaking point using the function name. And progress the GDB using the command ‘continue’, and reach that point, listbelow image is the result of command the ‘list’  Now I made a debugging environment. I’m worried about the first time of GDB using as well. If you try to use the connection between gdb and qemu, I hope this article will help. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Debug","64bit"],
        "url": "https://devsdk.github.io/development/2017/07/03/QemuAndGdb.html"
      },{
        "title": "Port IO memory and Input input process PS/2 Keyboard IO.",
        "excerpt":"This is a result until today from yesterday thinking a lot.  The red text was input text. Now, 0SOS support keyboard input. Of course, it isn’t a shell, it is just a keyboard driver. It just simply works that input data to video memory. I’m a little bit worried about it is designed for PS/2 interface. (Old computer’s port) Well, I don’t wanna develop exactly the same as the book. But… I tried to google it, even I tried to ask the author:   He said like that. He said you need to control the PCI. So I defer about that, and I’ll design to extentionable. From the book, It uses input data to queue buffer, I think the queue will be used to the interface. Well, this problem also defers when I need to develop USB Driver and PCI control. First, Let’s develop the Keyboard Driver on the PS/2 version. Fortunately, the Laptop keyboard was PS/2 internally. This is no problem to develop. It needs a classification of the source codes, because this will begin in earnest. So I made Driver directory in Source folder. My method for this is Port-Map IO, So I separate between PortIO and keyboard. So Below image was the tree that was made from that directories  *I don’t know why gch file is added, dammit Google said it was made from gcc when it running with the header file. I don’t know how can fix. I think I should take time for checking makefile. Fist, I hate the ‘../../’ when ‘include’ so I add the gcc include path option at source directory. gcc -I ../SourceOkay now, #include \"../../Types.h\" //We can use below line instead of this line.#include &lt;Types.h&gt;Well, I tried to make better than before… Now Let’s build time. Build failure. LoL. undefined reference to PS2~~It makes a message above. As I check that message more carefully, that would compile header, and not compile the source file. Maybe the reason is that in the book was described by a single path. Okay, Now I start the editing makefile. I think I spent 3 hours for that. Below code is 02_Kernel64/makefile. CSOURCEFILES = $(wildcard ../$(SOURCEDIR)/*.c)ASSEMBLYSOURCEFILES = $(wildcard ../$(SOURCEDIR)/*.asm)I changed C and assembly code assignment expression above codes to below codes. CSOURCEFILES = $(shell find ../$(SOURCEDIR)/ -name *.c)ASSEMBLYSOURCEFILES = $(shell find ../$(SOURCEDIR)/ -name *.asm)It has made a target all about C file, but It wouldn’t compile properly. So It cannot link on ld command at linking step because the file was lost. Thus I changed the rule of making o file. %.o: ../$(SOURCEDIR)/%.c             $(GCC64) -c $&lt;         %.o: ../$(SOURCEDIR)%.asm    $(NASM64) -c $@ $&lt;Above codes to below codes. $(COBJECTFILES): $(CSOURCEFILES)    $(GCC64) -c $^$(ASSEMBLYOBJECTFILES): $(ASSEMBLYSOURCEFILES)    $(NASM64) -o $@ $&lt;After building all of the files, that result file would be transfer in Obj directory. And linker was executed, the disk was completely baked.  I almost cry -_-. Anyway, The build was complete, launch the qemu with happy. Keep blinking -_-;;;; I try to find why it is working like it. I wanna use GDB, but… I can’t handle it. Also QEMU host the server, so It cannot work step by step. I’ll try to find a GUI version. Anyway, I found the reason. Two of the functions in PortIO assembly and header connected oppositely. Thus they return not properly, also parameter not work properly, the stack was exploded. PortIO function now available and I start to write keyboard driver using PS/2 Keyboard port. I think keyboard driver codes quite a bit long, so you can check here When the user presses the keyboard, they send the scan code. I make a g_KeyboardStatus structure for using shift and caps lock functions, I implement that when it press that keys, that value would be updated. //Keyboard.htypedef struct _KeyboardSataus{    BOOL isShiftKeyDown;    BOOL isCapsLockOn;    BOOL isNumLockOn;    BOOL isScrollLockOn;    BOOL isExtendCode;    int  SkipPauseCount;} KeyboardStatus;static KeyboardStatus    g_KeyboardStatus= { 0,};And I create scan code-askii code map. I made it can possible separate between combined-key and normal-key. //Keyboard.htypedef struct _StructKeyMapEntry{    BYTE     NormalCode;    BYTE     CombinedCode;} KeyMapEntry;static KeyMapEntry         g_KeyMapScanTable[KEYMAP_TABLE_SIZE] = {    { KEY_NONE                ,        KEY_NONE        }, //    0    { KEY_ESC                 ,        KEY_ESC            }, //    1    { '1'                    ,         '!'                }, //    2    { '2'                    ,        '@'                }, //    3    { '3'                    ,        '#'                }, //    4    { '4'                    ,        '$'                }, //    5    { '5'                    ,        '%'                }, //    6    { '6'                    ,        '^'                }, //    7    { '7'                    ,        '&amp;'                }, //    8    { '8'                    ,        '*'                }, //    9    { '9'                    ,        '('                }, //    10    { '0'                    ,        ')'                }, //    11    { '-'                    ,        '_'                }, //    12    // 나머지는 생략 89개다.Anyway, We can process keyboard input through the table. You can find Internal Implement on github. So you can use on kernel entry like that: //__Kernel_Entry.cvoid __KERNEL_ENTRY(){    PrintVideoMemory(5,12, 0x0F,\"64 bit C Language Kernel.\");        BYTE flags;    int i = 14;    char temps[2] = {0,};    if(PS2ActivationKeyboard() == FALSE)    {        PrintVideoMemory(5,15, 0x0F,\"Keyboard Error    .\");            while(1);    }                    while(1)    {            if(PS2CheckOutputBufferNotEmpty() == TRUE)        {                BYTE temp = PS2GetKeyboardScanCode();                if(ConvertScancodeToASCII( temp, &amp;temps[0], &amp;flags) == TRUE)                    if(flags &amp; KEY_DOWN )                        PrintVideoMemory(i++, 15, 0x0C, temps);                                    }                }        }As you can see, if the input value exists, that would take that value and change to ASCII, and checking whether that is keyboard input. Not use interrupt yet. I’m so happy because it works properly. Finally, I will.. make… Shell.. Anyway, the next thing was inttrupt… It should be hard. Full Source Code of Kernel64 ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Input","Keyboard","64bit"],
        "url": "https://devsdk.github.io/development/2017/07/05/PortIOAndKeyboard.html"
      },{
        "title": "Changing GDT & Defining GDT & Setting TSS",
        "excerpt":"Until now, sometimes I’ve got something to work, and I spent a lot of debugging time at this time. so I write this now. Well…. Until now, 0SOS didn’t have an interrupt process code. So If the interrupt occurs, it makes system down or processed by the default handler Anyway, I don’t like it. For input keyboard or some interrupt application, I’ve made IDT for prepare interrupt process.  Still, they connected the dummy handler, but interrupt has occurred, the handler was executed for process interrupt. I defined the IST data structure for handling interrupt on the 7~8MB area. And I assign IST using TSS segment, and I connect about hundred of dummy handler and dummy descriptor in IST. Below image was memory map.  I’ll draw paint next time. Too much effort. Anyway, The point is setting up TSS selector in GDT, defining TSS and constructing IDT. Well, It looks simple. Let’s see the codes. And I’ll write a debugging log. First, Dummy handler: void DummyHandler(){    Pt(0,0,0x0F ,\"===============================\");    Pt(0,1,0x0F ,\"===============================\");    Pt(0,2,0x0F ,\"===    Test Interrupt Hander===\");    Pt(0,3,0x0F ,\"===============================\");    Pt(0,4,0x0F ,\"===============================\");        while(1);   //Busy waiting for no retuning.}If some interrupt has occurred, it would be handled by that function. In other words, if you try to divide 0, it would occur interrupt. So That function was executed. You can see the result in the first image. Anyway, I need to re-define GDT, TSS using IST and make IDT for process interrupt. So I make a Descriptor directory and define some files for that.  Descriptor.asm and Descriptor.h handle asm code for GDTR, IDTR and TSS load to the processor. IDT.c and IDT.h are related at IDT and GDT.c and GDT.h are related at GDT. If you wanna look detail GDT.h, please check the below URL. GDT.h URL I define the bundle of codes that would be used often. The implementation was: //GDT.c#include \"GDT.h\"#include \"IDT.h\"#include &lt;Utility/Memory.h&gt;void InitializeGDTWithTSS(){    GDTR* _gdtr = (GDTR*)GDTR_POINTER;    GDT_ENTRY8* _gdt_entry      = (GDT_ENTRY8*)(GDTR_POINTER + sizeof(GDTR));     TSS_SEGMENT* _tss_segment    = (TSS_SEGMENT*)((QWORD)_gdt_entry+GDT_TABLE_SIZE);        _gdtr-&gt;Size         = GDT_TABLE_SIZE - 1;    _gdtr-&gt;BaseAddress  = (QWORD)_gdt_entry;    SetGDT_Entry8((&amp;_gdt_entry[0]), 0, 0, 0, 0, 0);    SetGDT_Entry8((&amp;_gdt_entry[1]),0,0xFFFFF, GDT_ENTRY_HIGH_CODE, GDT_ENTRY_LOW_KERNEL_CODE, GDT_TYPE_CODE);    SetGDT_Entry8((&amp;_gdt_entry[2]),0,0xFFFFF, GDT_ENTRY_HIGH_DATA, GDT_ENTRY_LOW_KERNEL_DATA, GDT_TYPE_DATA);        SetGDT_Entry16(((GDT_ENTRY16*)(&amp;_gdt_entry[3])), (QWORD)_tss_segment, sizeof(TSS_SEGMENT)-1, GDT_ENTRY_HIGH_TSS,                    GDT_ENTRY_LOW_TSS, GDT_TYPE_TSS);    InitializeTSSSegment(_tss_segment);    }void SetGDT_Entry8(GDT_ENTRY8* _entry, DWORD _BaseAddress,                     DWORD _Size, BYTE _HighFlags, BYTE _LowFlags, BYTE _Type){    _entry-&gt;Low_Size            =   _Size &amp; 0xFFFF;    _entry-&gt;Low_BaseAddress     = _BaseAddress &amp; 0xFFFF;    _entry-&gt;Low_BaseAddress1    = ( _BaseAddress &gt;&gt; 16 ) &amp; 0xFF;    _entry-&gt;Low_Flags           = _LowFlags | _Type;    _entry-&gt;High_FlagsAndSize   = ((_Size&gt;&gt;16) &amp; 0xFF) | _HighFlags;    _entry-&gt;High_BaseAddress    = (_BaseAddress&gt;&gt;24) &amp; 0xFF;}void SetGDT_Entry16(GDT_ENTRY16* _entry, QWORD _BaseAddress,                     DWORD _Size, BYTE _HighFlags, BYTE _LowFlags, BYTE _Type){    _entry-&gt;Low_Size            = _Size &amp; 0xFFFF;    _entry-&gt;Low_BaseAddress     = _BaseAddress &amp; 0xFFFF;    _entry-&gt;Mid_BaseAddress     = (_BaseAddress &gt;&gt; 16 ) &amp; 0xFF;    _entry-&gt;Low_Flags           = _LowFlags | _Type;    _entry-&gt;High_FlagsAndSize   = ((_Size &gt;&gt; 16) &amp; 0xFF) | _HighFlags;    _entry-&gt;High_BaseAddress    = (_BaseAddress  &gt;&gt; 24) &amp; 0xFF;    _entry-&gt;High_BaseAddress2   = (_BaseAddress&gt;&gt;32);    _entry-&gt;Reserved            = 0;}void InitializeTSSSegment(TSS_SEGMENT* _tss){    _MemSet(_tss, 0, sizeof(TSS_SEGMENT));        _tss-&gt;IST[0] = IST_POINTER + IST_SIZE;    _tss-&gt;IOMapBaseAddress  =  0xFFFF;}Well, You can see GDT load on memory through InitializeGDTWithTSS function. (You should check GDTR_POINTER. That was completely calculated.) Not different normal GDT, I suggest you Google it. Let’s check IDT. //IDT.h#ifndef __IDT_H__#define __IDT_H__#include \"GDT.h\"#define IDT_TYPE_INTERRUPT      0x0E    //0b00001110#define IDT_TYPE_TRAP           0x0F    //0b00001111#define IDT_ENTRY_DPL0          0x00    //0b00000000#define IDT_ENTRY_DPL1          0x20    //0b00100000#define IDT_ENTRY_DPL2          0x40    //0b01000000#define IDT_ENTRY_DPL3          0x60    //0b01100000#define IDT_ENTRY_P             0x80    //0b10000000#define IDT_ENTRY_IST1          1#define IDT_ENTRY_IST0          0#define IDT_ENTRY_KERNEL    (IDT_ENTRY_DPL0 | IDT_ENTRY_P)#define IDT_ENTRY_USER      (IDT_ENTRY_DPL3 | IDT_ENTRY_P)#define IDT_MAX_ENTRY_COUNT     100#define IDTR_POINTER            (sizeof(GDTR) + GDTR_POINTER \\                                + GDT_TABLE_SIZE + TSS_SEGMENT_SIZE)#define IDT_POINTER            (sizeof(IDTR) + IDTR_POINTER)#define IDT_TABLE_SIZE          (IDT_MAX_ENTRY_COUNT + sizeof(IDT_ENTRY))#define IST_POINTER         0x700000#define IST_SIZE            0x100000#pragma pack(push, 1)typedef struct _Struct_IDT_Entry{    WORD Low_BaseAddress;    WORD SegmentSelector;    BYTE IST;    //3Bit IST, 5Bit set 0    BYTE FlagsAndType;    // 4Bit Type, 1 Bit set 0, 2Bit DPL, 1Bit P    WORD Mid_BaseAddress;    DWORD High_BaseAddres;    DWORD Reserved;}IDT_ENTRY;#pragma pack(pop)void InitializeIDTTables();void SetIDTEntry(IDT_ENTRY* _entry, void* _handler, WORD _Selector,                     BYTE _IST, BYTE _Flags, BYTE _Type);void Pt(int _x, int _y, BYTE _Attribute ,const char* _str);void DummyHandler();#endif /* __IDT_H__ */Yet IDT.h file wasn’t huge. You can see as well, I designed that could place on memory by sizeof instead directly use _POINTER that was pointing starting address. Below was an implement of IDT.c. //IDT.c#include \"IDT.h\"void InitializeIDTTables(){    IDTR* idtr = (IDTR*) IDTR_POINTER;    IDT_ENTRY* entry =  (IDT_ENTRY*)(IDTR_POINTER + sizeof(IDTR));        idtr-&gt;BaseAddress   = (QWORD)entry;    idtr-&gt;Size          = IDT_TABLE_SIZE - 1;    for(int i = 0; i &lt; IDT_MAX_ENTRY_COUNT; i++)     {        SetIDTEntry(&amp;entry[i],DummyHandler,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    }}void SetIDTEntry(IDT_ENTRY* _entry, void* _handler, WORD _Selector,                     BYTE _IST, BYTE _Flags, BYTE _Type){    _entry-&gt;Low_BaseAddress =  (QWORD) _handler &amp; 0xFFFF;    _entry-&gt;SegmentSelector = _Selector;    _entry-&gt;IST             = _IST &amp; 0x3;    _entry-&gt;FlagsAndType   = _Flags | _Type;    _entry-&gt;Mid_BaseAddress = ((QWORD)_handler &gt;&gt; 16) &amp; 0xFFFF;    _entry-&gt;High_BaseAddres = ((QWORD)_handler &gt;&gt; 32);    _entry-&gt;Reserved        = 0;}//Skip Pt and DummyHandlerI skip that dummyhandler and print vide memory function. IDT was defined and loaded by the above codes. Descriptor.h and Descriptor.asm work for linking the handler and processor. //Descriptor.h#ifndef __DESCRIPTOR_H__#define __DESCRIPTOR_H__void LoadGDTR(QWORD _GdtrAddress);void LoadTR(WORD _TssSegmentOffset);void LoadIDTR(QWORD _IDTRAddress);#endif /*__DESCRIPTOR_H__*/Above code linked at the assembly codes. the assembly codes are: ;Descriptor.asm[BITS 64]                     global LoadGDTR, LoadTR, LoadIDTR                        SECTION .textLoadGDTR:    lgdt[rdi]    retLoadTR:    ltr di    retLoadIDTR:    lidt[rdi]    retIt’s simple. It’s just table notification to table code. I add the below codes to initialize and link to the processor at the kernel entry. And Below code makes a divide by zero interrupt when we press some key.     //__Kernel_Entry.c    PrintVideoMemory(5,12, 0x0F,\"Initialize GDT........................................\");    InitializeGDTWithTSS();    LoadGDTR(GDTR_POINTER);    PrintVideoMemory(60,12,0x0A,\"[SUCCESS]\");    PrintVideoMemory(5,13, 0x0F,\"Load TSS Segment .....................................\");    LoadTR(GDT_TSS_SEGMENT);    PrintVideoMemory(60,13,0x0A,\"[SUCCESS]\");    PrintVideoMemory(5,14, 0x0F,\"Initialize IDT .......................................\");    InitializeIDTTables();    LoadIDTR(IDTR_POINTER);    PrintVideoMemory(60,14,0x0A,\"[SUCCESS]\");    //...//__Kernel_Entry.c    if(flags &amp; KEY_DOWN )    {        PrintVideoMemory(i++, 15, 0x0C, temps);        int b = 10 / 0;    }Thus far, this is an addition in the codes. Well…. I should consider about copy&amp;paste whole codes. I think it has a better way. Like above Kernel Entry. Okay, below article is debugging log when I developed above. I try to build with a happy mind. undefined reference to ....Dammit. I try to find what is a problem. I check the linker log, Assembly object file looks weird. So I check through the objdmp… OMG, that files exactly same without the filename. (PortIO.o and Descriptor.o was same PortIO.o data) nasm looks like gcc but it cannot build several files. $(ASSEMBLYOBJECTFILES): $(ASSEMBLYSOURCEFILES)     $(NASM64) -o $@ $&lt;In fact, It can be built by $&lt;. If it is $^, nasm would be stopped because of too many arguments. So this happen was made by more than two asm file. gcc could build with option -c and source files, but nasm didn’t. I wanna find the way. First, I try to use the nasm function. I consider that but it’s impossible. Or I didn’t know? Anyway, I solved this problem by inserting foreach in makefile. $(ASSEMBLYOBJECTFILES):$(ASSEMBLYSOURCEFILES)$(foreach var,$(ASSEMBLYSOURCEFILES),$(NASM64) $(var) -o $(notdir $(patsubst %.asm, %.o,  $(var))) ;)I waist hours for the above shortcode lines.  Well, I guess I don’t need to touch makefile. I try to run. It didn’t work properly. I’m mental hurt by makefile. So I’m so confused. I’ve spent a rest little bit. So, we need to check GDT, IDT and TSS data would be loaded properly. The first we try, Check the GDTR that explicitly assigned memory address.  Green is GDTR, red is GDT table. GDTR’s assignment is GDT address appointing. I designed GDT next to GDTR, So it should refer 0x142010, and i should check that HEX. And it is properly worked. Let’s look at the GDT. Well, GDTR assignment is properly worked, and I can check the output. So I think GDT table content wasn’t wrong. But, I check harder the TSS segment. The starting address is 0x142028. If I make table:  I check the base address because I tried to check the memory part. Also, I designed a tss table next to GDTR too, it should be 0x142038. Tss Segment descriptor base address looks no-problem.  I check again. Something wrong. The last 2byte, I set FFFF on IOMap. Where they go? Also IST base address 0x800000 has gone. I try to check the codes. OMG. I write the InitializeTSSSegment function but I wouldn’t call it. So I solve that problem by calling that function.  … You can see the different above image and right above image. It worked properly now. But it still didn’t work. So I should check the IDT. Hum…  Ah…?? It memory calculation wasn’t properly worked. I plan right next to the TSS but why it refer 0x1421A0? I checked the codes. IDT_ENTRY* entry =  (IDT_ENTRY*)IDTR_POINTER + sizeof(IDTR);Okay, I mistake Again -_- Of course, It appoints before if like that. because After casting to the pointer and add. So I solve this change above code to below code. IDT_ENTRY* entry =  (IDT_ENTRY*)(IDTR_POINTER + sizeof(IDTR));Addition, This code wasn’t a problem to work. But it isn’t my plan. So It should make something problem later. For example, it could occur address crashing when I try to insert data on after IDT. (Because the memory address in IDTR is the same as IDT location. In fact, you can check IDT on 0x2021A0.) After Fixing that, data was filled properly.  All of the data is ready. But it didn’t work…. So I knew if interrupt occurs, system down. Weird. No way! Did I make a  mistake about the pass on the processor? [BITS 64]                     global LoadGDTR, LoadTR, LoadIDTR                        SECTION .textLoadGDTR:    lgdt[rdi]    retLoadTR:    ltr di    retLoadIDTR:    lgdt[rdi]    retOh shi… I make a mistake which is calling lgdt in LoadIDTR function. So I change above code to below. [BITS 64]                     global LoadGDTR, LoadTR, LoadIDTR                        SECTION .textLoadGDTR:    lgdt[rdi]    retLoadTR:    ltr di    retLoadIDTR:    lidt[rdi]    retI edit lgdt to lidt. Thus, It works properly. OMG, this posting is huge. You can check full-source-code on here The left thing is the keyboard process using interrupt. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Interrupt","64bit"],
        "url": "https://devsdk.github.io/development/2017/07/10/ReadyInterrupt.html"
      },{
        "title": "PIC Interrupt, Interrupt Handling, Active Interrupt",
        "excerpt":"In fact, I made today afternoon, but I wrote this article now because I’ve got some work related to a server. In this time, I succeeded in PCI interrupt handling.  As you could notify about up-right, you can see the “INT” small text. An up-next number is interrupt number and next is counter. If you just make running, it would be increased from 00 to 99. Interrupt number 32 is a timer interrupt. Anyway This time I did implement of PCI driver, connecting routine for interrupt handling of IDT, context saving before interrupt handling and restore context after the process. The book said, nowadays we use APIC that have more functions. Also, the book said we will handle it later, so skip about APIC. We are going to handle PIC, so we need to implement a PIC driver.  Above image was PIC driver diagram what we’ll implement. They separated Master and Slave, Master connected 0x20 and 0x21 and Slave connected 0xA0 and 0xA1 each other that would be PortIO Map method. On here, We try to initialize using ICW(Initial Command Word) When We try to use that, We will use OCW(Operation Command Word) You could check detail on here We will use PortIO mapping when we try to initialize. We can use the PortIO Driver which made before. I constructed PIC directory in Driver directory and made PIC.c and PIC.c files. The contents are: //PIC.h#ifndef __PIC_H__#define __PIC_H__#include &lt;Types.h&gt;#define PIC_MASTER_PORT_1   0x20#define PIC_MASTER_PORT_2   0x21#define PIC_SLAVE_PORT_1    0xA0#define PIC_SLAVE_PORT_2    0xA1#define PIC_IRQ_VECTOR      0x20void InitializePIC();void MaskPICInterrupt(WORD _IRQ_Mask);void SendPIC_EOI(int _IRQ_Number);#endif /* __PIC_H__ */The four define lines are port numbers, below define line is an interrupt routine starting vector. (System reserved 1~31, so we are gonna use more than 32) And I use ICW, OCW. Implementation. //PIC.c#include \"PIC.h\"#include &lt;Driver/IO/PortIO.h&gt;void InitializePIC(){    //Initalize Master PIC    //ICW1 IC4 = 1    PortIO_OutByte(PIC_MASTER_PORT_1, 0x11);    //ICW2 Interrupt Vector Offset = 0x20 (32)    PortIO_OutByte(PIC_MASTER_PORT_2, PIC_IRQ_VECTOR);    //ICW3 Master-Slave Pin S2=1   |  0x04    PortIO_OutByte(PIC_MASTER_PORT_2, 0x04);    //ICW4 SFNM = 0 BUF = 0 M/S = 0 AEOI = 0 uPM = 1     PortIO_OutByte(PIC_MASTER_PORT_2, 0x01);        //Initalize Slave PIC    //ICW1 IC4 = 1    PortIO_OutByte(PIC_SLAVE_PORT_1, 0x11);    //ICW2 Interrupt Vector Offset = 0x28    PortIO_OutByte(PIC_SLAVE_PORT_2, PIC_IRQ_VECTOR + 8);    //ICW3 Master-Slave Pin Number = 2 | 0x2    PortIO_OutByte(PIC_SLAVE_PORT_2, 0x02);    //ICW4 SFNM = 0 BUF = 0 M/S = 0 AEOI = 0 uPM = 1    PortIO_OutByte(PIC_SLAVE_PORT_2, 0x01);}   void MaskPICInterrupt(WORD _IRQ_Mask){    //OCW1 IRQ0~IRQ7    PortIO_OutByte(PIC_MASTER_PORT_2, _IRQ_Mask);    //OCW1 IRQ8~IRQ15    PortIO_OutByte(PIC_SLAVE_PORT_2 , (BYTE)(_IRQ_Mask&gt;&gt;8));}void SendPIC_EOI(int _IRQ_Number){    //OCW2 NonSpecific EOI Command.    PortIO_OutByte(PIC_MASTER_PORT_1, 0X20);    //If Slave Interrupt.    if(_IRQ_Number&gt;=8)    {        PortIO_OutByte(PIC_SLAVE_PORT_1, 0x20);    }}In fact, This driver’s role just pushes the Command Word using Port IO. And the codes for Interrupt Process:  They contain interrupt setup, interrupt handler and interrupt service routine each other. //Interrupt.h#ifndef __INTERRUPT_H__#define __INTERRUPT_H__#include &lt;Types.h&gt;void EnableInterrupt();void DisableInterrupt();QWORD ReadFlags();#endif /*__INTERRUPT_H__*/It’s a quite short header file. This code connected assembly code directly. ;Interrupt.asm[BITS 64]SECTION .textglobal EnableInterrupt, DisableInterrupt, ReadFlagsEnableInterrupt:    sti    retDisableInterrupt:    cli    retReadFlags:    pushfq    pop rax    retThat used interrupt enable(sti), disable(cli) and inquiring Flag Register(pushfq). And Interrupt Service Routine’s role is context saving before calling interrupt handler and restore that context. Context saving(Fill into the stack)  And Restore the context (Pop Pop pop pop!) (If an error code has existed, We need to process that parameter) Interrupt Service routine’s header file is below. //InterService.h#ifndef __INTERRUPT_SERVICE_H__#define __INTERRUPT_SERVICE_H__//Reserved Exceptionsvoid ISRDividError();void ISRDebug();void ISRNMI();void ISRBreakPoint();void ISROverflow();void ISRBoundRangeExceeded();void ISRInvalidOpCode();void ISRDeviceNotAvailable();void ISRDoubleFault();void ISRCoProcessorSegmentOverrun();void ISRInvalidTSS();void ISRSegmentNotPresent();void ISRStackSegmentFault();void ISRGeneralProtection();void ISRPageFault();void ISR15();void ISRFloatingPointError();void ISRAlignmentCheck();void ISRMachineCheck();void ISRSIMDError();void ISRDefaultException();//PIC Interruptvoid ISRTimer();void ISRPS2Keyboard();void ISRSlavePIC();void ISRSerialPort2();void ISRSerialPort1();void ISRParallel2();void ISRFloppy();void ISRParallel1();void ISRRTC();void ISRReserved();void ISRNotUsed1();void ISRNotUsed2();void ISRPS2Mouse();void ISRCoprocessor();void ISRHDD1();void ISRHDD2();void ISRDefaultInterrupt();#endif /* __INTERRUPT_SERVICE_H__ */All of the Above header file content’s implementation connected assembly codes. I extracted part of them because it’s so huge. ;InterruptService.asm;...SKIP...ISRDividError:    SAVECONTEXT    mov rdi, 0    call DefaultExceptionHandler    LOADCONTEXT    iretqISRDebug:    SAVECONTEXT    mov rdi, 1    call DefaultExceptionHandler    LOADCONTEXT    iretqISRNMI:    SAVECONTEXT    mov rdi, 2    call DefaultExceptionHandler    LOADCONTEXT    iretqISRBreakPoint:    SAVECONTEXT    mov rdi, 3    call DefaultExceptionHandler    LOADCONTEXT    iretqISROverflow:    SAVECONTEXT    mov rdi, 4    call DefaultExceptionHandler    LOADCONTEXT    iretq;...SKIP...SAVECONTEXT and LOADCONTEX are macro to use Context saving and restoring. Interrupt Service Routine’s assembly full Source Code That service routine called Handler function, that was implemented in InterruptHandler. Before that, I move Video memory output function PrintVideoMemory into Utility/Console.h because we used that here and there. Interrupt Handler’s header file. //InterruptHandler.h#ifndef __INTERRUPT_HANDLER_H__#define __INTERRUPT_HANDLER_H__#include &lt;Types.h&gt;void DefaultExceptionHandler(int _Vector, QWORD _ErrorCode);void DefaultInterruptHandler(int _Vector);void KeyboardInterruptHandler(int _Vector);#endif /*__INTERRUPT_HANDLER_H__*/Each other, Default Handler and Keyboard Handler. Implementation is: //InterruptHandler.c#include \"InterruptHandler.h\"#include &lt;Driver/PIC/PIC.h&gt;#include &lt;Utility/Console.h&gt;void __DebugIntOutput(int _Vector, int _Count){    char Buffer[] = \"[INT:  ,  ]\";    Buffer[5] = _Vector/10 + '0';    Buffer[6] = _Vector%10 + '0';    Buffer[8] = _Count/10  + '0';    Buffer[9] = _Count%10  + '0';      PrintVideoMemory(69,0,0x0F,Buffer);}void DefaultExceptionHandler(int _Vector, QWORD _ErrorCode){    char Buffer[3] = {0,};    Buffer[0] = '0' + _Vector/10;    Buffer[1] = '0' + _Vector%10;    PrintVideoMemory(0,0,0xF,\"================================================================================\");    PrintVideoMemory(0,1,0xF,\"Exception:                                                                      \");    PrintVideoMemory(0,2,0xF,\"                                                                                \");    PrintVideoMemory(0,3,0xF,\"================================================================================\");    PrintVideoMemory(11,1,0xF, Buffer);    while(1);}void DefaultInterruptHandler(int _Vector){        static int g_DefaultInterruptCounter = 0;    g_DefaultInterruptCounter = (g_DefaultInterruptCounter + 1)%100;    __DebugIntOutput(_Vector, g_DefaultInterruptCounter);    SendPIC_EOI(_Vector - PIC_IRQ_VECTOR);}void KeyboardInterruptHandler(int _Vector){        static int g_KeyboardInterruptCounter = 0;    g_KeyboardInterruptCounter = (g_KeyboardInterruptCounter + 1)%100;    __DebugIntOutput(_Vector, g_KeyboardInterruptCounter);    SendPIC_EOI(_Vector - PIC_IRQ_VECTOR);}As you can see I made that If an exception occurs, the system would be stopped and you can check the exception number through the monitor. At the interrupt process, codes would return, not anymore busy waiting. Also, Interrupt occurs information and counter display at right-up. Now, We are going to load the interrupt service routine to IDT before we made it. Before IDT initialize codes right below. void InitializeIDTTables(){    IDTR* idtr = (IDTR*) IDTR_POINTER;    IDT_ENTRY* entry =  (IDT_ENTRY*)(IDTR_POINTER + sizeof(IDTR));        idtr-&gt;BaseAddress   = (QWORD)entry;    idtr-&gt;Size          = IDT_TABLE_SIZE - 1;    for(int i = 0; i &lt; IDT_MAX_ENTRY_COUNT; i++)     {        SetIDTEntry(&amp;entry[i],DummyHandler,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    }}Okay, we don’t need to use Dummy Handler. Let’s connect the real thing. //IDT.cvoid InitializeIDTTables(){    IDTR* idtr = (IDTR*) IDTR_POINTER;    IDT_ENTRY* entry =  (IDT_ENTRY*)(IDTR_POINTER + sizeof(IDTR));        idtr-&gt;BaseAddress   = (QWORD)entry;    idtr-&gt;Size          = IDT_TABLE_SIZE - 1;    SetIDTEntry(&amp;entry[0],ISRDividError,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[1],ISRDebug,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[2],ISRNMI,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[3],ISRBreakPoint,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[4],ISROverflow,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[5],ISRBoundRangeExceeded,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[6],ISRInvalidOpCode,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[7],ISRDeviceNotAvailable,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[8],ISRDoubleFault,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[9],ISRCoProcessorSegmentOverrun,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[10],ISRInvalidTSS,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[11],ISRSegmentNotPresent,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[12],ISRStackSegmentFault,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[13],ISRGeneralProtection,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[14],ISRPageFault,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[15],ISR15,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[16],ISRFloatingPointError,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[17],ISRAlignmentCheck,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[18],ISRMachineCheck,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[19],ISRSIMDError,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[20],ISRDefaultException,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    for(int i= 21; i &lt; 32 ; i++)    {        SetIDTEntry(&amp;entry[i],ISRDefaultException,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    }    SetIDTEntry(&amp;entry[32],ISRTimer,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[33],ISRPS2Keyboard,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[34],ISRSlavePIC,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[35],ISRSerialPort2,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[36],ISRSerialPort1,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[37],ISRParallel2,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[38],ISRFloppy,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[39],ISRParallel1,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[40],ISRRTC,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[41],ISRReserved,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[42],ISRNotUsed1,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[43],ISRNotUsed2,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[44],ISRPS2Mouse,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[45],ISRCoprocessor,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[46],ISRHDD1,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    SetIDTEntry(&amp;entry[47],ISRHDD2,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);        for(int i = 48; i &lt; IDT_MAX_ENTRY_COUNT; i++)    {        SetIDTEntry(&amp;entry[i],ISRDefaultInterrupt,0x08, IDT_ENTRY_IST1, IDT_ENTRY_KERNEL, IDT_TYPE_INTERRUPT);    }}It looks so huge but it just repeated code. Anyway, I wrote that code and try to build and try to fix some bugs. Launch. It’s blinking. I wanna find why it is. Blinking occurs when I try to active interrupt. So my mental was exploded, and I try to take a rest. After that i try to read the code. I removed interrupt active code, and I try to occur Divide By Zero. It worked. Strange. If IDT is a problem, it shouldn’t work, but it’s worked. So I check detail. I find the problem. IDT_MAX_ENTRY_COUNT * sizeof(IDT_ENTRY)It should be below not above code. IDT_MAX_ENTRY_COUNT + sizeof(IDT_ENTRY)So It would make 0 Exception Divide by zero, but it wouldn’t make Timer Interrupt in PIC. So It shut down the system and repeated. I’m so proud about it is worked. Interrupt was worked and the counter was increased. Now, Keyboard Driver update that would use interrupt was left. And Next is the Long-awaited SHELL!! Thanks for reading this long story. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Interrupt","64bit"],
        "url": "https://devsdk.github.io/development/2017/07/12/InterruptHandling.html"
      },{
        "title": "Keyboard Driver Update-Interrupt",
        "excerpt":"I think this article was short. Today I cannot focus strangely. In the morning I could focus greatly but now I can’t. Anyway, at this time, I guess this article wouldn’t too long. Until now we use a Port Map IO that used buffer from PS/2’s memory, but if we use the interrupt, we can’t use that buffer. Because the data load and de-load time is too different. So I made InputBuffer as you well-know. Data Structure is Queue. I considered about directory which would be used generally. DS makes an image about Nintendo DS, so I hate it. DataStructure is too long. SO I just decide UDS (Universal Data Strcture). I made Queue.h and Queue.c files in UDS directory. That was a Circular Queue. That was the general queue, so you can understand easily if you have a little knowledge. Implemented by C, It can be Identify by the first parameter that Queue Descriptor Anyway, Below code is a specific implementation. //Queue.h#ifndef __QUEUE_H__#define __QUEUE_H__#include &lt;Types.h&gt;#pragma pack(push, 1)typedef struct _struct_QueueDescriptor{    int DataSize;    int MaxDataCount;    void* MemoryArray;    unsigned int Front;    unsigned int Rear;    BOOL isLastPut;} QUEUE;#pragma pack(pop)void InitializeQueue(QUEUE* _QD, void* _QueueBuffer, int _MaxDataCount, int _DataSize);BOOL IsQueueFull(const QUEUE* _QD);BOOL IsQueueEmpty(const QUEUE* _QD);BOOL PushQueue(QUEUE* _QD, const void* _Src);BOOL PopQueue(QUEUE* _QD, void* _Dst);#endif /*__QUEUE_H__*/It just queue as you know. Skip description. //Queue.c#include \"Queue.h\"#include &lt;Utility/Memory.h&gt;void InitializeQueue(QUEUE* _QD, void* _QueueBuffer, int _MaxDataCount, int _DataSize){    _QD-&gt;MaxDataCount = _MaxDataCount;    _QD-&gt;DataSize = _DataSize;    _QD-&gt;MemoryArray = _QueueBuffer;    _QD-&gt;Front = 0;    _QD-&gt;Rear = 0;    _QD-&gt;isLastPut = FALSE;}BOOL IsQueueFull(const QUEUE* _QD){    if((_QD-&gt;Rear == _QD-&gt;Front) &amp;&amp; (_QD-&gt;isLastPut == TRUE))        return TRUE;    return FALSE;}BOOL IsQueueEmpty(const QUEUE* _QD){    if((_QD-&gt;Rear == _QD-&gt;Front) &amp;&amp; (_QD-&gt;isLastPut == FALSE))        return TRUE;    return FALSE;}BOOL PushQueue(QUEUE* _QD, const void* _Src){    if(IsQueueFull(_QD))        return FALSE;    _MemCpy(((char*)_QD-&gt;MemoryArray) + (_QD-&gt;DataSize * _QD-&gt;Front),  _Src, _QD-&gt;DataSize);    _QD-&gt;Front = (_QD-&gt;Front + 1) % _QD-&gt;MaxDataCount;    _QD-&gt;isLastPut = TRUE;    return TRUE;}BOOL PopQueue(QUEUE* _QD, void* _Dst){    if(IsQueueEmpty(_QD))        return FALSE;    _MemCpy(_Dst, (char*)_QD-&gt;MemoryArray + (_QD-&gt;DataSize * _QD-&gt;Rear ) , _QD-&gt;DataSize);    _QD-&gt;Rear = (_QD-&gt;Rear + 1) % _QD-&gt;MaxDataCount;    _QD-&gt;isLastPut = FALSE;    return TRUE;}If you don’t wanna read the code, you can skip and mind it is just queue as well. Anyway, we should make a keyboard input buffer using this data structure and use it on Interrupt Handling function. First, Write the General Queue in Keyboard.h. Also, make a structure for key-data. //Keybuard.h//....skip#define KEY_BUFFER_SIZE 100typedef struct _KeyDataStruct{    BYTE ScanCode;    BYTE ASCIICode;    BYTE Flags;} KEYDATA;static QUEUE g_KeyBufferQueue;static KEYDATA g_KeyBufferMemory[KEY_BUFFER_SIZE];void InitalizeKeyboardBuffer();BOOL ConvertScanCodeWithPushKeyQueue(BYTE _ScanCode);BOOL GetKeyData(KEYDATA* _data);//....skipAbove functions’ implementation is below. //Keyboard.c//...skipvoid InitalizeKeyboardBuffer(){    InitializeQueue(&amp;g_KeyBufferQueue, g_KeyBufferMemory, KEY_BUFFER_SIZE, sizeof(KEYDATA));}BOOL ConvertScanCodeWithPushKeyQueue(BYTE _ScanCode){    KEYDATA keydata;    keydata.ScanCode = _ScanCode;    BOOL result = FALSE;    if(ConvertScancodeToASCII(_ScanCode, &amp;keydata.ASCIICode, &amp;keydata.Flags) == TRUE)    {        BOOL interrupt_status = SetInterruptFlag(FALSE);        result = PushQueue(&amp;g_KeyBufferQueue, &amp;keydata);        SetInterruptFlag(interrupt_status);    }    return result;BOOL GetKeyData(KEYDATA* _data){    BOOL result = FALSE;    if(IsQueueEmpty(&amp;g_KeyBufferQueue))        return FALSE;    BOOL interruptstatus = SetInterruptFlag(FALSE);    result = PopQueue(&amp;g_KeyBufferQueue,_data);    SetInterruptFlag(interruptstatus);    return result;}}//...skipFrom above, Initialization queue for buffer function, Pushing Keydata from ScanCode into the queue function and Getting key data from the Queue function. You can see below the line on pushing queue, it makes turning off interrupts. BOOL interrupt_status = SetInterruptFlag(FALSE);And after pushing, that flag was restored. Because I don’t wanna make a problem related to synchronization. While queue operation, we are blocking interrupt function to avoid problems like change operation order. SetInterruptFlag function was defined in Utility/Flags.h Implementationn content is: //Flags.cBOOL SetInterruptFlag(BOOL _flag){    QWORD flag;    flag = ReadFlags();    if(_flag == TRUE)        EnableInterrupt();    else        DisableInterrupt();    if(flag &amp; 0x0200)        return TRUE;    else        return FALSE;}It was made by ReadFlags, EnagleInterrupt, and DisableInterrupt which were we made. And next, the LED and Keyboard activation request and waiting response code’s changed. BOOL WaitACKWithScanCodePushQueue(){    BOOL result = FALSE;    for(int i = 0; i&lt; 100; i++)    {        for(int j = 0 ; j &lt; 0xFFFF; j++)        {            if(PS2CheckOutputBufferNotEmpty())                break;        }                BYTE data = PortIO_InByte(0x60);        if(data == 0xFA)        {            result = TRUE;            break;        }        else        {            ConvertScanCodeWithPushKeyQueue(data);        }    }    return result;     }Add code above.     for(int i=0; i&lt; 100; i++)    {        //....    }I add awaiting function on ACK awaiting code above. result = WaitACKWithScanCodePushQueue();    if(result == FALSE)        return FALSE;You can see specifically And Interrupt Handler part function can process data cause below code appended.    if(PS2CheckOutputBufferNotEmpty() == TRUE)    {        BYTE scancode = PS2GetKeyboardScanCode();        ConvertScanCodeWithPushKeyQueue(scancode);    }And Change the input process part in kernel entry to use Queue.         if(GetKeyData(&amp;keydata) == TRUE)        {            if(keydata.Flags &amp; KEY_DOWN)            {                temps[0] = keydata.ASCIICode;                PrintVideoMemory(i++, 17, 0x0C, temps);            }        }Now we can process input using the queue. Also Interrupt too. It looks the same, but an internal huge changed.  Now we use the input queue, So If we wanna make some Input Driver, we can use the queue. Simply, It get a layer. I think I can use it when I write USB Keyboard Driver. Thanks for reading. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Interrupt","64bit"],
        "url": "https://devsdk.github.io/development/2017/07/13/InterruptKeyboard.html"
      },{
        "title": "Finally It looks OS! Shell development complete!",
        "excerpt":"This article should be huge. Shell. Finally, My 0SOS has an initial version CLI. Now It looks like an OS. Also, the Source tree grow bigger and bigger.  Above image was source tree of 0SOS. Many things already implemented. Also, many things need implementation Anyway, This time It was made here and there. I’ve implemented Printf and SPrint functions in the All-time Cafe where I went before, talking with friends.  In fact, I’ve spent talking time more than development time, so It made slowly. And Next day Also I’ve spent development time and the next day too. Writing Article on the blog was enjoyment after rushing development time. I think this article would be written separately. Ah anyway, 0SOS has a console shell. Scrolling looks nice. If you see it an only image, you wouldn’t feel like me, so I prepare a youtube video. How many time I spent preparing for running a command shell It needs starting at 16-bit bootloader assembly codes, Preparing to jump 16-bit mode to 32-bit kernel and preparing to jump 32 bit to 64-bit mode, Keyboard driver and Interrupt handling. In this time, Developing Printf function(also SPrintf for later) and GetCh function is made for input commands. And It would be used on Shell codes. This time also I don’t refer the book. Well if it works same, it’s fine (And I don’t carry my book cause it’s too heavy) Variable argument function can be found on Google, So It’s no problem. But the problem is… I’m not sure it can be used OS development. So I try to search. After that, I knew it is possible. So We need to implement output format and escape sequence. We should print %d and %x that should works number-&gt;charactor on screen or memory. I think standard function already have an efficient algorithm, so I try to google it and I found magnificent codes. BOOL _itoa(long _value, char* _result, int _base){    if (_base &lt; 2 || _base &gt; 36) { *_result = '\\0'; return FALSE; }    char* ptr = _result, *ptr1 = _result, tmp_char;    int tmp_value;    //It works negative and positive.    do {        tmp_value = _value;        _value /= _base;        *ptr++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\"[35 + (tmp_value - _value * _base)];    } while (_value);    //Sign     if (tmp_value &lt; 0) *ptr++ = '-';    *ptr-- = '\\0';    //Reverse    while (ptr1 &lt; ptr) {        tmp_char = *ptr;        *ptr-- = *ptr1;        *ptr1++ = tmp_char;    }    return TRUE;}I try to change a little, but it is same structure. It uses on GCC they said. Constructing-character table and reserve table for a negative and positive number. And we use that to make characters from the number. Now We have an itoa function, let’s implement atoi function to change the character to number. BOOL _atoi(const char* _number, long* _value, int _base){    if (!_number)        return FALSE;    if (_base &lt; 2 || _base &gt; 36)        return FALSE;    int sign = 1;    int i = 0;    if (_number[0] == '-')    {        sign = -1;        i = 1;    }    long result = 0;    char c = 0;    while ((c = _number[i++]) != '\\0')    {        int num = _ctoi(c);        if (num &gt; _base)            return FALSE;        result = result * _base + num;    }    *_value = sign*result;    return TRUE;}On the above code, _ctoi function returns a number corresponding to the character. ex) ‘a’ is 10 (You can read the full source code.) Returning value takses r = r * base + v per digit. For example, When ‘202’ value number input: 1) r =  0 * 10  + 2 r = 2 2) r = 2 * 10  + 0 r = 20 3) r = 20 * 10 + 2 r = 202 end. So It makes the number 202. No difference if it hexadecimal value or octet. Anyway, Those functions were implemented in Utility/string.c. Now we have functions for change the character to number and reverse, so let’s makes Printf and Sprtinf functions. I defined information of attribute for output and cursor position in a header file. //Console.h#ifndef __CONSOLE_H__#define __CONSOLE_H__#include &lt;Types.h&gt;#include &lt;stdarg.h&gt;#define FORMAT_BUFFER_SIZE 200    #define PRINT_MEMORY 0x01#define PRINT_OUTPUT 0x02#define CONSOLE_WIDTH 80#define CONSOLE_HEIGHT 25#define CONSOLE_VIDEO_MEMORY    0xB8000#define CONSOLE_BACKGROUND_BLACK    0x00#define CONSOLE_BACKGROUND_BLUE     0x10#define CONSOLE_BACKGROUND_GREEN    0x20#define CONSOLE_BACKGROUND_CYAN     0x30#define CONSOLE_BACKGROUND_RED      0x40#define CONSOLE_BACKGROUND_MAGENTA  0x50#define CONSOLE_BACKGROUND_BROWN    0x60#define CONSOLE_BACKGROUND_WHITE    0x70#define CONSOLE_BACKGROUND_BLINK    0x80#define CONSOLE_FOREGROUND_DARKBLACK    0x00#define CONSOLE_FOREGROUND_DARKBLUE     0x01#define CONSOLE_FOREGROUND_DARKGREEN    0x02#define CONSOLE_FOREGROUND_DARKCYAN     0x03#define CONSOLE_FOREGROUND_DARKRED      0x04#define CONSOLE_FOREGROUND_DARKMAGENTA  0x05#define CONSOLE_FOREGROUND_DARKBROWN    0x06#define CONSOLE_FOREGROUND_DARKWHITE    0x07#define CONSOLE_FOREGROUND_BLACK        0x08#define CONSOLE_FOREGROUND_BLUE         0x09#define CONSOLE_FOREGROUND_GREEN        0x0A#define CONSOLE_FOREGROUND_CYAN         0x0B#define CONSOLE_FOREGROUND_RED          0x0C#define CONSOLE_FOREGROUND_MAGENTA      0x0D#define CONSOLE_FOREGROUND_BROWN        0x0E#define CONSOLE_FOREGROUND_WHITE        0x0F#define COLOR_DEFAULT (CONSOLE_BACKGROUND_BLACK|CONSOLE_FOREGROUND_WHITE)#pragma pack(push, 1)typedef struct _Struct_ConsoleCursor{    int cursor_offset;    DWORD current_attribute;} CONSOLESYSTEM;typedef struct _Charactor_Struct{    BYTE bCharactor;    BYTE bAttribute;} CHARACTER_MEMORY;#pragma pack(pop)static CONSOLESYSTEM g_console_system = {0,COLOR_DEFAULT};void _PrintStringXY(int _x, int _y, BYTE _Attribute ,const char* _str);void _PrintChar_offset(int _offset, BYTE _attribute, char _ch);void _Printf(char* _str, ...);void _SPrintf(void* _dst, char* _str, ...);char _GetCh();void __VSPrintf(BYTE _type, const void* _dst, char* str, va_list _arg);void __NextLine();void __NextScroll();void __SetConsole_System(CONSOLESYSTEM value);CONSOLESYSTEM __GetConsole_System();#endif /*__CONSOLE_H__*/Uh, too many define. But as you can see, it’s all attribute value for Framebuffer. CONSOLESYSTEM g_console_system variable takes cursor position, output color and etc. //Console.cvoid __UpdateWithCheckConsoleCursor(){    if(g_console_system.cursor_offset + 1 &gt;=        CONSOLE_HEIGHT * CONSOLE_WIDTH)            {            __NextScroll();                g_console_system.cursor_offset = CONSOLE_WIDTH*(CONSOLE_HEIGHT - 1);            }        else        {            g_console_system.cursor_offset++;            }}void __putch(char _ch, BYTE _attribute){    _PrintChar_offset(g_console_system.cursor_offset, _attribute, _ch);    __UpdateWithCheckConsoleCursor();}void __PrintOutInteger(long _value, char* _buffer, int _base){    _itoa(_value, _buffer, _base);    for (int i = 0; _buffer[i] != '\\0'; i++)    {        __putch(_buffer[i], g_console_system.current_attribute);    }}char* __PrintMemInteger(long _value, char* _dst, int _base){    char Buffer[FORMAT_BUFFER_SIZE];    _itoa(_value, Buffer, _base);    int length = __StringLength(Buffer);    _MemCpy(_dst, Buffer, length);    return _dst + length;}void __VSPrintf(BYTE _type, const void* _dst, char* str, va_list _arg){    char* ptr = str;    char Buffer[FORMAT_BUFFER_SIZE];    char* dst = (char*)_dst;    while (*ptr != '\\0')    {        char output = *ptr;            int value = 0;        char ch = 0;        char* str = 0;        QWORD qvalue = 0;        if (*ptr == '%')        {            ptr++;            switch (*ptr)            {                case 'd':                value = (int)(va_arg(_arg, int));                if (_type == PRINT_OUTPUT)                    __PrintOutInteger(value, Buffer, 10);                else if (_type == PRINT_MEMORY)                    dst = __PrintMemInteger(value, dst, 10);                break;            case 'o':                value = (int)(va_arg(_arg, int));                if (_type == PRINT_OUTPUT)                    __PrintOutInteger(value, Buffer, 8);                else if (_type == PRINT_MEMORY)                    dst = __PrintMemInteger(value, dst, 8);                break;            case 'x':                value = (int)(va_arg(_arg, int));                if (_type == PRINT_OUTPUT)                    __PrintOutInteger(value, Buffer, 16);                else if (_type == PRINT_MEMORY)                    dst = __PrintMemInteger(value, dst, 16);                                    break;                //case 'f':                //case 'g':                //TODO: Floating Point            case 'p':                qvalue = (QWORD)(va_arg(_arg, void*));                    if (_type == PRINT_OUTPUT)                {                    __putch('0', g_console_system.current_attribute);                    __putch('x', g_console_system.current_attribute);                    __PrintOutInteger(qvalue, Buffer, 16);                }                else if (_type == PRINT_MEMORY)                {                    dst[0] = '0';                    dst[1] = 'x';                    dst = __PrintMemInteger(qvalue, dst+ 2, 16);                }                                    break;            case 'c':                ch = (char)(va_arg(_arg,int));                if (_type == PRINT_OUTPUT)                    __putch(ch, g_console_system.current_attribute);                else if (_type == PRINT_MEMORY)                {                    dst[0] = ch;                    dst++;                }                break;            case 's':                str = (char*)(va_arg(_arg, char*));                if (_type == PRINT_OUTPUT)                    _Printf(str);                else if (_type == PRINT_MEMORY)                {                    _SPrintf(dst, str);                    int len = __StringLength(str);                    dst += len;                }                break;            default:                break;            }        }This is the heart of Printf and Sprintf function. Also, the above codes are helper functions for the implementation of VSPrintf. Implementations are so different from the book. Book implemented this using buffer array, but I don’t wanna that. So I made this to write directly without a buffer. and __putch. It processes output characters when it meets % character. And I implement this separately from Sprintf and Printf function. When it meets Character ‘%s’, _Sprint and _Printf function are called. Because if it has an escape sequence, it needs to process that. You can notice about internal of the Printf and Sprintf will call a _VSPrintf function by type. //Console.cvoid _Printf(char* _str, ...){    va_list _arg;    va_start(_arg, _str);    __VSPrintf(PRINT_OUTPUT, 0, _str, _arg);    va_end(_arg);    _SetCursor(g_console_system.cursor_offset % CONSOLE_WIDTH,                 g_console_system.cursor_offset / CONSOLE_WIDTH);}void _SPrintf(void* _dst, char* _str, ...){    va_list _arg;    va_start(_arg, _str);    __VSPrintf(PRINT_MEMORY, _dst, _str, _arg);    va_end(_arg);}void _PrintStringXY(int _x, int _y, BYTE _Attribute ,const char* _str){    CHARACTER_MEMORY* Address = ( CHARACTER_MEMORY* ) CONSOLE_VIDEO_MEMORY;    int i = 0;    Address+= ( _y * 80 ) + _x;        for ( i = 0; _str[i] != 0; i++)    {        Address[i].bCharactor = _str[i];        Address[i].bAttribute = _Attribute;            }}void _PrintChar_offset(int _offset, BYTE _attribute, char _ch){    CHARACTER_MEMORY* Address = ( CHARACTER_MEMORY* ) CONSOLE_VIDEO_MEMORY;    int i = 0;    Address+= _offset;    Address[0].bCharactor = _ch;    Address[0].bAttribute = _attribute;}void __NextLine(){    int addoffset =CONSOLE_WIDTH - (g_console_system.cursor_offset%CONSOLE_WIDTH);    if( g_console_system.cursor_offset + addoffset &gt;= CONSOLE_HEIGHT * CONSOLE_WIDTH)            {            __NextScroll();            g_console_system.cursor_offset = CONSOLE_WIDTH*(CONSOLE_HEIGHT - 1);        }    else        g_console_system.cursor_offset += addoffset;}void __NextScroll(){    _MemCpy(CONSOLE_VIDEO_MEMORY,         CONSOLE_VIDEO_MEMORY + CONSOLE_WIDTH* sizeof(CHARACTER_MEMORY),             (CONSOLE_HEIGHT-1) * CONSOLE_WIDTH * sizeof(CHARACTER_MEMORY)  );    CHARACTER_MEMORY* target = (CHARACTER_MEMORY*)(CONSOLE_VIDEO_MEMORY) + (CONSOLE_HEIGHT-1) * CONSOLE_WIDTH ;    for(int i = 0; i &lt;CONSOLE_WIDTH; i++)        target[i].bCharactor = ' ';}New line and scrolling look a little bit complicated but the principle is simple. Scrolling is just shifting-down in video memory. (Clear the last line) And Lastly, I made _GetCh function. It’s simply worked get character. //Console.cchar _GetCh(){    KEYDATA keydata;    while(1)    {        if(GetKeyData(&amp;keydata) == TRUE)        {            if(keydata.Flags &amp; KEY_DOWN)            {                return keydata.ASCIICode;            }        }    }}So Now we are ready for developing Shell. Let’s see Shell.h. //Shell.c#ifndef __SHELL_H__#define __SHELL_H__#include &lt;Types.h&gt;#define SHELL_INPUT_BUFFER_SIZE 500#define SHELL_PROMPT_MESSAGE    \"0SOS&gt;\"typedef void (*CommandCallBack) (const char* parameter);#pragma pack(push, 1)typedef struct __Struct_ShellCommandEntry{    char* Command;    char* Comment;    CommandCallBack command_callback;} SHELLCOMMAND;typedef struct __Struct_Shell_Parameters{    const char* Buffer;    int Length;    int CurrentPosition;} PARAMETERLIST;#pragma pack(pop)//--------------------------------------------------- *void Command_Help(const char* _Parameter);void Command_Clear(const char* _Parameter);void Command_ShutDown(const char* _Parameter);void Command_TotalRamSize(const char* _Parameter);void Command_StringToNumber(const char* _Parameter);//---------------------------------------------------*static SHELLCOMMAND g_ShellCommandTable[] = {     {\"clear\", \"clear the consol\\n-f {white, green, cyan,black} front color\\n-b {black, white, blue} back ground\\n\"    , Command_Clear},    {\"help\", \"help for 0SOS\", Command_Help},    {\"shutdown\", \"Shutdown PC\", Command_ShutDown},    {\"strtod\", \"String To Hex or Decimal\", Command_StringToNumber},    {\"totalram\", \"Show Ram Size\", Command_TotalRamSize}};void Clear();void SetAttribute(BYTE _attribute);void StartShell();void ExecuteCommand(const char * CommandBuffer);void InitalizeParameter(PARAMETERLIST* _List, const char* _Parameter);int GetNextParameter(PARAMETERLIST* _List, char* _Parameter_Out);#endif /*__SHELL_H__*/Shell header file. The structure is just called StartShell function from Kernel Entry. And process command line with an infinite loop. You could see something special line. typedef void (*CommandCallBack) (const char* parameter);Ta-da, function pointer. That is contained in SHELLCOMMAND and connect commands through the g_ShellCommandTable. Also, InitializeParameter and GetNextParameter function works registering the parameter characters and get parameter from those characters. For that, We had PARAMETERLIST structure. All of the prefix Command_ functions are callback function for the process command line. //Shell.cvoid StartShell(){    __InitializeMemoryCheck();    char CommandBuffer[SHELL_INPUT_BUFFER_SIZE];    _SetCursor(0, 17);    int CommandBufferIndex = 0;    _Printf(SHELL_PROMPT_MESSAGE);    const int Prompt_length = sizeof(SHELL_PROMPT_MESSAGE);    while(1)    {           BYTE c = _GetCh();        if(c == KEY_BACKSPACE)        {            if(CommandBufferIndex &gt; 0)            {                int x, y;                _GetCursor(&amp;x, &amp;y);                int dx = x - Prompt_length;                   for(int i = dx; i &lt; CommandBufferIndex; i++)                {                    CommandBuffer[i] = CommandBuffer[i + 1];                }                                for(int i = 0; i&lt; CONSOLE_WIDTH; i++)                {                    _PrintStringXY(i,y, __GetConsole_System().current_attribute, \" \");                    }                                _SetCursor(0, y);                _Printf(SHELL_PROMPT_MESSAGE);                _Printf(\"%s\", CommandBuffer);                if((x-1) &gt;= Prompt_length)                    _SetCursor(x-1, y);                else                    _SetCursor(x, y);                               CommandBufferIndex --;                if(CommandBufferIndex == 0)                {                    _SetCursor(Prompt_length-1, y);                                    }            }        }        else if(c == KEY_ENTER)        {            _Printf(\"\\n\");            if(CommandBufferIndex &gt; 0)            {                CommandBuffer[CommandBufferIndex] = '\\0';                ExecuteCommand(CommandBuffer);            }            _Printf(SHELL_PROMPT_MESSAGE);            CommandBufferIndex = 0;            _MemSet(CommandBuffer,0 , SHELL_INPUT_BUFFER_SIZE);        }        else if( (c == KEY_LSHIFT) || (c == KEY_RSHIFT) || (c == KEY_CAPSLOCK)                || (c == KEY_NUMLOCK) || (c == KEY_SCROLLLOCK))        {            ;        }        else if (c == KEY_ARROW_LEFT)        {            int x,y;            _GetCursor(&amp;x, &amp;y);            if((x - 1) &gt;= Prompt_length)            {                _SetCursor(x - 1, y);            }        }        else if(c == KEY_ARROW_RIGHT)        {            int x,y;            _GetCursor(&amp;x, &amp;y);            if((x + 1) &lt;= CommandBufferIndex)            {                _SetCursor(x + 1, y);            }        }        else        {            if(c == KEY_TAB)                c = ' ';            if(CommandBufferIndex &lt; SHELL_INPUT_BUFFER_SIZE)            {                CommandBuffer[CommandBufferIndex ++ ] = c;                _Printf(\"%c\", c);            }        }    }    }Start Shell function. __InitalieMemoryCheck is implemented in Utility/Memory and set global variable after checking memory size and get that value using __GetTotalRamSize() function. This will ignore arrows, shift, and capslock. Until now, When we press kind of shift key, it makes some weird characters. Now, that problem solved by those codes. (But another alt key makes that, it need to implement) And Enter the key most important part is processed by the ExecuteCommand function. void ExecuteCommand(const char * CommandBuffer){    int command_index = 0;    const int length = __StringLength(CommandBuffer);    for(command_index = 0; command_index &lt; length; command_index++)    {        if(CommandBuffer[command_index] == ' ')            break;    }    const int CommandTableSize = sizeof(g_ShellCommandTable)/sizeof(SHELLCOMMAND);    for(int i = 0; i &lt;CommandTableSize; i++)    {        int command_length = __StringLength(g_ShellCommandTable[i].Command);        if((command_length == command_index) &amp;&amp; (_MemCmp(g_ShellCommandTable[i].Command, CommandBuffer, command_index) == 0))        {            g_ShellCommandTable[i].command_callback(CommandBuffer + command_index + 1);            return;        }     }      _Printf(\"\\'%s\\' command not found\\n\",CommandBuffer);  }This function simple work separating parameter and command and calling the function from the command table. It has so many commands so I can’t descript all about that. So Except help command, You can see here! //Shell.cvoid Command_Help(const char* _Parameter){    _Printf(\"\\n\");    _Printf(\"============================= Help ===========================\\n\");    const int command_table_size = sizeof(g_ShellCommandTable) / sizeof(SHELLCOMMAND);    int max_command_length = 0;    for(int i = 0; i &lt;command_table_size; i ++)    {        int length = __StringLength(g_ShellCommandTable[i].Command);        if(length &gt; max_command_length)            max_command_length = length;    }    int x,y;    for(int i = 0; i &lt; command_table_size; i++)    {        _Printf(\"%s\", g_ShellCommandTable[i].Command);        _GetCursor(&amp;x, &amp;y);        _SetCursor(max_command_length, y);        _Printf(\" : %s\\n\", g_ShellCommandTable[i].Comment);    }    _Printf(\"============================= Help ===========================\\n\");    _Printf(\"\\n\");    }When We type ‘help’ characters and press enter key, that function will be called. I can see a little bit about how massive modern-OS. If you try this, you need many things for boot. Anyway, I can see more and more about low-level programming. But, It takes a lot of time. and next…. timer device driver and next is finally task… Let’s do this! ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","CLI","Shell","64bit"],
        "url": "https://devsdk.github.io/development/2017/07/18/shell.html"
      },{
        "title": "Implemented timer driver.",
        "excerpt":"Finally, I’ve got time for OS developing. I’m so busy so I can’t make time. Actually, I wrote code quite a bit with my laptop but it wasn’t a huge change.So I didn’t write an article. Before the article, the following is changing. Changed BOOL type unsigned char to c99 _Bool type in Types.h The reason why is little bit complicate. One of the reason is ! operator to unsigned char. Usually, When we try to not operation, we can faster if we use x xor 1. But I found different! operation between unsigned char and x xor 1.   It is definitely different. If I use compiler optimize option like -O3, it will be changed to xor. But It can be worked to un-properly. When I don’t use compiler optimize option, not operation’s instructions are more than xor. After cmp instruction, data was set through setne instruction. Because System thought it can use other bits not only t/f bit. So It has been solved by changing unsigned char to _Bool. Yeah, here we are the main topic. This time I’ve developed a timer. Specifically, I made PIT(Programmable Interval Timer) Driver, Timestamp and RTC(Real Time Clock) Driver. Below image is source tree.  We can access PIT through PortIO Driver at 0x43, 0x40, 0x41 and 0x42. Well, It needs to setup many bits. 7,6 - SC : Select Counter  for a target of a command 5,4 - RW : Read/Write     00: Read the current value of the counter (2byte)    01: R/W counter low bytes (1Byte)    10: R/W counter high bytes (1Byte)    11: R/W low to a high byte in counter(2Byte)3,2,1-Mode: Set up PIT controller count mode     000: Mode 0 (Interrupt during counting)    001: Mode 1 (Programmable monoflop)    010: Mode 2 (Clock rate generator)    011: Mode 3 (Square wave generator)    100: Mode 4 (Software-triggered impulse)    101: Mode 5 (Hardware-triggered impulse)0   - BCD : Setup counter to binary or BCD format.     BCD format until 0~9999     Binary format until 0x00~0xFFFF Anyway, that would be selected by SC field, below things are options. sDriver/Time/PIT.h #ifndef __PIT_H__#define __PIT_H__#include &lt;Types.h&gt;//PIT frequency 1.193182MHz #define PIT_FREQUENCY 1193182#define MS_TO_COUNT(x) (PIT_FREQUENCY * (x)/1000)#define US_TO_COUNT(x) (PIT_FREQUENCY * (x)/1000000)#define PIT_PORT_CONTROL    0x43#define PIT_PORT_COUNTER0   0x40#define PIT_PORT_COUNTER1   0x41#define PIT_PORT_COUNTER2   0x42#define PIT_CONTROL_SC_COUNTER0   0x00#define PIT_CONTROL_SC_COUNTER1   0x40#define PIT_CONTROL_SC_COUNTER2   0x80#define PIT_CONTROL_RW_BIT11      0x30#define PIT_CONTROL_RW_BIT00      0x00#define PIT_CONTROL_MODE_0        0x00#define PIT_CONTROL_MODE_2        0x04#define PIT_CONTROL_BCD_FALSE     0x00#define PIT_CONTROL_BCD_TRUE      0x01#define PIT_COUNTER0_FLAG_ONCE  (PIT_CONTROL_SC_COUNTER0 | PIT_CONTROL_RW_BIT11 | PIT_CONTROL_MODE_0 | PIT_CONTROL_BCD_FALSE)#define PIT_COUNTER0_FLAG_INTERVAL  (PIT_CONTROL_SC_COUNTER0 | PIT_CONTROL_RW_BIT11 | PIT_CONTROL_MODE_2 | PIT_CONTROL_BCD_FALSE)#define PIT_COUNTER0_FLAG_LATCH  (PIT_CONTROL_SC_COUNTER0 | PIT_CONTROL_RW_BIT00 )// SET PIT Counter 0 = _Count and Cange state Intervalvoid InitializePIT(WORD _Count, BOOL _IsInterval);WORD ReadTimerCount0();/*    Should be disable Interrupt    Parameter _Count : &lt; 50ms*/void WaitUsingPITCounter0(WORD _Count);#endif /*__PIT_H__*/PIT works on 1.19318 Mhz, decreasing counter value every single time to 0. If the counter value is 0, it would make a signal. We need to convert that PIC to time we use, we take formula t = 1193182 * rate ( ex: 1ms rate = 0.001 ) 0SOS is going to use counter 0 and the book said counter 1 and 2 are usually used main memory and speaker. It’ll be implemented by PortMapIO data read/write. #include \"PIT.h\"#include &lt;Driver/IO/PortIO.h&gt;void InitializePIT(WORD _Count, BOOL _IsInterval){    //If it has interval, it would be mode 2. If not, mode 0.    if(_IsInterval == TRUE)        PortIO_OutByte(PIT_PORT_CONTROL, PIT_COUNTER0_FLAG_INTERVAL);    else        PortIO_OutByte(PIT_PORT_CONTROL, PIT_COUNTER0_FLAG_ONCE);    //Set up upper bits and lower bits    PortIO_OutByte(PIT_PORT_COUNTER0, _Count);    PortIO_OutByte(PIT_PORT_COUNTER0, _Count &gt;&gt; 8);}WORD ReadTimerCount0(){    BYTE high, low;    WORD ret = 0x0000;    //Read data of Counter 0.    PortIO_OutByte(PIT_PORT_CONTROL, PIT_COUNTER0_FLAG_LATCH);    low = PortIO_InByte(PIT_PORT_COUNTER0);    high = PortIO_InByte(PIT_PORT_COUNTER0);    //Transfer 2 byte using upper and lower bits.    ret = high;    ret = (ret &lt;&lt; 8) | low;    return ret;}void WaitUsingPITCounter0(WORD _Count){    //Repeat 0~0xFFFF area.    WORD CurrentCounter = 0;    InitializePIT(0, TRUE);    const WORD LastCounter0 = ReadTimerCount0();    while(TRUE)    {        //Get Counter 0 Value        CurrentCounter = ReadTimerCount0();        //Value is incresed by time spent.          if(((LastCounter0 - CurrentCounter) &amp; 0xFFFF) &gt;= _Count)            break;        }}Initialize PIT function and read the counter 0 function and waiting for function by millisecond Next is a time stamp. The time stamp would be increased by clock and bus speed. So We can measure more detail of time. ;Driver/Time/TSC.asm[BITS 64]SECTION .textglobal ReadTSC;Return read value of time stamp counter.ReadTSC:    push rdx    rdtsc   ;Save time stamp counter value in rdx:rax.    shl rdx, 32    or rax, rdx ; upper 32bit tcs value of rdx register and lower tsc value of rax register to rax.    pop rdx    retLoad by RDTSC command. And next is RTC driver. RTC controller works for memorizing time. Also, it still works after off your PC. RTC data stored in CMOS memory. We should get RTC value to access CMOS. CMOS memory can be access by PortIO Driver, using memory address port 0x70 and data port 0x71. Table of RTC.  //Driver/Time/RTC.h#ifndef __RTC_H__#define __RTC_H__#include &lt;Types.h&gt;#define  PORT_CMOS_ADDRESS      0x70#define  PORT_CMOS_DATA         0x71#define  CMOS_ADDRESS_RTC_SECOND       0x00#define  CMOS_ADDRESS_RTC_MINUTE        0x02#define  CMOS_ADDRESS_RTC_HOUR          0x04#define  CMOS_ADDRESS_RTC_DAY_OF_WEEK   0x06#define  CMOS_ADDRESS_RTC_DAY_OF_MONTH  0x07#define  CMOS_ADDRESS_RTC_MONTH         0x08#define  CMOS_ADDRESS_RTC_YEAR          0x09//Changing BCD code. #define  BCD_TO_BIN(x) ((((x) &gt;&gt; 4) * 10) + ((x)  &amp; 0x0F ))void ReadRTCTime(BYTE* _Out_Hour, BYTE* _Out_Minute, BYTE* _Out_Second);void ReadRTCDate(WORD* _Out_Year, BYTE* _Out_Month, BYTE* _Out_DayOfMonth, BYTE* _Out_DayOfWeek);char* ConvertDayOfWeekString(BYTE _DayOfWeek);#endif /*__RTC_H__*/Defining the address field and getting data and changing the date to string is this code’s role. And RTC data from CMOS should transfer BCD code to binary. //Driver/Time/RTC.c#include \"RTC.h\"void ReadRTCTime(BYTE* _Out_Hour, BYTE* _Out_Minute, BYTE* _Out_Second){    BYTE data;    //Time data from CMOS memory is BCD code.    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_HOUR);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Hour = BCD_TO_BIN(data);    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_MINUTE);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Minute = BCD_TO_BIN(data);    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_SECOND);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Second = BCD_TO_BIN(data);    }void ReadRTCDate(WORD* _Out_Year, BYTE* _Out_Month, BYTE* _Out_DayOfMonth, BYTE* _Out_DayOfWeek){    BYTE data;    //Time data from CMOS memory is BCD code.    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_YEAR);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Year = BCD_TO_BIN(data) + 2000; //연도에 2000을 더해 2000년도를 표현    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_MONTH);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_Month = BCD_TO_BIN(data);    PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_DAY_OF_MONTH);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_DayOfMonth = BCD_TO_BIN(data);        PortIO_OutByte(PORT_CMOS_ADDRESS, CMOS_ADDRESS_RTC_DAY_OF_WEEK);    data = PortIO_InByte(PORT_CMOS_DATA);    *_Out_DayOfWeek = BCD_TO_BIN(data);    }char* ConvertDayOfWeekString(BYTE _DayOfWeek){    //weekdate to string    static char* WeekStringTable [8] = {\"NULL\", \"Sunday\", \"Monday\", \"Tushday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};    if(_DayOfWeek &gt;= 8)        return WeekStringTable[0];    return WeekStringTable[_DayOfWeek];Timer driver is completed by this! So We can use this driver in the shell command. void Command_SetTimer(const char* _Parameter){    char ParameterBuffer[200];    PARAMETERLIST pList;    InitializeParameter(&amp;pList, _Parameter);    if(GetNextParameter(&amp;pList,ParameterBuffer) == 0)    {        _Printf(\"settimer {time(ms)} {interval}\\n\");        return;    }    long value;    if(_atoi(ParameterBuffer, &amp;value, 10) == FALSE)    {        _Printf(\"Parameter Decimal number\\n\");        return;    }    if(GetNextParameter(&amp;pList,ParameterBuffer) == 0)    {        _Printf(\"settimer {time(ms)} {interval}\\n\");        return;    }    long interval_value;    if(_atoi(ParameterBuffer, &amp;interval_value, 10) == FALSE)    {        _Printf(\"Parameter is not Decimal number\\n\");        return;    }        InitializePIT(MS_TO_COUNT(value), interval_value != 0);    _Printf(\"Time = %d ms. Interval = %s Change Complate\\n\",value, (interval_value == 0)? \"False\": \"True\"); }void Command_PITWait(const char* _Parameter){    char ParameterBuffer[200];    PARAMETERLIST pList;    InitializeParameter(&amp;pList, _Parameter);    if(GetNextParameter(&amp;pList,ParameterBuffer)==0)    {        _Printf(\"wait {time(ms)}\\n\");        return;    }        long value;    if(_atoi(ParameterBuffer, &amp;value, 10) == FALSE)    {        _Printf(\"Parameter is not Decimal number\\n\");        return;    }    _Printf(\"%d ms Sleep Start...\\n\", value);    DisableInterrupt();    for(long i =0; i &lt; value/30L; i++)    {        WaitUsingPITCounter0(MS_TO_COUNT(30));    }    WaitUsingPITCounter0(MS_TO_COUNT(value % 30));            EnableInterrupt();    _Printf(\"%d ms Sleep Complate.\\n\", value);    InitializePIT(MS_TO_COUNT(1), TRUE); }void Command_ReadTimeStamp(const char* _Parameter){    QWORD tsc =  ReadTSC();    _Printf(\"Time Stamp Counter = %q \\n\",tsc);}void Command_CPUSpeed(const char* _Parameter){    QWORD last_tsc;    QWORD total_tsc = 0;    _Printf(\"Now Calculate.\");    DisableInterrupt();    for(int i = 0; i &lt; 200; i++)    {        last_tsc = ReadTSC();        WaitUsingPITCounter0(MS_TO_COUNT(50));        total_tsc+= ReadTSC() - last_tsc;        _Printf(\".\");    }    InitializePIT(MS_TO_COUNT(1),TRUE);    EnableInterrupt();    _Printf(\"\\n Cpu Clock = %d MHz \\n\", total_tsc/10/1000/1000);}void Command_ShowDateTime(const char* _Parameter){    BYTE Second, Minute, Hour;    BYTE DayOfWeek, DayOfMonth, Month;    WORD Year;    ReadRTCTime(&amp;Hour, &amp;Minute, &amp;Second);    ReadRTCDate(&amp;Year,&amp;Month,&amp;DayOfMonth, &amp;DayOfWeek);    _Printf(\"Date: %d-%d-%d %s, \", Year, Month, DayOfMonth, ConvertDayOfWeekString(DayOfWeek));    _Printf(\"Time: %d:%d:%d\\n\", Hour, Minute, Second);    }It is just print command from the driver.  Commands are added like this, rdtsc command works properly.  The result of another command. It prints date beautifully and measure CPU clock and waiting by milliseconds. Settimer works properly, but it cannot show by the image so I skip this. I fixed two of bugs, first thing is not properly working unsigned value at _Printf function. That fixed by %q and _u_itoa function. Second is reset bug from wrong setup control port in control 0 in PIT. It fixed the changing control port. Now we are going to make Task, multithread, synchronize and floating point. I expect that. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Paging","Timer","Interrupt","64bit"],
        "url": "https://devsdk.github.io/development/2017/08/03/timerdriver.html"
      },{
        "title": "TCB and Context and ContextSwitch",
        "excerpt":"Before I named the data structure ‘Universal Data Structure’ shortly ‘UDS’, I think General is more properly instead of Universal. So I changed UDS to GDS. I implemented Context Switching and Task for multitasking that was not yet supported. It doesn’t look massive. But It is task switching definitely.  Before we define “Task” we need to check out about Context. This Context, it was leaned OS in college. It’s Process and Task’s executed status. Context is just Register stored values and Stack. Context Switching is literally switching, that would execute here and there. The task is work that can be processed separately. In Task, Code and Data can be shared but Stack and Context keep separation. Latency time will be increased when you use timeslice instead of the batch process. So I’ll use Timeslice multitasking. Timeslice multitasking is context switching every millisecond by IRQ0 interrupt. //shell.cstatic TCB g_task[2] = {0.};static QWORD test_stack[1024] = {0,};void TaskTask(){    int iteration = 0;    while(1)    {        _Printf(\"[%d] Message from test task Press any key to switching\\n\",iteration++);        _GetCh();        ContextSwitch(&amp;g_task[1].Context, &amp;g_task[0].Context);    }}void Command_CreateTask(const char* _Parameter){    KEYDATA key;    InitTask(&amp;g_task[1],1,0, TaskTask, test_stack, sizeof(test_stack));        int iteration = 0;    while(1)    {        _Printf(\"[%d] message from shell Press any key to switching\\n\", iteration++);        if(_GetCh() =='q')            break;        ContextSwitch(&amp;g_task[0].Context, &amp;g_task[1].Context);          }}CreatTask function, it works for the creation of task and initialization. Context Switching, switching context function. Task Control Block, it is data-structure for context. And Defining offsets and context. I created Directory “Tasking” Tasking/Task.h: #ifndef __TASK_H__#define __TASK_H__#include &lt;Types.h&gt;//SS, RSP, RFLAGS, CS, RIP..  Context#define CONTEXT_REGISTER_COUNT     25#define CONTEXT_REGISTER_SIZE       8#define CONTEXT_OFFSET_GS           0#define CONTEXT_OFFSET_FS           1#define CONTEXT_OFFSET_ES           2#define CONTEXT_OFFSET_DS           3#define CONTEXT_OFFSET_R15          4#define CONTEXT_OFFSET_R14          5#define CONTEXT_OFFSET_R13          6#define CONTEXT_OFFSET_R12          7#define CONTEXT_OFFSET_R11          8#define CONTEXT_OFFSET_R10          9#define CONTEXT_OFFSET_R9           10#define CONTEXT_OFFSET_R8           11#define CONTEXT_OFFSET_RSI          12#define CONTEXT_OFFSET_RDI          13#define CONTEXT_OFFSET_RDX          14#define CONTEXT_OFFSET_RCX          15#define CONTEXT_OFFSET_RBX          16#define CONTEXT_OFFSET_RAX          17#define CONTEXT_OFFSET_RBP          18#define CONTEXT_OFFSET_RIP          19#define CONTEXT_OFFSET_CS           20#define CONTEXT_OFFSET_RFLAG        21#define CONTEXT_OFFSET_RSP          22#define CONTEXT_OFFSET_SS           23#pragma pack(push,1)typedef struct __CONTEXT_STRUCT{    QWORD Registers[CONTEXT_REGISTER_COUNT];} CONTEXT;typedef struct __TCB_STRUCT{    CONTEXT Context;    QWORD ID;    QWORD Flags;    void* StackAddress;    QWORD StackSize;} TCB;#pragma pack(pop)void InitTask(TCB* _Tcb, QWORD _ID, QWORD _Flags, QWORD _EntryPointAddress, void* _StackAddress, QWORD _StackSize);//Link Assembly Filevoid ContextSwitch(CONTEXT* _CurrentContext, CONTEXT* _NextContext);#endif /*__TASK_H__*/   It has many definitions, but there are just index and registers. It’ll be great for statically assigning value in the array. And than Context (It is just register-values) And TCB (It can be Task Control Block and Thread Control Block) TCB contain Context, ID, Flags, Stack Address, and Stack size Tasing/Task.c: #include \"Task.h\"#include &lt;Utility/Memory.h&gt;#include &lt;Descriptor/GDT.h&gt;void InitTask(TCB* _Tcb, QWORD _ID, QWORD _Flags, QWORD _EntryPointAddress, void* _StackAddress, QWORD _StackSize){    _MemSet(_Tcb-&gt;Context.Registers, 0, sizeof(_Tcb-&gt;Context.Registers));        //초기화 과정의 RSP, RBP 해당 Task의 Stack Pointer 기 떄문에 + Size     _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RSP] = (QWORD)_StackAddress + _StackSize;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RBP] = (QWORD)_StackAddress + _StackSize;        //Segment Register Setup in Context     _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_CS] = GDT_KERNEL_CODE_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_DS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_ES] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_FS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_GS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_SS] = GDT_KERNEL_DATA_SEGMENT;        //Next run instruction setup    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RIP] = _EntryPointAddress;    // 0 NT  IOPL  OF DF IF TF SF ZF 0  AF 0  PF 1  CF    // 0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RFLAG] |= 0x0200;       //Setup TCB Block    _Tcb-&gt;ID            = _ID;    _Tcb-&gt;StackAddress  = _StackAddress;    _Tcb-&gt;StackSize     = _StackSize;    _Tcb-&gt;Flags         = _Flags; }It is just function for the initialize of members. Segment register kernel segment and initialize register’s initial values. And next code of execution assigns in RIP register(PC, Program counter)’s EntryPoint. And ContextSwitch function linked with assembly code. [BITS 64]global ContextSwitchSECTION .text   %macro SAVECONTEXT 0    push rbp    push rax    push rbx    push rcx    push rdx    push rdi    push rsi    push r8    push r9    push r10    push r11    push r12    push r13    push r14    push r15    mov ax, ds    push rax    mov ax, es    push rax    push fs    push gs    mov ax, 0x10    mov ds,ax    mov es,ax    mov gs,ax    mov fs,ax%endmacro%macro LOADCONTEXT 0    pop gs    pop fs    pop rax    mov es, ax    pop rax    mov ds, ax    pop r15    pop r14    pop r13    pop r12    pop r11    pop r10    pop r9    pop r8    pop rsi    pop rdi    pop rdx    pop rcx    pop rbx    pop rax    pop rbp%endmacroContextSwitch:    push rbp    mov rbp, rsp    ;Push RFLAGS in stack    pushfq    ;if _CurrentContext is NULL    cmp rdi,0    je .LoadContext    popfq    push rax    ;For use Context Offset     ;Save SS RSP RFLAGS CS RIP Registers    mov ax, ss    mov qword[rdi + 23 * 8], rax    mov rax, rbp    ;reset value to before, RSP Contextswitch  -(ReturnAddress + RBP)    add rax, 16    mov qword[rdi + 22 * 8], rax    ;Push FLAGS in stack    pushfq    pop rax    mov qword[rdi + 21 * 8], rax        ;Save Cs Segment    mov ax, cs    mov qword[rdi + 20 * 8], rax    mov rax, qword[rbp + 8]    mov qword[rdi + 19 * 8], rax    pop rax    pop rbp    ;Context-&gt;Registers    add rdi, 19*8    mov rsp, rdi    sub rdi, 19*8    SAVECONTEXT.LoadContext:    mov rsp, rsi    LOADCONTEXT    iretqIf the first parameter Null(0) it is ShellTask. Jump to .LoadContext If working like that, We will context load by the second parameter. If not, it would save context. And then load by the second parameter. So It’s done of context-switching. Huh. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Performance","Task","MultiCore","64bit"],
        "url": "https://devsdk.github.io/development/2017/08/23/BeginTask.html"
      },{
        "title": "Round robin scheduling and Timeslice Context-Switching",
        "excerpt":"I’ve got working hard in Software maestro. So I took this time to time. It’s a little bit late huh. It makes me think a lot. Also, code size is quite a bit large. Anyway, in this time, I developed round robin scheduler for multitasking and Timeslice scheduling using IRQ0 timer interrupt. Below image is a picture of executing. That text is moved separately. (It worked simultaneously)  It wasn’t multilevel. So I made this every task can take 5ms cpu time. From the Wikipedia, scheduling is an OS technique that makes possible to multiprogramming. Simply, I wanna use several tasks simultaneously. Many techniques there like FCFS, JSF, and ETC … But I’ll use the round-robin technique. Priority isn’t considered now. So CPU can take same cputime. Well, If I organize a multilevel queue, I can give priority. It has a lot of considering things. First, The data will be added and deleted frequently. So a Linked-list will be proper data structure instead of an array-based list. So I implemented Linked-list. Yeah I know, Name is suck lol. I named this LList shorter from LinkedList. LList is a general data structure, so it has been implemented in ‘/GDS/’ directory. Following codes is header file of LList. I try to generalize this to insert list header in the node. #ifndef __LINKEDLIST_H__#define __LINKEDLIST_H__#include &lt;Types.h&gt;#pragma pack(push, 1)typedef struct _struct_Single_LinekdListNode{    void* NextNode; //Single Link Linked List    QWORD ID; //Address or Data}   LLIST_NODE_HEADER;/*    example of the element data structure.typedef struct _Example_Data{    LLIST_DATA_HEADER header;        int data1;    char data2;} Example;*/typedef struct _struct_LinkedListDescriptor{    void* FirstNode;     void* LastNode;    QWORD Count; } LLIST;#pragma pack(pop)void InitializeLList(LLIST* _Ld);void Push_Back_LList(LLIST* _Ld, void* _Item);void Push_Front_LList(LLIST* _Ld, void* _Item);void* Remove_LList(LLIST* _Ld, QWORD _ID);void* Remove_Front_LList(const LLIST* _Ld);void* Remove_Back_LList(const LLIST* _Ld);void* FindLList(const LLIST* _Ld, QWORD _ID);#endif /*__LINKEDLIST_H__*/We need to define a HEADER. So I defined LLIST_NODE_HEADER in front of the structure for the data node. Next is /GDS/LinkedList.c #include \"LinkedList.h\"#include &lt;Console/Console.h&gt;void InitializeLList(LLIST* _Ld){    _Ld-&gt;Count = 0;    _Ld-&gt;FirstNode = NULL;    _Ld-&gt;LastNode  = NULL;   }void Push_Back_LList(LLIST* _Ld, void* _Item){       LLIST_NODE_HEADER* header = (LLIST_NODE_HEADER*)_Item;    header-&gt;NextNode = NULL;    if(_Ld-&gt;FirstNode == NULL)    {        _Ld-&gt;FirstNode = _Item;        _Ld-&gt;LastNode  = _Item;        _Ld-&gt;Count     = 1;        return;    }    header = (LLIST_NODE_HEADER*)_Ld-&gt;LastNode;    header-&gt;NextNode = _Item;    _Ld-&gt;LastNode = _Item;    _Ld-&gt;Count++;}void Push_Front_LList(LLIST* _Ld, void* _Item){    LLIST_NODE_HEADER* header = (LLIST_NODE_HEADER*)_Item;    header-&gt;NextNode = _Ld-&gt;FirstNode;    if(_Ld-&gt;FirstNode == NULL)    {        _Ld-&gt;FirstNode  = _Item;        _Ld-&gt;LastNode   = _Item;        _Ld-&gt;Count      = 1;        return;    }    _Ld-&gt;FirstNode = _Item;    _Ld-&gt;Count++;}void* Remove_LList(LLIST* _Ld, QWORD _ID){    LLIST_NODE_HEADER* pre_headaer = (LLIST_NODE_HEADER*)_Ld-&gt;FirstNode;    for(LLIST_NODE_HEADER* iter_header = pre_headaer; iter_header != NULL; iter_header = iter_header-&gt;NextNode)    {        if(iter_header-&gt;ID == _ID)        {            if((iter_header == _Ld-&gt;FirstNode) &amp;&amp; (iter_header == _Ld-&gt;LastNode) )            {                _Ld-&gt;FirstNode = NULL;                _Ld-&gt;LastNode  = NULL;               }            else if(iter_header == _Ld-&gt;FirstNode)            {                _Ld-&gt;FirstNode = iter_header-&gt;NextNode;                            }            else if(iter_header == _Ld-&gt;LastNode)            {                _Ld -&gt;LastNode = pre_headaer;            }             else            {                pre_headaer-&gt;NextNode = iter_header-&gt;NextNode;            }            _Ld-&gt;Count--;            return iter_header;        }        pre_headaer = iter_header;    }        return NULL;}void* Remove_Front_LList(const LLIST* _Ld){    if(_Ld-&gt;Count == 0)        return NULL;    LLIST_NODE_HEADER* header = (LLIST_NODE_HEADER*)_Ld-&gt;FirstNode;    return Remove_LList(_Ld, header-&gt;ID);}void* Remove_Back_LList(const LLIST* _Ld){    if(_Ld-&gt;Count == 0)        return NULL;    LLIST_NODE_HEADER* header    = (LLIST_NODE_HEADER*)_Ld-&gt;LastNode;    return Remove_LList(_Ld, header-&gt;ID);}void* FindLList(const LLIST* _Ld, QWORD _ID){    for(LLIST_NODE_HEADER* iter = (LLIST_NODE_HEADER*) _Ld-&gt;FirstNode; iter!=NULL; iter = iter-&gt;NextNode)    {        if(iter-&gt;ID == _ID)            return iter;    }    return NULL;}Linked list was implemented quite well. But Something problem waited for me. Problem is… 0SOS didn’t have Heap Allocator. That mean, We cannot allocate dynamically. For fixing this problem and managing memory effectively, I’ll use TCB pulling. (First pre-assign specific area and allocating memory from the area like cake slice.) TCB Pool was placed after 8MB area and I organize TaskStackPool on TCB pool. I draw a picture for helping of understanding.  (Powered by OneNote and my finger lol.) Anyway, it has a structure like that. (I’m so lazy to calculate above 8MB area.) After 2MB area to 0x205C19 is 64bit kernel(IA-32e mode) area.  From the book, ID was allocated by the first 32bit area was 0 in memory that was sliced to 32bit and 32bit I don’t wanna use like that. So I change properly. I defined from 0bit to 55bit is the Index of ID and from 56bit to 63bit is status. As Picture is:  Tasking/Task.h. #ifndef __TASK_H__#define __TASK_H__#include &lt;Types.h&gt;#include &lt;GDS/LinkedList.h&gt;//SS, RSP, RFLAGS, CS, RIP.. etc.. Context#define CONTEXT_REGISTER_COUNT     24#define CONTEXT_REGISTER_SIZE       8#define CONTEXT_OFFSET_GS           0#define CONTEXT_OFFSET_FS           1#define CONTEXT_OFFSET_ES           2#define CONTEXT_OFFSET_DS           3#define CONTEXT_OFFSET_R15          4#define CONTEXT_OFFSET_R14          5#define CONTEXT_OFFSET_R13          6#define CONTEXT_OFFSET_R12          7#define CONTEXT_OFFSET_R11          8#define CONTEXT_OFFSET_R10          9#define CONTEXT_OFFSET_R9           10#define CONTEXT_OFFSET_R8           11#define CONTEXT_OFFSET_RSI          12#define CONTEXT_OFFSET_RDI          13#define CONTEXT_OFFSET_RDX          14#define CONTEXT_OFFSET_RCX          15#define CONTEXT_OFFSET_RBX          16#define CONTEXT_OFFSET_RAX          17#define CONTEXT_OFFSET_RBP          18#define CONTEXT_OFFSET_RIP          19#define CONTEXT_OFFSET_CS           20#define CONTEXT_OFFSET_RFLAG        21#define CONTEXT_OFFSET_RSP          22#define CONTEXT_OFFSET_SS           23#define TASK_TCBPOOL_ADDRESS        0x800000#define TASK_TCBPOOL_COUNT          4096#define TASK_STACK_ADRESS           (TASK_TCBPOOL_ADDRESS + sizeof(TCB) * TASK_TCBPOOL_COUNT)#define TASK_STACK_SIZE             8192#define TASK_INVALID_ID             0xFFFFFFFFFFFFFFFF//----- TCB STATUS DEFINITION#define TASK_FREE                   0x0000000000000000#define TASK_ALLOCATED              0x0100000000000000#define TASK_STATE_MASK             0xFF00000000000000#define TASK_INDEX_MASK             0x00FFFFFFFFFFFFFF#pragma pack(push,1)typedef struct __CONTEXT_STRUCT{    //RegisterData    QWORD Registers[CONTEXT_REGISTER_COUNT];} CONTEXT;//Include the Linked List Header.typedef struct __TCB_STRUCT{    LLIST_NODE_HEADER   list_header;    QWORD               Flags;    CONTEXT             Context;    void*               StackAddress;    QWORD               StackSize;} TCB;  //Management TCB Polltypedef struct __TCB_POOL_MANAGER{    TCB* StartAddress;    int MaxCount;    int Count;    int AllocatedCount;}TCB_POOL_MANAGER;typedef struct __SchedulerStruct{    TCB* Current_Runing_Task;    int CpuTime;        LLIST task_list;}SCHEDULER;#pragma pack(pop)/// TASK POOL &amp; TASK void InitTask(TCB* _Tcb, QWORD _Flags, QWORD _EntryPointAddress, void* _StackAddress, QWORD _StackSize);void InitializeTCBPool();TCB* AllocateTCB();void FreeTCB(QWORD _ID);TCB* CreateTask(QWORD _Flags, QWORD _EntryPointAddress);//Link Assembly Filevoid ContextSwitch(CONTEXT* _CurrentContext, CONTEXT* _NextContext);#endif /*__TASK_H__*/I defined AllocateTCB, FreeTCB and InitalizeTCB functions and TCB_POOL_MANAGER structure. And Masking for TCB-ID. C-Code is: #include \"Task.h\"#include &lt;Utility/Memory.h&gt;#include &lt;Descriptor/GDT.h&gt;#include &lt;Console/Console.h&gt;static TCB_POOL_MANAGER g_TcbPoolManager;void InitTask(TCB* _Tcb, QWORD _Flags, QWORD _EntryPointAddress, void* _StackAddress, QWORD _StackSize){    _MemSet(_Tcb-&gt;Context.Registers, 0, sizeof(_Tcb-&gt;Context.Registers));        // It add stack size because RSP, RBP in initialize is Task's stackpointer.    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RSP] = (QWORD)_StackAddress + _StackSize;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RBP] = (QWORD)_StackAddress + _StackSize;        //Segment Register Setup in Context     _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_CS] = GDT_KERNEL_CODE_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_DS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_ES] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_FS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_GS] = GDT_KERNEL_DATA_SEGMENT;    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_SS] = GDT_KERNEL_DATA_SEGMENT;        //Next run instruction setup    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RIP] = _EntryPointAddress;    // 0 NT  IOPL  OF DF IF TF SF ZF 0  AF 0  PF 1  CF    // 0  0  0  0  0  0  1  0  0  0  0  0  0  0  0  0    _Tcb-&gt;Context.Registers[CONTEXT_OFFSET_RFLAG] |= 0x0200;       //Setup TCB Block    _Tcb-&gt;StackAddress  = _StackAddress;    _Tcb-&gt;StackSize     = _StackSize;    _Tcb-&gt;Flags         = _Flags; } void InitializeTCBPool() {     //Initialize Task Pool started from 8MB area and Manager.     _MemSet(&amp;(g_TcbPoolManager), 0, sizeof(g_TcbPoolManager));    g_TcbPoolManager.StartAddress = (TCB*)TASK_TCBPOOL_ADDRESS;    _MemSet(TASK_TCBPOOL_ADDRESS,0,sizeof(TCB) * TASK_TCBPOOL_COUNT);    for(int i = 0; i &lt; TASK_TCBPOOL_COUNT; i++)        g_TcbPoolManager.StartAddress[i].list_header.ID = i;    g_TcbPoolManager.MaxCount = TASK_TCBPOOL_COUNT;    g_TcbPoolManager.AllocatedCount = 1;} //       STATE //63 ------------ 55 -------0 // 0 0 0 0 0 0 0 0 | address| TCB* AllocateTCB() {    TCB* EmptyTCB;    //If TCBPool fill, return NULL.    if(g_TcbPoolManager.Count == g_TcbPoolManager.MaxCount)        return NULL;    //Linear searching in TCBPool at Free status.    for(int i = 0; i &lt; g_TcbPoolManager.MaxCount; i++)    {        if((g_TcbPoolManager.StartAddress[i].list_header.ID &amp; TASK_STATE_MASK) == TASK_FREE )        {            EmptyTCB = &amp;(g_TcbPoolManager.StartAddress[i]);            break;        }    }    //Changing status TASK_ALLOCATED to ALLOCATED using or operation and generate ID value using Allocate count.    QWORD id = (QWORD) (g_TcbPoolManager.AllocatedCount);    EmptyTCB-&gt;list_header.ID = (( id | TASK_ALLOCATED));    g_TcbPoolManager.Count++;    g_TcbPoolManager.AllocatedCount++;        if(g_TcbPoolManager.AllocatedCount ==0)        g_TcbPoolManager.AllocatedCount = 1;        return EmptyTCB;}void FreeTCB(QWORD _ID){    //Extracy Index area from _ID    QWORD index = _ID &amp; TASK_INDEX_MASK;    //Initialize TCB Context    _MemSet(&amp;(g_TcbPoolManager.StartAddress[index].Context), 0, sizeof(CONTEXT));    //Free    g_TcbPoolManager.StartAddress[index].list_header.ID = index;    g_TcbPoolManager.Count--;}TCB* CreateTask(QWORD _Flags, QWORD _EntryPointAddress){    TCB* task = AllocateTCB();    if(task == NULL)        return NULL;    //Get stack address. TCBPool end address + STCKSIZE * INDEX.    void* StackAddress = (void*)(TASK_STACK_ADRESS +         (TASK_STACK_SIZE * (task-&gt;list_header.ID &amp; TASK_INDEX_MASK)));        InitTask(task,  _Flags, _EntryPointAddress, StackAddress, TASK_STACK_SIZE);        //Register scheduler    AddTaskToScheduler(task);    return task;} Finally, We are going to write the scheduler code. #ifndef __SCHEDULER_H__#define __SCHEDULER_H__#include &lt;Types.h&gt;#include &lt;Tasking/Task.h&gt;//Default CPU Time#define TASK_TIME                   5void InitializeScheduler();void SetCurrentRunningTask(TCB* _Tcb);TCB* GetCurrentRunningTask();TCB* GetNextTask();void AddTaskToScheduler(TCB* _Tcb);void Schedule();BOOL ScheduleInInterrupt();void DecreaseProcessorTime();BOOL IsProcessorTimeExpired();#endif /*__SCHEDULER_H__*/Header file. That contain functions for scheduling and initialize and maximum cpu usage time for Round Robin Scheduling. ContextSwitching technique is quite different between Calling Schedule function and Calling IRQ0 Timerinterupt. When we use the Schedule function, we can just do ContextSwitch. But When we interrupt, We need to designate context with changing the context in IST I cannot draw this (With my horrible draw technique) Shortly, It will be switched automatically because the IST area for using interrupt would be saved context. Let’s see the source code. #include \"Scheduler.h\"#include &lt;Tasking/Task.h&gt;#include &lt;Interrupt/Interrupt.h&gt;#include &lt;Descriptor/IDT.h&gt;#include &lt;Utility/Memory.h&gt;#include &lt;Console/Console.h&gt;static SCHEDULER g_Scheduler;//Initialize TCBPool and TaskList.void InitializeScheduler(){    InitializeTCBPool();    InitializeLList(&amp;(g_Scheduler.task_list));    //Designate Shell Task to Task    g_Scheduler.Current_Runing_Task = AllocateTCB();}void SetCurrentRunningTask(TCB* _Tcb){    g_Scheduler.Current_Runing_Task = _Tcb;}TCB* GetCurrentRunningTask(){    return g_Scheduler.Current_Runing_Task;}TCB* GetNextTask(){    if(g_Scheduler.task_list.Count == 0)        return NULL;    return (TCB*) Remove_Front_LList(&amp;g_Scheduler.task_list);}void AddTaskToScheduler(TCB* _Tcb){    Push_Back_LList( &amp;(g_Scheduler.task_list), _Tcb);}   void Schedule(){    //If scheduling list is empty, exit this function.    if(g_Scheduler.task_list.Count == 0)        return;    //Disable Inerrupt.    BOOL interrupt_status = SetInterruptFlag(FALSE);    TCB* task = GetNextTask();     //If next task is NULL,    if(task == NULL)    {        //return after restore interrupt        SetInterruptFlag(interrupt_status);        return;    }    //Register current task in scheduling list.    TCB* pre_task = g_Scheduler.Current_Runing_Task;    AddTaskToScheduler(pre_task);           //Changing running task.    g_Scheduler.Current_Runing_Task = task;    //Context Switch    ContextSwitch(&amp;(pre_task-&gt;Context), &amp;(task-&gt;Context));    //Initialize Cputime     g_Scheduler.CpuTime = TASK_TIME;    //Restore Interrupt.    SetInterruptFlag(interrupt_status);}//Calling by interrupt.BOOL ScheduleInInterrupt(){    Get the next task.    TCB* task = GetNextTask();    if(task == NULL)    {        return FALSE;    }    //Context address stored in IST Stack.    void* ContextAddress = IST_POINTER + IST_SIZE - sizeof(CONTEXT);        TCB* running_task = g_Scheduler.Current_Runing_Task;    //Save context.    _MemCpy(&amp;(running_task-&gt;Context), ContextAddress, sizeof(CONTEXT));    g_Scheduler.Current_Runing_Task = task;    AddTaskToScheduler(running_task);    //Switch context and restore    _MemCpy(ContextAddress, &amp;(task-&gt;Context),sizeof(CONTEXT));    g_Scheduler.CpuTime = TASK_TIME;    return TRUE;}void DecreaseProcessorTime(){    if(g_Scheduler.CpuTime &gt; 0)        g_Scheduler.CpuTime--;}BOOL IsProcessorTimeExpired(){    if(g_Scheduler.CpuTime  &lt;= 0)        return TRUE;    return FALSE;   }I think I’ve written enough comment. Now we are ready to schedule. Now we can possible timeslice multitasking with IRQ0 Timer Interrupt. I add a function in Interrupt/InterruptHandler.c void TimerInterruptHandler(int _Vector){    SendPIC_EOI(_Vector - PIC_IRQ_VECTOR);    DecreaseProcessorTime();    if(IsProcessorTimeExpired())    {        ScheduleInInterrupt();        }    }IRQ0 Interrupt in Interrupt/InterruptService.asm ISRTimer:    SAVECONTEXT    mov rdi, 32    call TimerInterruptHandler    LOADCONTEXT    iretqI add the following code in shell file. void TestTask1(){    BYTE data;    int i =  0, ix =0, iy = 0, iMargin;    CHARACTER_MEMORY* video = (CHARACTER_MEMORY*)CONSOLE_VIDEO_MEMORY;    TCB* task = GetCurrentRunningTask();    iMargin = (task-&gt;list_header.ID &amp; TASK_INDEX_MASK) %10;    while(1)    {        switch(i)        {            case 0:                ix++;                if(ix&gt;=(CONSOLE_WIDTH - iMargin))                    i = 1;                break;            case 1:                iy++;                if(iy&gt;=(CONSOLE_WIDTH - iMargin))                    i = 2;                break;                case 2:                ix--;                if(iy&lt;iMargin)                    i = 3;                break;            case 3:                iy--;                if(iy &lt; iMargin)                    i = 0;                break;        }           video[iy * CONSOLE_WIDTH + ix].bCharactor = data;        video[iy * CONSOLE_WIDTH + ix].bAttribute = data &amp; 0x0F;        data++;        Schedule();    }    }void TestTask2(){    int i =0, iOffset;        CHARACTER_MEMORY* video = (CHARACTER_MEMORY *)CONSOLE_VIDEO_MEMORY;    TCB* task = GetCurrentRunningTask();    char data[4] = {'-','\\\\','/','|'};    iOffset = (task-&gt;list_header.ID &amp; TASK_INDEX_MASK ) * 2;    iOffset = CONSOLE_WIDTH * CONSOLE_HEIGHT - (iOffset % (CONSOLE_WIDTH * CONSOLE_HEIGHT));    while(1)    {        video[iOffset].bCharactor = data[i %4];        video[iOffset].bAttribute = (iOffset % 15) + 1;        i++;        Schedule();    }}void Command_CreateTask(const char* _Parameter){    PARAMETERLIST parameter_list;    char type[30];    char count[30];    InitializeParameter(&amp;parameter_list, _Parameter);    GetNextParameter(&amp;parameter_list, type);    GetNextParameter(&amp;parameter_list, count);    long idx = 0;    long cnt = 0;    _atoi(type, &amp;idx,10);    _atoi(count, &amp;cnt,10);    int i = 0;     switch (idx)    {        case 1:            for( i =0; i&lt;cnt; i++)            {                if(CreateTask(0,(QWORD)TestTask1) == NULL)                    break;            }                  _Printf(\"Task 1 %d Created\\n\", i);            break;        case 2:            for( i =0; i&lt;cnt; i++)            {                if(CreateTask(0,(QWORD)TestTask2) == NULL)                    break;            }                  _Printf(\"Task 2 %d Created\\n\", i);            break;    }}We can create the task (one of type 1 or 2) using command createtask. Type 2 makes the pinwheel and type 2 is like movement string line. One of pinwheel is taken by one task. Anyway, It is clearly worked code. Before we worked, It has a lot of problems. One of the problems is  Exception7. Specific is “Device Not Available” code 7 in x86 sytem. From Google, that problem is related to FPU. But my OS doesn’t support FPU so I’m confused. And I found why it makes that. I defined 25 register in Task.h, even we had 24 register. Damm. After fixing that, It makes Exception 14 Page Fault. This problem was made from the Liked List. After fixing that, it worked. Well, I read the memory map and do other things in the debugging process. Finally, It has just miss calling function and linked list problem so I don’t write that. Now, Multitasking has worked! Now This project will be frozen. I think it resumes after Software maestro. IDK. If I try to develop, I’ll write this. ","categories": ["development"],
        "tags": ["0SOS","OS","Operating System","System","Performance","Task","Scheduling","MultiCore","64bit"],
        "url": "https://devsdk.github.io/development/2017/09/19/Scheduler.html"
      },{
        "title": "Dev log of NaverWordBookExtractor",
        "excerpt":"Wow, It’s quite loooong time to write this article in here. As you know 0SOS development was paused. When I finish translating blog posting, Maybe I’ll resume. I felt Naver vocabulary doesn’t have enough function. So I try to use Quizlet that was introduced by my friend. QuizLet A person who used the quizlet know about it. When I try to add words in the quizlet, I need to excel file pair of word-mean raw text. But Naver vocabulary doesn’t have any extract function and if I write my hand, it would use a lot of time. So I decide to develop a word-extract program. I chose python because that is simple and multiplatform. First, Naver didn’t support any API. So I should parse from html. The problem is Program need to sign-in to Naver account to access my vocabulary. At the begin of developing, I thought using selenium, but I considered WebDriver makes this heavy. So selenium wasn’t proper. So We need to make sign-in in steps like the web browser. So Let’s analyze sign-in page  Let’s see what happen when we press the sign-in button using chrome development tools. &lt;form id=\"frmNIDLogin\" name=\"frmNIDLogin\" target=\"_top\" autocomplete=\"off\" action=\"https://nid.naver.com/nidlogin.login\" method=\"post\" onsubmit=\"return confirmSubmit();\"&gt;        &lt;input type=\"hidden\" name=\"enctp\" id=\"enctp\" value=\"1\"&gt;        &lt;input type=\"hidden\" name=\"encpw\" id=\"encpw\" value=\"\"&gt;        &lt;input type=\"hidden\" name=\"encnm\" id=\"encnm\" value=\"\"&gt;        &lt;input type=\"hidden\" name=\"svctype\" id=\"svctype\" value=\"0\"&gt;        &lt;input type=\"hidden\" name=\"svc\" id=\"svc\" value=\"\"&gt;        &lt;!-- Skip etc codes --&gt;        &lt;input type=\"submit\" title=\"로그인\" alt=\"로그인\" tabindex=\"12\" value=\"로그인\" class=\"btn_global\" onclick=\"nclks('log.login',this,event)\"&gt;        &lt;!--  Skip etc codes --&gt;&lt;/form&gt;You can see the confirmSubmit function is called when I press submit button and data will send by these keys like ‘enctp’, ‘encpw’ using the POST method. Let’s read the content of the confirmSubmit function in the js file.  function confirmSubmit() {    var id = $(\"id\");    var pw = $(\"pw\");    var encpw = $(\"encpw\");        //if(id.value == \"\" &amp;&amp; encpw.value == \"\") {    if(id.value == \"\") {        show(\"err_empty_id\");        hide(\"err_empty_pw\");        hide(\"err_common\");        id.focus();        return false;    //} else if(pw.value == \"\" &amp;&amp; encpw.value == \"\") {    } else if(pw.value == \"\") {        hide(\"err_empty_id\");        show(\"err_empty_pw\");        hide(\"err_common\");        pw.focus();        return false;    }    try{        $(\"ls\").value = localStorage.getItem(\"nid_t\");    }catch(e){}    return encryptIdPw();}It is the confirmSubmit function. We can see id and password empty notification warning logic. But that isn’t an important thing. As you can see a function that looks important has existed there. Let’s see this. function encryptIdPw() {    var id = $(\"id\");    var pw = $(\"pw\");    var encpw = $(\"encpw\");    var rsa = new RSAKey;    if (keySplit(session_keys)) {        rsa.setPublic(evalue, nvalue);        try{            encpw.value = rsa.encrypt(                getLenChar(sessionkey) + sessionkey +                getLenChar(id.value) + id.value +                getLenChar(pw.value) + pw.value);        } catch(e) {            return false;        }        $('enctp').value = 1;        id.value = \"\";        pw.value = \"\";        return true;    }    else    {        getKeyByRuntimeInclude();        return false;    }I can find this function makes request sending encrypted RSA data from ID and Password to login url(“https://nid.naver.com/nidlogin.login”) using post ‘encpw’ key. We should know the session_keys, keySplit, and getLenChar functions. Let’s see them. function getLenChar(a) {    a = a + \"\";    return String.fromCharCode(a.length)}that function return length of the parameter string. Let’s see session_keys and keySplit. session_keys return requirement value(e,n) and etc for public-key generation from “https://nid.naver.com/login/ext/keys.nhn”. Let’s get inside of seesion_key’s set step. When the user writes text in pw textbox, getKeysv2 function will be called using ajax so we can take key values. Example (This isn’t proper value. So This key wouldn’t work. I add new-line for reading) gs0TbOWaCaYxTQ0,102042940,ad1ca063118c32asdd51a8c53119faa8bc9c8cb0f743d8f1b89db53cc8f4647784ab08b0f4704e2a49c85cdf44e1830c04ad3505cb977810768a3cwrrq8ce38d2956892722f45aecc6bfc23248e2fe453a4d20b51344968b8ffa848068d72d05e5aa679fbaef4351e099aea00fd6fccfff598426b0d12bdc660e601dd7a93bbd,010001Let’s see keySplit function. function keySplit(a) {    keys = a.split(\",\");    if (!a || !keys[0] || !keys[1] || !keys[2] || !keys[3]) {        return false;    }    sessionkey = keys[0];    keyname = keys[1];    evalue = keys[2];    nvalue = keys[3];    $(\"encnm\").value = keyname;    return true}It’s a simple function. Okay, we have information for implementing this. Simply, It’s make ‘encpw’ key value using ‘ getLenChar(sessionkey) + sessionkey +    getLenChar(id.value) + id.value + getLenChar(pw.value) + pw.value)’ for sending post. So When this string encrypts using RSA with e and n value, it ganna make a something happen. I write the script using python. from bs4 import BeautifulSoup import requestsimport rsafrom rsa import common, transform, coreimport reinfo = { \"id\" : \"\", \"pw\" : \"\" }session = requests.Session()session_key_string = \"\"session_keys = {}def split_keys(a):    keys = a.split(',')    if (a is None or keys[0] is None or keys[1] is None or keys[2] is None or keys[3] is None):        return False    session_keys[\"sessionkey\"] = keys[0]    session_keys[\"keyname\"] = keys[1]    session_keys[\"evalue\"] = keys[2]    session_keys[\"nvalue\"] = keys[3]    return Truedef getLenChar(a):    return chr(len(a))    def encrypt():    id = info['id']    pw = info['pw']    pub_key = rsa.PublicKey(e=int(session_keys[\"nvalue\"],16), n = int(session_keys[\"evalue\"],16))    source  = (getLenChar(session_keys[\"sessionkey\"]) + session_keys[\"sessionkey\"] + getLenChar(info[\"id\"]) + info[\"id\"]            + getLenChar(info[\"pw\"]) + info[\"pw\"])    return rsa.encrypt(source.encode('utf-8'), pub_key)def signin():    session_key_string = requests.get(\"https://nid.naver.com/login/ext/keys.nhn\").text    if(split_keys(session_key_string) is False):        print(\"Error\")        return False    encrypted_source = encrypt()    postdata = {    \"encpw\": encrypted_source.hex(),     \"enctp\": 1,    \"encnm\": session_keys[\"keyname\"],    }    response = session.post(\"https://nid.naver.com/nidlogin.login\", data=postdata)    if response.text.count('\\n') &gt; 50 :        print(\"sigin in error\")        return False            print(response.text)    return True    if signin() is False:    exit(0)I find something weird thing. It is swapped between evalue and nvalue parsing data from session_keys. I don’t know this is a mistake or design. Anyway, I found this problem, because application keep dying on Rsa Encrypt step and I found n and e value swapped. That mean e value is n and n value is e in javascript. Whatever, It worked properly like Naver sign-in step. If info dictionary id and password is correct, &lt;html&gt;&lt;script language=javascript&gt;location.replace(\"https://nid.naver.com/login/sso/finalize.nhn?url=http%3A%2F%2Fwww.naver.com&amp;sid=rbCj4sWaqQfCweR&amp;svctype=1\");&lt;/script&gt;&lt;/html&gt;It will return redirection URL. After three steps of redirect, it’s done. Now the program is signed-in. I wanna more clearly, but it has a captcha and it makes blocks login. But Maybe I use like deep-learning is over-engineering. So I think if it happens, just sign-in on the web browser for passing the captcha. I use ‘beautifulsoup 4’ for parsing. Below url is source code. SourceCode IDK this article is quite readable. Because I didn’t sleep. ","categories": ["development"],
        "tags": ["Naver","Web","Parsing","python"],
        "url": "https://devsdk.github.io/development/2018/02/19/NaverWordBookExtractor.html"
      },{
        "title": "Printing A + B with no limitation.",
        "excerpt":"Today, I’ve started an algorithm study. I’ve learned something didn’t know before. Today’s problem is this: Problem Write a program printing sum of A and B which are inputted.Input Input values consist of multiple test-case. Each test-case is a single line and will be given value A and B (0 &lt; A, B&lt;10)Output Print A + B by each test-case.Example input 1 12 33 49 85 2Example output 257177From here. So, Let’s think about it. When I met this problem, I’m just shocked. Honestly, I have no idea for solving this problem. Because this problem didn’t have information about the limitation of input. So I try to find how can I solve this problem on Google and an answer sheet. And I got Idea. An Eof. This fact makes me a little bit annoying because I can’t find any information about Eof in that judgment site. So this problem’s solution is this. #include &lt;iostream&gt;using namespace std;int main(){    int a, b;    while(cin &gt;&gt; a &gt;&gt; b)    {           cout &lt;&lt; a + b &lt;&lt; endl;    }       return 0;}The answer has a quite funny fact. The » operator that was overridden return istream itself. That makes possible we can write like this. \tcin &gt;&gt; a &gt;&gt; b;Did you find anything weird? operator »  have been used the condition of the while loop. From reference, We can find the return value of overridden bool operation that is selected by an error state of  ios_base::iostate flag. So If the state value of ‘cin’ is eof, we can escape from the while loop. I didn’t know istream’s functions before, so this problem gave me the knowledge and it’s quite happy :D. ","categories": ["algorithm"],
        "tags": ["algorithm","solving problem"],
        "url": "https://devsdk.github.io/algorithm/2019/02/13/algorithm-sum-of-a-and-b.html"
      },{
        "title": "Printing stars with single output function.",
        "excerpt":"Today I’ve solved bit algorithm problems. I’ll write my solution one of those problems. So Let’s begin. Problem Print the \"*\" by inferring example's rule.Input Value N(1 ≤ N ≤ 100)  will be given.Output Print from the first line to N line.Example Input 1 1Example  Output 1  *Example Input 2 2Example Output 2  ** *Example Input 3 3Example Output 3   * * ** * *Example Input 4 4Example Output 4    *  * * * * ** * * *From here Let’s think about it! It’s can be solved easily if I use many conditional expression and output expression. But I think It can be solved just a single output function(except newline) with loops and the ternary operator. So Let’s find the rule of this problem. For finding the rule, I’ve drawn a table.  We can find some rule of this. First, We can get the count of ‘i’ raw.Second, If the N is even value, We can print ‘’ when the sum of ‘i’ and ‘j’ value is an odd value. If not, We can print ‘’ when the sum of ‘i’ and ‘j’ is even value. The first rule can be used for a single output function(except newline). But the second rule makes the condition.  So We need to remove the condition.  I take ‘i’+’j’-‘N’. So, ‘*’ can be printed when that value is odd. And, Third, We can print ‘ ‘ when that value is less than 1. So Let’s write this to code. #include &lt;iostream&gt;using namespace std;int main(){    int N=0;    cin&gt;&gt;N;    for(int i=1; i&lt;=N; i++)    {           for(int j=1; j&lt;=(N+i-1); j++)            cout&lt;&lt; ((((i+j-N) &gt; 0)&amp;&amp;(i+j-N) % 2 != 0)? \"*\" : \" \");        cout&lt;&lt;endl;    }       return 0;}So this problem can be solved like this single output function(except newline). ","categories": ["algorithm"],
        "tags": ["algorithm","solving problem"],
        "url": "https://devsdk.github.io/algorithm/2019/02/14/printing-stars.html"
      },{
        "title": "\\[DP\\] I have solved My first DP problem.",
        "excerpt":"Now, I solved a DP problem. Dynamic programming is one of the problem-solving methods.this method divides a problem to sub-problems. It stores a result of the algorithm by specific values to the memory for reusing. So When that value occurs, We can use that data again. Thus we can optimize re-computing time. Problem Following source code is C++ function for calculating N Fibonacci number. int fibonacci(int n) {    if (n == 0) {        printf(\"0\");        return 0;    } else if (n == 1) {        printf(\"1\");        return 1;    } else {        return fibonacci(n‐1) + fibonacci(n‐2);    }}When fibonacci(3) is called, it would be worked like this:   fibonacci(3)  call fibonacci(2) and fibonacci(1)(first called).  fibonacci(2) call fibonacci(1)(second called) and fibonacci(0).  fibonacci(1)(second called) return and print 1.  fibonacci(0) return and print 0.  fibonacci(2) get result of fibonacci(1) and fibonacci(0) and return 1.  fibonacci(1)(fist called) return and print 1.  fibonacci(3) get result of fibonacci(2) and fibonacci(1) and return 2.Thus, number 1 printed the twice and 0 printed a single. Write a program to calculate how many number 0 and 1 printed when number N is given. Time limit: 0.25 Second Input The value T will be given that is the count of test-case.Each case consists of a single line which is number N.(0&lt;=N&lt;=40) Output Print the numbers of the count of 0 and 1 which is separated by the white-space. Example Input 3013Example  Output 1 00 11 2From here When I met this problem the first time, I just used counting 0 and 1. But my counting method always made the time-over. I had some few times for thinking. The main topic is calculation time. And the following idea occurred to me. If I store the value of fibonacci(N) to reuse? If I do that, This algorithm makes calculation just a single time by the N value. So I fixed above function like this. int DP[41] = {0};int fibonacci(int n) {    if (n == 0) {        return 0;    } else if (n == 1) {        return 1;    } else {        if(DP[n]!=0)            return DP[n];        else        {            int res = fibonacci(n-1) + fibonacci(n-2);            DP[n] = res;            return res;        }    }   }If fibonacci(2) called the first time, it would call fibonacci(1) and fibonacci(0) functions which just return 1 and 0. And then it stored the result of fibbonacci(2) to DP[2]. Thus, when fibonacci function called next time, it would return the value of DP[2]. So It’s solved! But let’s see the problem. We need to count how many 0 and 1 is printed. But we can’t count use counter because every function by N is called a single time. Let’s think. We need to find how many N value consists of 1 and 0 makes function-call. Let’s think when fibonacci(2) is called. fibonacci(2) makes fibonacci(1) and fibonacci(0). As you can see that makes counting each 1 and 0 by specific value N=2. Thus, We can make this formula: zero_count = { 1, 0, 0 …}zero_count[N] = zero_count[N-1] + zero_count[N-2] one_count { 0, 1, 0 …}one_count[N] = one_count[N-1] + one_count[N-2] So If I use above to source code, we can solve finally. #include &lt;iostream&gt;using namespace std;int DP[41] = {0};int DPC[41] = {0,1,0,};int DPZC[41] = {1,0,};int fibonacci(int n) {    if (n == 0) {        return 0;    } else if (n == 1) {        return 1;    } else {        if(DP[n]!=0)            return DP[n];        else        {            int res = fibonacci(n-1) + fibonacci(n-2);                DPC[n] = DPC[n-1] + DPC[n-2];               DPZC[n] = DPZC[n-1] + DPZC[n-2];            DP[n] = res;            return res;        }    }   }int main(){    int T,N;    cin.sync_with_stdio(false);    cout.sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin&gt;&gt;T;    for(int i=0;i&lt;T;i++)    {           cin&gt;&gt;N;        fibonacci(N);        cout&lt;&lt;DPZC[N]&lt;&lt;\" \"&lt;&lt;DPC[N]&lt;&lt;'\\n';    }       return 0;}I heard DP method but I couldn’t use that. And luckily I can deploy that method through this problem! ","categories": ["algorithm"],
        "tags": ["algorithm","solving problem"],
        "url": "https://devsdk.github.io/algorithm/2019/02/20/first-dp-problem.html"
      },{
        "title": "\\[DP\\] The RGB Street",
        "excerpt":"I’ve solved another DP problem! Problem Peoples who live in RGB street want to paint one of three color red, green, and blue to the house. Also, they make a rule Does not paint the same color between the adjoining house. The adjoining house is i + 1 and i - 1 of the house i. The price of painting  RED color and Green color and BLUE color will be given, then find the minimum price of painting all of the houses. Time limit: 0.5 Second Input The first line, N value will be given. N is less or equal to 1000. And the painting price of red, green, and blue color will be given after the first line. Output Print the minimum price of painting color. Example Input 326 40 8349 60 5713 89 99Example  Output 96From here When I read this problem the first time, I didn’t know how do I solve using DP this problem. Even I have no idea how do I solve this using full-search. The very first time, I just think I can use DP with an array which is 6 sized and contain the value of case select Red, Green, and Blue and before selected color. And I try to solve with iterate statement. But that solution makes the wrong output. So I try to come back to the full-search method with a recursive function. Let’s think about it. It always makes two selection number of the case except for the first line. Because We have adjoining houses painting rule. So We need to calculate like this:  The blue dotted line is the solution path (It is just one of the path to calculate the price). We can make this to function at reverse order for define recursive function. Let’s define the function returns min value of price at N and color. And we can find the price is always the same at N and color. That is DP. we can use DP. So when function at N and color is already calculated, we can return the calculated value. Let’s write the ‘select’ function which selects the minimum value of two cases. int select(int n, int i){    if(dp[n][i] != 0)        return dp[n][i];        if(n==0)    {        return input[0][i];    }    int res = min(input[n][i] + select(n-1, (i+1)%3), input[n][i] + select(n-1,(i+2)%3));    dp[n][i]=res;    return res;}i is color, n is house number. Let’s call this function case 0, 1, and 2. So The final source code is: #include &lt;iostream&gt;using namespace std;int input[1000][3];int dp[1000][3];int select(int n, int i){    if(dp[n][i] != 0)        return dp[n][i];        if(n==0)    {        return input[0][i];    }    int res = min(input[n][i] + select(n-1, (i+1)%3), input[n][i] + select(n-1,(i+2)%3));    dp[n][i]=res;    return res;}int select_all(int n){    return min(select(n,0), min(select(n,1),select(n,2)));}int main(){    int N;    cin&gt;&gt;N;    for(int i=0;i&lt;N;i++)    {        cin&gt;&gt;input[i][0];        cin&gt;&gt;input[i][1];        cin&gt;&gt;input[i][2];    }    cout&lt;&lt;select_all(N-1)&lt;&lt;endl;            return 0;}Sorry for the unreadable article. Because I’m burned and hungry! ","categories": ["algorithm"],
        "tags": ["algorithm","solving problem"],
        "url": "https://devsdk.github.io/algorithm/2019/03/02/The-RGB-street.html"
      },{
        "title": "\\[Recursive Function\\] Print '*' character-11",
        "excerpt":"I’ve solved the recursive function problem. Problem Find the rule from the following example output, write the code for working it. Input Number N will be given representing the number of lines. N is always  \\(3×2^k\\). (3, 6, 12, 24, (k &lt;=10) Output Print ‘*’ character the first to last line. Example Input 24Example  Output                        *                                              * *                                            *****                                          *     *                                        * *   * *                                      ***** *****                                    *           *                                  * *         * *                                *****       *****                              *     *     *     *                            * *   * *   * *   * *                          ***** ***** ***** *****                        *                       *                      * *                     * *                    *****                   *****                  *     *                 *     *                * *   * *               * *   * *              ***** *****             ***** *****            *           *           *           *          * *         * *         * *         * *        *****       *****       *****       *****      *     *     *     *     *     *     *     *    * *   * *   * *   * *   * *   * *   * *   * *  ***** ***** ***** ***** ***** ***** ***** *****From here It looks quite different usually called print ‘*’ problems, isn’t it? I just thought It is definitely the recursive function problem. But the problem is finding the rule for using recursively and the output system. Before I tried to solve this problem, I made the triangle output system. From C++ standard, We didn’t have any terminal or console cursor move function. I could figure out using the array but it’ll make a lot of empty space. So I come up with using ‘map’. Key is the number of lines and the value is the list of ‘*’ position. Simply, the key is Y position value is the list of X position. So I implemented add-point function at the X, Y coordinate and print triangle at the X, Y position using the add-point function. Triangle’s drawing position is the left-top. Like this:  So the code about above is: map&lt;int, vector&lt;int&gt;*&gt; printlist;int emptyCount = 0;void addPrint(int x, int y){    if(printlist.find(y) == printlist.end())    {        printlist[y] = new vector&lt;int&gt;();    }    if(find(printlist[y]-&gt;begin(), printlist[y]-&gt;end(), x) == printlist[y]-&gt;end())            printlist[y]-&gt;push_back(x);}void printAll(){    for(int i=0;i&lt;printlist.size(); i++)    {            vector&lt;int&gt;* vec = printlist[i];        if(vec==nullptr)        {            cout&lt;&lt;endl;            continue;        }        sort(vec-&gt;begin(),vec-&gt;end());        int dif=vec-&gt;at(0);        int before = -1;        for(int j=0;j&lt;vec-&gt;size();j++)        {            dif = vec-&gt;at(j) - before-1;            for(int k=0;k&lt;dif;k++)            {                cout&lt;&lt;\" \";                    }            cout&lt;&lt;\"*\";            before = vec-&gt;at(j);        }                for(int p=before;p&lt;emptyCount-2;p++)            cout&lt;&lt;\" \";                    cout&lt;&lt;endl;    }}void printTriangle(int x, int y){        addPrint(x+2,y+0);    addPrint(x+1,y+1);    addPrint(x+3,y+1);    addPrint(x+0,y+2);    addPrint(x+1,y+2);    addPrint(x+2,y+2);    addPrint(x+3,y+2);    addPrint(x+4,y+2);}‘emptyCount’ variable is used for print empty space after the final output and its value is N * 2 - 2. ‘dif’ variable is used for print empty space between previously printed ‘*’ and currently print position. And the function printTriangle(0,0) is implemented experientially. So When I call the function printTriangle(0,0) then it’ll be print like this:   *   * * *****So Let’s come back to the problem. It is a recursive problem. The drawing position of the triangle is left-top. And we can find the rule when N is 6. The top triangle’s coordinate is (3, 0). It is figured out (0+N/2, 0). And Left-Bottom triangle’s coordinate is (0,3). And it’s came up with (0, N/2). the  Right-Bottom triangle’s coordinate is (6,3). and it’s figured out (0+N, N/2). This rule can be used when N is bigger. That means we can write ‘the recursive function. I drew above rules:  Let’s write the recursive function! void recursive(int x,int y,int p){    if(p==6)    {        printTriangle(0+x,3+y);        printTriangle(6+x,3+y);        printTriangle(3+x,0+y);    }    else    {        recursive(x+p/2,y, p/2);        recursive(x,y+p/2, p/2);        recursive(x+p,y+p/2, p/2);    }}and… it’s solved!!! Following codes is full source code for this problem! #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;map&lt;int, vector&lt;int&gt;*&gt; printlist;int emptyCount = 0;void addPrint(int x, int y){    if(printlist.find(y) == printlist.end())    {        printlist[y] = new vector&lt;int&gt;();    }    if(find(printlist[y]-&gt;begin(), printlist[y]-&gt;end(), x) == printlist[y]-&gt;end())            printlist[y]-&gt;push_back(x);}void printAll(){    for(int i=0;i&lt;printlist.size(); i++)    {            vector&lt;int&gt;* vec = printlist[i];        if(vec==nullptr)        {            cout&lt;&lt;endl;            continue;        }        sort(vec-&gt;begin(),vec-&gt;end());        int dif=vec-&gt;at(0);        int before = -1;        for(int j=0;j&lt;vec-&gt;size();j++)        {            dif = vec-&gt;at(j) - before-1;            for(int k=0;k&lt;dif;k++)            {                cout&lt;&lt;\" \";                    }            cout&lt;&lt;\"*\";            before = vec-&gt;at(j);        }                for(int p=before;p&lt;emptyCount-2;p++)            cout&lt;&lt;\" \";                    cout&lt;&lt;endl;    }}void printTriangle(int x, int y){        addPrint(x+2,y+0);    addPrint(x+1,y+1);    addPrint(x+3,y+1);    addPrint(x+0,y+2);    addPrint(x+1,y+2);    addPrint(x+2,y+2);    addPrint(x+3,y+2);    addPrint(x+4,y+2);}void recursive(int x,int y,int p){    if(p==6)    {        printTriangle(0+x,3+y);        printTriangle(6+x,3+y);        printTriangle(3+x,0+y);    }    else    {        recursive(x+p/2,y, p/2);        recursive(x,y+p/2, p/2);        recursive(x+p,y+p/2, p/2);    }}void freeAll(){    for(map&lt;int,vector&lt;int&gt;*&gt;::iterator i = printlist.begin();i!=printlist.end(); i++)    {        delete i-&gt;second;    }}int main(){    int input=0;    cin&gt;&gt;input;    emptyCount = input*2;    if(input==3)        printTriangle(0,0);    else        recursive(0,0,input);    printAll();    freeAll();    return 0;}I think I’m very enjoying this problem! ","categories": ["algorithm"],
        "tags": ["algorithm","solving problem"],
        "url": "https://devsdk.github.io/algorithm/2019/03/16/PrintStars11.html"
      },{
        "title": "\\[1196\\] Codeforces Round \\#575 (Div. 3)",
        "excerpt":"This article’s purpose is studying the unsolved problems in last contest for my P.S skill.It is made personally in the Notion and exported. Editorial is here. Below solutions are review of non-solved problem in the contest. I read the problems A,B,C,D1,D2. But I’ve solved A,B,D1. C - Robot Breakout This problem’s main point is not simulation. I’ve thought it is DP and simulation(or BFS) but the solution is simple than I thought. First, Define the area by the min point(x,y) and max point(x,y). (max x and y = 10^5, min x and y = -10^5) And Move that points max and min by the robot’s available functions. For example, If the robot cannot move to right (That mean, the robot can move to up and down and left) The x of the max point have to find min right moving unavailable robot’s x coordinate. Because, That robot cannot move to right. That mean is if the robots in right site of min(max points) robot cannot move left direction, it could be not match between both robots. Let’s look at the code.     #include &lt;iostream&gt;        using namespace std;        int main()    {    \tint q;    \tcin&gt;&gt;q;    \twhile(q--)    \t{    \t\tint n;    \t\tcin&gt;&gt;n;    \t\tint minx = -100000, miny=-100000;    \t\tint maxx = 100000, maxy = 100000;        \t\tint X,Y,f1,f2,f3,f4;    \t\tfor(int i=0;i&lt;n;i++)    \t\t{    \t\t\tcin&gt;&gt;X&gt;&gt;Y&gt;&gt;f1&gt;&gt;f2&gt;&gt;f3&gt;&gt;f4;    \t\t\tif(!f1)    \t\t\t\tminx = max(minx, X);    \t\t\tif(!f2)    \t\t\t\tmaxy = min(maxy, Y);    \t\t\tif(!f3)     \t\t\t\tmaxx = min(maxx, X);    \t\t\tif(!f4)    \t\t\t\tminy = max(miny, Y);    \t\t}    \t\t\tif(minx&lt;=maxx &amp;&amp; miny&lt;=maxy)    \t\t\t\tcout&lt;&lt;\"1 \"&lt;&lt;minx&lt;&lt;\" \"&lt;&lt;miny&lt;&lt;endl;    \t\t\telse    \t\t\t\tcout&lt;&lt;\"0\"&lt;&lt;endl;\t\t    \t}            \treturn 0;    } The “if statement” of the last output code’s the condition check the all of the robot can move to same points. D2. RGB Substring (hard version) I’ve solved the easy version by full-search. Because the input size is n &lt; 2000. But this problem has a large input. So, I have to think more. I thought it is Definitely DP problem. And It is (But the other technique more important to solve it) This problem can solve easily using Sliding Window(Two points) my easy version’s code has O(n^2) and the below solution has \\($O(n)\\)$.     #include &lt;iostream&gt;        using namespace std;        int main()    {    \tint q;    \tcin&gt;&gt;q;    \twhile(q--)    \t{    \t\tint x,y;    \t\tcin&gt;&gt;x&gt;&gt;y;    \t\tstring s;    \t\tcin&gt;&gt;s;    \t\tint arr[3] = {1, 2, 3};    \t\t    \t\t\t    \t\tint minv = 0x0FFFFFFF;        \t\tfor(int i=0;i&lt;3;i++)    \t\t{            \t\t\tint minp=0, maxp=y-1;    \t\t\t    \t\t\tint curv = 0;\t    \t\t\t    \t\t\tfor(int j=0;j&lt;y;j++)    \t\t\t{    \t\t\t\tif(s[j] == 'R' &amp;&amp; arr[(i+j)%3] != 1)    \t\t\t\t\tcurv++;    \t\t\t\tif(s[j] == 'G' &amp;&amp; arr[(i+j)%3] != 2)    \t\t\t\t\tcurv++;    \t\t\t\tif(s[j] == 'B' &amp;&amp; arr[(i+j)%3] != 3)    \t\t\t\t\tcurv++;    \t\t\t}    \t\t\twhile(1)    \t\t\t{        //\t\t\t\tcout&lt;&lt;\"SLIDE MI = \"&lt;&lt;minp&lt;&lt; \" MA = \"&lt;&lt;maxp&lt;&lt;\" curv = \"&lt;&lt;curv&lt;&lt;endl;    \t\t\t\t    \t\t\t\tminv=min(minv,curv);    \t\t\t\tif(s[minp] == 'R' &amp;&amp; arr[(minp + i)%3] != 1)    \t\t\t\t\tcurv--;\t    \t\t\t\tif(s[minp] == 'G' &amp;&amp; arr[(minp + i)%3] != 2)    \t\t\t\t\tcurv--;\t    \t\t\t\tif(s[minp] == 'B' &amp;&amp; arr[(minp + i)%3] != 3)    \t\t\t\t\tcurv--;    \t\t\t\tminp++;    \t\t\t\tmaxp++;    \t\t\t\tif(s[maxp] == 'R' &amp;&amp; arr[(maxp + i)%3] != 1)    \t\t\t\t\tcurv++;    \t\t\t\tif(s[maxp] == 'G' &amp;&amp; arr[(maxp + i)%3] != 2)    \t\t\t\t\tcurv++;    \t\t\t\tif(s[maxp] == 'B' &amp;&amp; arr[(maxp + i)%3] != 3)    \t\t\t\t\tcurv++;        \t\t\t\tif(maxp &gt;= x)    \t\t\t\t\tbreak;\t    \t\t\t}\t    \t\t}    \t\tcout&lt;&lt;minv&lt;&lt;endl;    \t}    \treturn 0;    }","categories": ["algorithm"],
        "tags": ["algorithm","solving problem","codeforce"],
        "url": "https://devsdk.github.io/algorithm/2019/08/05/codeforce-1196.html"
      },{
        "title": "Implement the \\<select> should be affected by custom scrollbar tags",
        "excerpt":"Issue: http://crbug.com/1076508 Patches:   https://chromium-review.googlesource.com/c/chromium/src/+/2364316  https://chromium-review.googlesource.com/c/chromium/src/+/2418527  https://chromium-review.googlesource.com/c/chromium/src/+/2586293The Implemented feature that I implemented 3 months ago is now working on Google Chrome live version. It’s a gratified thing and sometimes I felt it’s unreal. My achievement could be used for people all around the world. How awesome.  This gif image indicates after updated chrome working my code. Previously, the same codes working like this:  According to this document, Chromium and WebKit based browsers support the custom scrollbar via ::-webkit-scrollbar in CSS pseudo element. The first gif image’s CSS code: ::-webkit-scrollbar {    width: 10px;\t\theight:10px;  }  ::-webkit-scrollbar-track {    background: orange;  }  ::-webkit-scrollbar-corner {    background: yellow;  }  ::-webkit-scrollbar-thumb {    background: gray;  }  ::-webkit-scrollbar-thumb:hover {    background: green;  }In the previous version, other places (not &lt;select&gt;, i.e. Page’s scrollbar ) are ideally rendered as we expected like:  However, Before the change, we could see unexpected results for &lt;select&gt; on the second gif image. Before understanding, we should know about how &lt;select&gt; work on chromium.When we clicked the &lt;select&gt;, The browser (chromium) opened a new web popup(Simply, new web renderer). We called ‘Internal Popup”.In other words, The html codes and some internal styles from the host are copied to a new webview ‘Internal Popup’ and rendering via web-engine blink, when we clicked &lt;select&gt;. If you want to see detailed implementation, Source codes are here. Before the CL, the simple element styles are implemented (i.e. background color for options). But The function of Pseudo class style like ‘:-webkit-scrollbar’ is not implemented and also not considered. This patch mainly implements the serializer from ComputedStyle to CSS string and applies to internal popup. The test codes are dozen. “Added” tags indicates added test codes.  First patch  Second (:hover) patch Many tests are added. Because It’s a special test case that opened a new Internal Popup, We should use a pixel test that compares pixel by pixel difference between pre-rendered image and actually rendered pixels. This case could bring platforms difference. So one of the tasks on this patch is to reduce platform difference. I didn’t write a detailed devlog. So, I’ve written completed codes and explain not kind of inspection or debugging parts. Below is the code-level implementation section. Declare few functions for serialization. //Serialize function from Computed to String CSS property via property-id.const String SerializeComputedStyleForProperty(const ComputedStyle&amp; style,                                               CSSPropertyID id) {  const CSSProperty&amp; property = CSSProperty::Get(id);  const CSSValue* value =      property.CSSValueFromComputedStyle(style, nullptr, false);  return String::Format(\"%s : %s;\\n\", property.GetPropertyName(),                        value-&gt;CssText().Utf8().c_str());}//Function that builds CSS element (i.e. target\\n{ ~some css~ } \\n)void InternalPopupMenu::AppendOwnerElementPseudoStyles(    const String&amp; target,    SharedBuffer* data,    const ComputedStyle&amp; style) {  PagePopupClient::AddString(target + \"{ \\n\", data);  const CSSPropertyID serialize_targets[] = {      CSSPropertyID::kDisplay,    CSSPropertyID::kBackgroundColor,      CSSPropertyID::kWidth,      CSSPropertyID::kBorderBottom,      CSSPropertyID::kBorderLeft, CSSPropertyID::kBorderRight,      CSSPropertyID::kBorderTop,  CSSPropertyID::kBorderRadius,      CSSPropertyID::kBoxShadow};  for (CSSPropertyID id : serialize_targets) {    PagePopupClient::AddString(SerializeComputedStyleForProperty(style, id),                               data);  }  PagePopupClient::AddString(\"}\\n\", data);}These functions use to serialize ComputedStyle to CSS style string and then apply to Internal Popup. With this, it has worked properly until without  ‘:hover’.Pseudo style like ‘:hover’ is rather complicated. When I read codes to implement ‘:hover’, I have a question “how to work in the renderer when ‘:hover’?” And I could figure out ‘:hover’ ComputedStyle could be serialized on hover status for the element. And the below codes is the answer after inspection: scoped_refptr&lt;const ComputedStyle&gt; StyleForHoveredScrollbarPart(    HTMLSelectElement&amp; element,    const ComputedStyle* style,    Scrollbar* scrollbar,    PseudoId target_id) {  ScrollbarPart part = ScrollbarPartFromPseudoId(target_id);  if (part == kNoPart)    return nullptr;  scrollbar-&gt;SetHoveredPart(part);  scoped_refptr&lt;const ComputedStyle&gt; part_style = element.StyleForPseudoElement(      PseudoElementStyleRequest(target_id, To&lt;CustomScrollbar&gt;(scrollbar),                                part),      style);  return part_style;}Finally, The code for each scrollbar styles is: LayoutObject* owner_layout = owner_element.GetLayoutObject();  std::pair&lt;PseudoId, const String&gt; targets[] = {      {kPseudoIdScrollbar, \"select::-webkit-scrollbar\"},      {kPseudoIdScrollbarThumb, \"select::-webkit-scrollbar-thumb\"},      {kPseudoIdScrollbarTrack, \"select::-webkit-scrollbar-track\"},      {kPseudoIdScrollbarTrackPiece, \"select::-webkit-scrollbar-track-piece\"},      {kPseudoIdScrollbarCorner, \"select::-webkit-scrollbar-corner\"}};  Scrollbar* temp_scrollbar = nullptr;  const LayoutBox* box = owner_element.InnerElement().GetLayoutBox();  if (box &amp;&amp; box-&gt;GetScrollableArea()) {    if (ScrollableArea* scrollable = box-&gt;GetScrollableArea()) {      temp_scrollbar = MakeGarbageCollected&lt;CustomScrollbar&gt;(          scrollable, kVerticalScrollbar, &amp;owner_element.InnerElement());    }  }  for (auto target : targets) {    if (const ComputedStyle* style =            owner_layout-&gt;GetCachedPseudoElementStyle(target.first)) {      AppendOwnerElementPseudoStyles(target.second, data, *style);    }    // For Pseudo-class styles, Style should be calculated via that status.    if (temp_scrollbar) {      scoped_refptr&lt;const ComputedStyle&gt; part_style =          StyleForHoveredScrollbarPart(owner_element,                                       owner_element.GetComputedStyle(),                                       temp_scrollbar, target.first);      if (part_style) {        AppendOwnerElementPseudoStyles(target.second + \":hover\", data,                                       *part_style);      }    }  }Internal Popup’s style filled out from above serialization functions. ","categories": ["Chromium"],
        "tags": ["Chromium","C++","Web Engine","HTML/CSS"],
        "url": "https://devsdk.github.io/chromium/2020/12/13/ChromiumCustomscrollbarForSelect.html"
      },{
        "title": "Allow Infinity And NaN on Chromium CSS - 1",
        "excerpt":"Issue: http://crbug.com/1076508 Patches:   https://chromium-review.googlesource.com/c/chromium/src/+/2465414I’ll write down to this blog about the log of activity on Chromium project. Due to this is a function implementation, The article could be separated. This article contains an inspection and research log about the function implementation. https://developer.mozilla.org/en-US/docs/Web/CSS/calc() There are calc function in CSS. The example of usage ‘calc’: div {\twidth: calc(10*2px);}The result of above will be 20px for width property. Following article will describe feature implementation for this function. When I’ve been trying to find something to do on chromium monorail, I’ve found this issue. I could’ve seen the simplest body of issue. I thought this is kind of easy and straightforward. I'm told that per the spec, calc(1px/0) should compute to infinity and not be a parse error.Testcase:&lt;div style=\"width: calc(1px/0); height: 10px; background: green;\"&gt;&lt;/div&gt;http://plexode.com/eval3/#s=aekVQXANJVQMbAx1yAXgePQOCGwFEQk1ECRJRWRARChwBg50SEaWqi51IU0ZGTxyaHx0Qch8DXgA=These lines of words are the start point of our project. When I find this issue, I’ve read the spec. CSS3 and MDN say “Zero division should be ignored”. So, I’ve created a question for the author “Due to the spec, Zero division should be ignored. Could you give me the spec about this issue?” And I can get a response from the question. “CSS Values and Units Module Level 4”. Following the spec, ‘infinity’ and ‘NaN’ should be supported on calc function.So, I’ve put my name on the owner and tried inspection. Firstly I did is trying to find where the calc function was evaluated. The basic idea was: ‘calc function should be parsed on CSS Parser’ Following grep command reduces the enormous search result. So I’ve read source codes in parser directory. To describe below commend, commend will search ‘calc(‘ and ignore character case and only -.cc files exclude -test.cc files. grep 'calc(' -rni --include=*.cc --exclude=*test.cc I’ve found the comment as I highlighted above. For now, it could have been possible to search via identifier constant like k’Token’ (i.e. kCalc) Because the chromium project maintains identifiers using json5 files. Inside of them:  We could find the source code. Simply, We could search kCalc constant usages to figure out where the expression is evaluated.  There are about 10 files related to kCalc. And we could find the evaluation part in ‘third_party/blink/renderer/core/css/css_math_expression_node.cc’. (I guess we could find what we want like this way) the calc function calculates the four fundamental operations recursively. This is an enjoyable part :) . Simply, Parse function called→Additive function called→Multiplicative function called → Parse function called(Recursion). Actually, These implementations are declared on the specification. Following is the notation in the spec.   I’ll leave the URL of the detailed implementation above. If you are interested, please click the link and see the source codes. And I think this is great entry point of this issue. Now we can implement infinity and NaN using the token on the part of the calculation. Actually, In the first CL, I didn’t notice I should implement ‘NaN’ in the code level. After code review, ‘NaN’ is added. Therefore, In this article, didn’t show ‘NaN’. Followed the function calls, We could get: The calculation part. Let’s think simply. Returning ‘std::numeric_limits::infinity()’ if op is ‘CSSMathOperator::kDivide’. That’s a kind of solution. Therefore I’ve added like: For the token:  I thought We should return the value with the token string is ‘infinity’ or ‘-infinity’ or ‘nan’. Test codes I’ve written the test code. The problems with writing source codes are wpt test failure because there are different results not implemented ‘round’ function and failure blink_unittests cause the test used other codes. On blink_unittests, the expressions are parsed by sizes_math_function_parser. So the tests are existed in sizes_math_function_parser_test.cc.  This tests are evaluated ‘CalcToReversePolishNotation’ function in ‘third_party/blink/renderer/core/css/parser/sizes_math_function_parser.cc’ . And The parser is implemented by stack. So we need to add our case. AppendInfinity() denotes add infinity into the stack. We could see the case in switch expression: case kIdentToken:        if (EqualIgnoringASCIICase(token.Value(), \"infinity\") ||            EqualIgnoringASCIICase(token.Value(), \"-infinity\")) {          AppendInfinity(token);          break;        }        return false;One of the problems with unittest is resolved. And I added new test cases in blink_web_tests. There are javascript based tests. I’ve used dumpAsText() function that generates or compares the text-based result (-expected.txt) from the DOM rendered page. Following is the new test file in blink/web_tests/css3/calc/calc-infinity.html: &lt;!DOCTYPE HTML&gt;&lt;div id=\"dummy\"&gt;&lt;/div&gt;&lt;div id=\"results\"&gt;Calc could handle an infinity value&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;script&gt;if (window.testRunner)    testRunner.dumpAsText();var tests = [    \"1px * infinity / infinity\",    \"1px * 0 * infinity\",    \"1px * (infinity + -infinity)\",    \"1px * (-infinity + infinity)\",    \"1px * (infinity - infinity)\",    \"1px * infinity\",    \"1px * -infinity\",    \"1px * (infinity + infinity)\",    \"1px * (-infinity + -infinity)\",    \"1px * 1/infinity\",    \"1px * infinity * infinity\",    \"1px * -infinity * -infinity\",];var results = document.getElementById(\"results\");var dummy = document.getElementById(\"dummy\");for (var i = 0; i &lt; tests.length; ++i) {    var expression = tests[i];    dummy.style.width = 'calc(' + expression + ')';    results.innerHTML += expression + \" =&gt; \" + dummy.style.width + \"&lt;br&gt;\";}&lt;/script&gt;The result of above are saved as ‘blink/web_tests/css3/calc/calc-infinity-expected.txt’: Calc could handle an infinity value1px * infinity / infinity =&gt;1px * 0 * infinity =&gt;1px * (infinity + -infinity) =&gt;1px * (-infinity + infinity) =&gt;1px * (infinity - infinity) =&gt;1px * infinity =&gt; calc(infpx)1px * -infinity =&gt; calc(-infpx)1px * (infinity + infinity) =&gt; calc(infpx)1px * (-infinity + -infinity) =&gt; calc(-infpx)1px * 1/infinity =&gt; calc(0px)1px * infinity * infinity =&gt; calc(infpx)1px * -infinity * -infinity =&gt; calc(infpx)Write Patch After writing the changes, I’ve tried to make clean codes. And formatting using ‘git cl format’. And then I’ve uploaded my patch to chromium gerrit with following commit messages:   I guess this subject should be separated. So It’s better to cut here. Perhaps, Next article will be about ‘code review’, and change from the code review. ","categories": ["Chromium"],
        "tags": ["Chromium","C++","Web Engine","HTML/CSS","InfinityAndNaN","DevLog"],
        "url": "https://devsdk.github.io/chromium/2020/12/24/ChromiumCSSInfinityAndNaN-1.html"
      },]
